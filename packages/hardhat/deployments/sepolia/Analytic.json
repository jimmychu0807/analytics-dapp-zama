{
  "address": "0x5366a157ca0FD369B843Acd1CfB15f31B541ccF3",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "uint64",
          "name": "qId",
          "type": "uint64"
        },
        {
          "internalType": "address",
          "name": "sender",
          "type": "address"
        }
      ],
      "name": "AlreadyAnswered",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint64",
          "name": "queryReqId",
          "type": "uint64"
        }
      ],
      "name": "InvalidQueryRequest",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint64",
          "name": "qId",
          "type": "uint64"
        }
      ],
      "name": "InvalidQuestion",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "reason",
          "type": "string"
        }
      ],
      "name": "InvalidQuestionMetaParam",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "reason",
          "type": "string"
        }
      ],
      "name": "InvalidQuestionParam",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint64",
          "name": "qId",
          "type": "uint64"
        },
        {
          "internalType": "uint256",
          "name": "metaAnsLen",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "metaOptLen",
          "type": "uint256"
        }
      ],
      "name": "MetaAnswerNumberNotMatch",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint64",
          "name": "queryReqId",
          "type": "uint64"
        }
      ],
      "name": "NotQueryOwner",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint64",
          "name": "qId",
          "type": "uint64"
        }
      ],
      "name": "NotQuestionAdmin",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint64",
          "name": "queryReqId",
          "type": "uint64"
        }
      ],
      "name": "QueryHasCompleted",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint64",
          "name": "queryReqId",
          "type": "uint64"
        }
      ],
      "name": "QueryNotCompleted",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint64",
          "name": "qId",
          "type": "uint64"
        }
      ],
      "name": "QueryThresholdNotReach",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint64",
          "name": "qId",
          "type": "uint64"
        }
      ],
      "name": "QuestionAlreadyClosed",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint64",
          "name": "qId",
          "type": "uint64"
        }
      ],
      "name": "QuestionNotOpenYet",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint64",
          "name": "qId",
          "type": "uint64"
        },
        {
          "internalType": "address",
          "name": "sender",
          "type": "address"
        }
      ],
      "name": "RejectAnswer",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint64",
          "name": "qId",
          "type": "uint64"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "sender",
          "type": "address"
        }
      ],
      "name": "ConfirmAnswer",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint64",
          "name": "reqId",
          "type": "uint64"
        }
      ],
      "name": "QueryExecutionCompleted",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint64",
          "name": "reqId",
          "type": "uint64"
        },
        {
          "indexed": false,
          "internalType": "uint64",
          "name": "accSteps",
          "type": "uint64"
        },
        {
          "indexed": false,
          "internalType": "uint64",
          "name": "ttl",
          "type": "uint64"
        }
      ],
      "name": "QueryExecutionRunning",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint64",
          "name": "reqId",
          "type": "uint64"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "owner",
          "type": "address"
        }
      ],
      "name": "QueryRequestCreated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint64",
          "name": "reqId",
          "type": "uint64"
        }
      ],
      "name": "QueryRequestDeleted",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint64",
          "name": "qId",
          "type": "uint64"
        }
      ],
      "name": "QuestionClosed",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "sender",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint64",
          "name": "qId",
          "type": "uint64"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "startTime",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "endTime",
          "type": "uint256"
        }
      ],
      "name": "QuestionCreated",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "MAX_METAS",
      "outputs": [
        {
          "internalType": "uint16",
          "name": "",
          "type": "uint16"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "STATS_ANS_SIZE",
      "outputs": [
        {
          "internalType": "uint8",
          "name": "",
          "type": "uint8"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint64",
          "name": "qId",
          "type": "uint64"
        },
        {
          "internalType": "einput",
          "name": "ans",
          "type": "bytes32"
        },
        {
          "internalType": "einput[]",
          "name": "metaAns",
          "type": "bytes32[]"
        },
        {
          "internalType": "bytes",
          "name": "inputProof",
          "type": "bytes"
        }
      ],
      "name": "answer",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint64",
          "name": "qId",
          "type": "uint64"
        }
      ],
      "name": "closeQuestion",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "reqId",
          "type": "uint256"
        },
        {
          "internalType": "bool",
          "name": "decValid",
          "type": "bool"
        }
      ],
      "name": "confirmOrRejectAnswer",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint64",
          "name": "reqId",
          "type": "uint64"
        }
      ],
      "name": "deleteQuery",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint64",
          "name": "reqId",
          "type": "uint64"
        },
        {
          "internalType": "uint32",
          "name": "steps",
          "type": "uint32"
        }
      ],
      "name": "executeQuery",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint64",
          "name": "qId",
          "type": "uint64"
        }
      ],
      "name": "getAnsLen",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint64",
          "name": "reqId",
          "type": "uint64"
        }
      ],
      "name": "getQueryRequest",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint64",
              "name": "questionId",
              "type": "uint64"
            },
            {
              "internalType": "address",
              "name": "owner",
              "type": "address"
            },
            {
              "components": [
                {
                  "internalType": "uint8",
                  "name": "metaOpt",
                  "type": "uint8"
                },
                {
                  "internalType": "enum IAnalytic.PredicateOp",
                  "name": "op",
                  "type": "uint8"
                },
                {
                  "internalType": "uint32",
                  "name": "metaVal",
                  "type": "uint32"
                }
              ],
              "internalType": "struct IAnalytic.Predicate[]",
              "name": "predicates",
              "type": "tuple[]"
            },
            {
              "internalType": "euint32[]",
              "name": "acc",
              "type": "uint256[]"
            },
            {
              "internalType": "euint32",
              "name": "ansCount",
              "type": "uint256"
            },
            {
              "internalType": "uint32",
              "name": "accSteps",
              "type": "uint32"
            },
            {
              "internalType": "enum IAnalytic.RequestState",
              "name": "state",
              "type": "uint8"
            }
          ],
          "internalType": "struct IAnalytic.QueryRequest",
          "name": "",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint64",
          "name": "reqId",
          "type": "uint64"
        }
      ],
      "name": "getQueryResult",
      "outputs": [
        {
          "components": [
            {
              "internalType": "euint32[]",
              "name": "acc",
              "type": "uint256[]"
            },
            {
              "internalType": "euint32",
              "name": "filteredAnsCount",
              "type": "uint256"
            },
            {
              "internalType": "uint32",
              "name": "ttlAnsCount",
              "type": "uint32"
            }
          ],
          "internalType": "struct IAnalytic.QueryResult",
          "name": "",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint64",
          "name": "qId",
          "type": "uint64"
        }
      ],
      "name": "getQuestion",
      "outputs": [
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "string",
                  "name": "text",
                  "type": "string"
                },
                {
                  "internalType": "string[]",
                  "name": "options",
                  "type": "string[]"
                },
                {
                  "internalType": "uint32",
                  "name": "min",
                  "type": "uint32"
                },
                {
                  "internalType": "uint32",
                  "name": "max",
                  "type": "uint32"
                },
                {
                  "internalType": "enum QuestionSpecLib.QuestionType",
                  "name": "t",
                  "type": "uint8"
                }
              ],
              "internalType": "struct QuestionSpecLib.QuestionSpec",
              "name": "main",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "string",
                  "name": "text",
                  "type": "string"
                },
                {
                  "internalType": "string[]",
                  "name": "options",
                  "type": "string[]"
                },
                {
                  "internalType": "uint32",
                  "name": "min",
                  "type": "uint32"
                },
                {
                  "internalType": "uint32",
                  "name": "max",
                  "type": "uint32"
                },
                {
                  "internalType": "enum QuestionSpecLib.QuestionType",
                  "name": "t",
                  "type": "uint8"
                }
              ],
              "internalType": "struct QuestionSpecLib.QuestionSpec[]",
              "name": "metas",
              "type": "tuple[]"
            },
            {
              "internalType": "uint256",
              "name": "startTime",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "endTime",
              "type": "uint256"
            },
            {
              "internalType": "enum IAnalytic.QuestionState",
              "name": "state",
              "type": "uint8"
            },
            {
              "internalType": "uint32",
              "name": "queryThreshold",
              "type": "uint32"
            }
          ],
          "internalType": "struct IAnalytic.Question",
          "name": "",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "user",
          "type": "address"
        },
        {
          "internalType": "uint64",
          "name": "qId",
          "type": "uint64"
        }
      ],
      "name": "getUserQueryRequestList",
      "outputs": [
        {
          "internalType": "uint64[]",
          "name": "",
          "type": "uint64[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint64",
          "name": "",
          "type": "uint64"
        },
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "hasAnswered",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "string",
              "name": "text",
              "type": "string"
            },
            {
              "internalType": "string[]",
              "name": "options",
              "type": "string[]"
            },
            {
              "internalType": "uint32",
              "name": "min",
              "type": "uint32"
            },
            {
              "internalType": "uint32",
              "name": "max",
              "type": "uint32"
            },
            {
              "internalType": "enum QuestionSpecLib.QuestionType",
              "name": "t",
              "type": "uint8"
            }
          ],
          "internalType": "struct QuestionSpecLib.QuestionSpec",
          "name": "_main",
          "type": "tuple"
        },
        {
          "components": [
            {
              "internalType": "string",
              "name": "text",
              "type": "string"
            },
            {
              "internalType": "string[]",
              "name": "options",
              "type": "string[]"
            },
            {
              "internalType": "uint32",
              "name": "min",
              "type": "uint32"
            },
            {
              "internalType": "uint32",
              "name": "max",
              "type": "uint32"
            },
            {
              "internalType": "enum QuestionSpecLib.QuestionType",
              "name": "t",
              "type": "uint8"
            }
          ],
          "internalType": "struct QuestionSpecLib.QuestionSpec[]",
          "name": "_metas",
          "type": "tuple[]"
        },
        {
          "internalType": "uint256",
          "name": "_startTime",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_endTime",
          "type": "uint256"
        },
        {
          "internalType": "uint32",
          "name": "_queryThreshold",
          "type": "uint32"
        }
      ],
      "name": "newQuestion",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "nextQueryRequestId",
      "outputs": [
        {
          "internalType": "uint64",
          "name": "",
          "type": "uint64"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "nextQuestionId",
      "outputs": [
        {
          "internalType": "uint64",
          "name": "",
          "type": "uint64"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint64",
          "name": "",
          "type": "uint64"
        }
      ],
      "name": "queryRequests",
      "outputs": [
        {
          "internalType": "uint64",
          "name": "questionId",
          "type": "uint64"
        },
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "internalType": "euint32",
          "name": "ansCount",
          "type": "uint256"
        },
        {
          "internalType": "uint32",
          "name": "accSteps",
          "type": "uint32"
        },
        {
          "internalType": "enum IAnalytic.RequestState",
          "name": "state",
          "type": "uint8"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint64",
          "name": "",
          "type": "uint64"
        },
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "questionAdmins",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint64",
          "name": "",
          "type": "uint64"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "questionAnswers",
      "outputs": [
        {
          "internalType": "euint32",
          "name": "val",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint64",
          "name": "",
          "type": "uint64"
        }
      ],
      "name": "questions",
      "outputs": [
        {
          "components": [
            {
              "internalType": "string",
              "name": "text",
              "type": "string"
            },
            {
              "internalType": "string[]",
              "name": "options",
              "type": "string[]"
            },
            {
              "internalType": "uint32",
              "name": "min",
              "type": "uint32"
            },
            {
              "internalType": "uint32",
              "name": "max",
              "type": "uint32"
            },
            {
              "internalType": "enum QuestionSpecLib.QuestionType",
              "name": "t",
              "type": "uint8"
            }
          ],
          "internalType": "struct QuestionSpecLib.QuestionSpec",
          "name": "main",
          "type": "tuple"
        },
        {
          "internalType": "uint256",
          "name": "startTime",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "endTime",
          "type": "uint256"
        },
        {
          "internalType": "enum IAnalytic.QuestionState",
          "name": "state",
          "type": "uint8"
        },
        {
          "internalType": "uint32",
          "name": "queryThreshold",
          "type": "uint32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint64",
          "name": "qId",
          "type": "uint64"
        },
        {
          "components": [
            {
              "internalType": "uint8",
              "name": "metaOpt",
              "type": "uint8"
            },
            {
              "internalType": "enum IAnalytic.PredicateOp",
              "name": "op",
              "type": "uint8"
            },
            {
              "internalType": "uint32",
              "name": "metaVal",
              "type": "uint32"
            }
          ],
          "internalType": "struct IAnalytic.Predicate[]",
          "name": "predicates",
          "type": "tuple[]"
        }
      ],
      "name": "requestQuery",
      "outputs": [
        {
          "internalType": "uint64",
          "name": "reqId",
          "type": "uint64"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "userQueries",
      "outputs": [
        {
          "internalType": "uint64",
          "name": "",
          "type": "uint64"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x552fc440587a993256b03593558577fc51a8496533bcee623158904f359dbd91",
  "receipt": {
    "to": null,
    "from": "0xeB10092a57e4fCb7260e05E4d3d2D29c84339758",
    "contractAddress": "0x5366a157ca0FD369B843Acd1CfB15f31B541ccF3",
    "transactionIndex": 120,
    "gasUsed": "3914161",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x5fe1ee4536676c935724286689654f1226c461e213779af54af7a7b77e1b985e",
    "transactionHash": "0x552fc440587a993256b03593558577fc51a8496533bcee623158904f359dbd91",
    "logs": [],
    "blockNumber": 8308348,
    "cumulativeGasUsed": "19835935",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "96fa4d657a1a4c5992f6787f5a94d22c",
  "metadata": "{\"compiler\":{\"version\":\"0.8.24+commit.e11b9ed9\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"qId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"AlreadyAnswered\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"queryReqId\",\"type\":\"uint64\"}],\"name\":\"InvalidQueryRequest\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"qId\",\"type\":\"uint64\"}],\"name\":\"InvalidQuestion\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"reason\",\"type\":\"string\"}],\"name\":\"InvalidQuestionMetaParam\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"reason\",\"type\":\"string\"}],\"name\":\"InvalidQuestionParam\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"qId\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"metaAnsLen\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"metaOptLen\",\"type\":\"uint256\"}],\"name\":\"MetaAnswerNumberNotMatch\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"queryReqId\",\"type\":\"uint64\"}],\"name\":\"NotQueryOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"qId\",\"type\":\"uint64\"}],\"name\":\"NotQuestionAdmin\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"queryReqId\",\"type\":\"uint64\"}],\"name\":\"QueryHasCompleted\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"queryReqId\",\"type\":\"uint64\"}],\"name\":\"QueryNotCompleted\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"qId\",\"type\":\"uint64\"}],\"name\":\"QueryThresholdNotReach\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"qId\",\"type\":\"uint64\"}],\"name\":\"QuestionAlreadyClosed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"qId\",\"type\":\"uint64\"}],\"name\":\"QuestionNotOpenYet\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"qId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RejectAnswer\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"qId\",\"type\":\"uint64\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"ConfirmAnswer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"reqId\",\"type\":\"uint64\"}],\"name\":\"QueryExecutionCompleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"reqId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"accSteps\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"ttl\",\"type\":\"uint64\"}],\"name\":\"QueryExecutionRunning\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"reqId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"QueryRequestCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"reqId\",\"type\":\"uint64\"}],\"name\":\"QueryRequestDeleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"qId\",\"type\":\"uint64\"}],\"name\":\"QuestionClosed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"qId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"}],\"name\":\"QuestionCreated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MAX_METAS\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"STATS_ANS_SIZE\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"qId\",\"type\":\"uint64\"},{\"internalType\":\"einput\",\"name\":\"ans\",\"type\":\"bytes32\"},{\"internalType\":\"einput[]\",\"name\":\"metaAns\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes\",\"name\":\"inputProof\",\"type\":\"bytes\"}],\"name\":\"answer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"qId\",\"type\":\"uint64\"}],\"name\":\"closeQuestion\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"reqId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"decValid\",\"type\":\"bool\"}],\"name\":\"confirmOrRejectAnswer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"reqId\",\"type\":\"uint64\"}],\"name\":\"deleteQuery\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"reqId\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"steps\",\"type\":\"uint32\"}],\"name\":\"executeQuery\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"qId\",\"type\":\"uint64\"}],\"name\":\"getAnsLen\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"reqId\",\"type\":\"uint64\"}],\"name\":\"getQueryRequest\",\"outputs\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"questionId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"metaOpt\",\"type\":\"uint8\"},{\"internalType\":\"enum IAnalytic.PredicateOp\",\"name\":\"op\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"metaVal\",\"type\":\"uint32\"}],\"internalType\":\"struct IAnalytic.Predicate[]\",\"name\":\"predicates\",\"type\":\"tuple[]\"},{\"internalType\":\"euint32[]\",\"name\":\"acc\",\"type\":\"uint256[]\"},{\"internalType\":\"euint32\",\"name\":\"ansCount\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"accSteps\",\"type\":\"uint32\"},{\"internalType\":\"enum IAnalytic.RequestState\",\"name\":\"state\",\"type\":\"uint8\"}],\"internalType\":\"struct IAnalytic.QueryRequest\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"reqId\",\"type\":\"uint64\"}],\"name\":\"getQueryResult\",\"outputs\":[{\"components\":[{\"internalType\":\"euint32[]\",\"name\":\"acc\",\"type\":\"uint256[]\"},{\"internalType\":\"euint32\",\"name\":\"filteredAnsCount\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"ttlAnsCount\",\"type\":\"uint32\"}],\"internalType\":\"struct IAnalytic.QueryResult\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"qId\",\"type\":\"uint64\"}],\"name\":\"getQuestion\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"text\",\"type\":\"string\"},{\"internalType\":\"string[]\",\"name\":\"options\",\"type\":\"string[]\"},{\"internalType\":\"uint32\",\"name\":\"min\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"max\",\"type\":\"uint32\"},{\"internalType\":\"enum QuestionSpecLib.QuestionType\",\"name\":\"t\",\"type\":\"uint8\"}],\"internalType\":\"struct QuestionSpecLib.QuestionSpec\",\"name\":\"main\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"text\",\"type\":\"string\"},{\"internalType\":\"string[]\",\"name\":\"options\",\"type\":\"string[]\"},{\"internalType\":\"uint32\",\"name\":\"min\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"max\",\"type\":\"uint32\"},{\"internalType\":\"enum QuestionSpecLib.QuestionType\",\"name\":\"t\",\"type\":\"uint8\"}],\"internalType\":\"struct QuestionSpecLib.QuestionSpec[]\",\"name\":\"metas\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"enum IAnalytic.QuestionState\",\"name\":\"state\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"queryThreshold\",\"type\":\"uint32\"}],\"internalType\":\"struct IAnalytic.Question\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"qId\",\"type\":\"uint64\"}],\"name\":\"getUserQueryRequestList\",\"outputs\":[{\"internalType\":\"uint64[]\",\"name\":\"\",\"type\":\"uint64[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"hasAnswered\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"text\",\"type\":\"string\"},{\"internalType\":\"string[]\",\"name\":\"options\",\"type\":\"string[]\"},{\"internalType\":\"uint32\",\"name\":\"min\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"max\",\"type\":\"uint32\"},{\"internalType\":\"enum QuestionSpecLib.QuestionType\",\"name\":\"t\",\"type\":\"uint8\"}],\"internalType\":\"struct QuestionSpecLib.QuestionSpec\",\"name\":\"_main\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"text\",\"type\":\"string\"},{\"internalType\":\"string[]\",\"name\":\"options\",\"type\":\"string[]\"},{\"internalType\":\"uint32\",\"name\":\"min\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"max\",\"type\":\"uint32\"},{\"internalType\":\"enum QuestionSpecLib.QuestionType\",\"name\":\"t\",\"type\":\"uint8\"}],\"internalType\":\"struct QuestionSpecLib.QuestionSpec[]\",\"name\":\"_metas\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"_startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_endTime\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"_queryThreshold\",\"type\":\"uint32\"}],\"name\":\"newQuestion\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextQueryRequestId\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextQuestionId\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"queryRequests\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"questionId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"euint32\",\"name\":\"ansCount\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"accSteps\",\"type\":\"uint32\"},{\"internalType\":\"enum IAnalytic.RequestState\",\"name\":\"state\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"questionAdmins\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"questionAnswers\",\"outputs\":[{\"internalType\":\"euint32\",\"name\":\"val\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"questions\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"text\",\"type\":\"string\"},{\"internalType\":\"string[]\",\"name\":\"options\",\"type\":\"string[]\"},{\"internalType\":\"uint32\",\"name\":\"min\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"max\",\"type\":\"uint32\"},{\"internalType\":\"enum QuestionSpecLib.QuestionType\",\"name\":\"t\",\"type\":\"uint8\"}],\"internalType\":\"struct QuestionSpecLib.QuestionSpec\",\"name\":\"main\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"enum IAnalytic.QuestionState\",\"name\":\"state\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"queryThreshold\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"qId\",\"type\":\"uint64\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"metaOpt\",\"type\":\"uint8\"},{\"internalType\":\"enum IAnalytic.PredicateOp\",\"name\":\"op\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"metaVal\",\"type\":\"uint32\"}],\"internalType\":\"struct IAnalytic.Predicate[]\",\"name\":\"predicates\",\"type\":\"tuple[]\"}],\"name\":\"requestQuery\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"reqId\",\"type\":\"uint64\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userQueries\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/Analytic.sol\":\"Analytic\"},\"evmVersion\":\"cancun\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"none\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":800},\"remappings\":[],\"viaIR\":true},\"sources\":{\"contracts/Analytic.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause-Clear\\npragma solidity ^0.8.24;\\n\\nimport \\\"fhevm/lib/TFHE.sol\\\";\\nimport { SepoliaZamaFHEVMConfig } from \\\"fhevm/config/ZamaFHEVMConfig.sol\\\";\\nimport { SepoliaZamaGatewayConfig } from \\\"fhevm/config/ZamaGatewayConfig.sol\\\";\\nimport \\\"fhevm/gateway/GatewayCaller.sol\\\";\\nimport { IAnalytic } from \\\"./interfaces/IAnalytic.sol\\\";\\nimport { QuestionSpecLib } from \\\"./QuestionSpecLib.sol\\\";\\nimport { console } from \\\"hardhat/console.sol\\\";\\n\\ncontract Analytic is SepoliaZamaFHEVMConfig, SepoliaZamaGatewayConfig, GatewayCaller, IAnalytic {\\n    // --- library ---\\n    using QuestionSpecLib for QuestionSpecLib.QuestionSpec;\\n\\n    // --- constant ---\\n    uint16 public constant MAX_METAS = 4;\\n    // has to correspond to the sie of enum StatsAnsPos\\n    uint8 public constant STATS_ANS_SIZE = 3;\\n\\n    // --- storage ---\\n    uint64 public nextQuestionId = 0;\\n    mapping(uint64 => Question) public questions;\\n    mapping(uint64 => Answer[]) public questionAnswers;\\n    mapping(uint64 => mapping(address => bool)) public questionAdmins;\\n    mapping(uint64 => mapping(address => bool)) public hasAnswered;\\n\\n    uint64 public nextQueryRequestId = 0;\\n    mapping(uint64 => QueryRequest) public queryRequests;\\n    mapping(address => uint64[]) public userQueries;\\n\\n    // --- modifier ---\\n    modifier questionValidAndOpen(uint64 qId) {\\n        if (qId >= nextQuestionId) revert InvalidQuestion(qId);\\n        Question storage question = questions[qId];\\n\\n        if (question.state == QuestionState.Closed) revert QuestionAlreadyClosed(qId);\\n        if (block.timestamp > question.endTime) revert QuestionAlreadyClosed(qId);\\n        if (block.timestamp < question.startTime) revert QuestionNotOpenYet(qId);\\n        _;\\n    }\\n\\n    modifier isQuestionAdmin(uint64 qId, address sender) {\\n        if (qId >= nextQuestionId) revert InvalidQuestion(qId);\\n        if (!questionAdmins[qId][sender]) revert NotQuestionAdmin(qId);\\n        _;\\n    }\\n\\n    modifier aboveQueryThreshold(uint64 qId) {\\n        Question storage question = questions[qId];\\n        if (getAnsLen(qId) < question.queryThreshold) revert QueryThresholdNotReach(qId);\\n        _;\\n    }\\n\\n    modifier queryValidIsOwner(uint64 qId, address sender) {\\n        if (qId >= nextQueryRequestId) revert InvalidQueryRequest(qId);\\n        QueryRequest storage req = queryRequests[qId];\\n        if (sender != req.owner) revert NotQueryOwner(qId);\\n        _;\\n    }\\n\\n    // --- viewer ---\\n    function getQuestion(uint64 qId) public view returns (Question memory) {\\n        if (qId >= nextQuestionId) revert InvalidQuestion(qId);\\n        return questions[qId];\\n    }\\n\\n    function getAnsLen(uint64 qId) public view returns (uint256) {\\n        if (qId >= nextQuestionId) revert InvalidQuestion(qId);\\n        Answer[] memory answers = questionAnswers[qId];\\n        return answers.length;\\n    }\\n\\n    function getUserQueryRequestList(address user, uint64 qId) public view returns (uint64[] memory) {\\n        uint64[] storage queries = userQueries[user];\\n\\n        uint256 len = 0;\\n        for (uint256 i = 0; i < queries.length; i++) {\\n            QueryRequest storage qr = queryRequests[queries[i]];\\n            if (qr.questionId == qId) len += 1;\\n        }\\n        uint64[] memory list = new uint64[](len);\\n\\n        // Early return as the list is going to be empty\\n        if (len == 0) return list;\\n\\n        uint256 idx = 0;\\n        for (uint256 i = 0; i < queries.length; i++) {\\n            QueryRequest storage qr = queryRequests[queries[i]];\\n            if (qr.questionId == qId) {\\n                list[idx] = queries[i];\\n                idx += 1;\\n            }\\n        }\\n        return list;\\n    }\\n\\n    function getQueryRequest(uint64 reqId) public view returns (QueryRequest memory) {\\n        QueryRequest storage req = queryRequests[reqId];\\n        return req;\\n    }\\n\\n    function getQueryResult(\\n        uint64 reqId\\n    ) public view queryValidIsOwner(reqId, msg.sender) returns (QueryResult memory) {\\n        // require the query request state to be completed\\n        QueryRequest storage req = queryRequests[reqId];\\n        if (req.state != RequestState.Completed) revert QueryNotCompleted(reqId);\\n\\n        return QueryResult({ acc: req.acc, filteredAnsCount: req.ansCount, ttlAnsCount: req.accSteps });\\n    }\\n\\n    // --- write function ---\\n    function newQuestion(\\n        QuestionSpecLib.QuestionSpec calldata _main,\\n        QuestionSpecLib.QuestionSpec[] calldata _metas,\\n        uint256 _startTime,\\n        uint256 _endTime,\\n        uint32 _queryThreshold\\n    ) public {\\n        if (_metas.length > MAX_METAS) revert InvalidQuestionParam(\\\"max meta options exceeded\\\");\\n        if (_startTime >= _endTime) revert InvalidQuestionParam(\\\"Start time should be less than end time\\\");\\n\\n        _main.validate();\\n        for (uint256 i = 0; i < _metas.length; i++) _metas[i].validate();\\n\\n        uint64 qId = nextQuestionId;\\n        Question memory question = Question({\\n            main: _main,\\n            metas: _metas,\\n            startTime: _startTime,\\n            endTime: _endTime,\\n            state: QuestionState.Initialized,\\n            queryThreshold: _queryThreshold\\n        });\\n        questionAdmins[qId][msg.sender] = true;\\n        questions[qId] = question;\\n        nextQuestionId += 1;\\n\\n        emit QuestionCreated(msg.sender, qId, _startTime, _endTime);\\n    }\\n\\n    function closeQuestion(uint64 qId) public isQuestionAdmin(qId, msg.sender) {\\n        Question storage question = questions[qId];\\n        if (question.state != QuestionState.Closed) {\\n            question.state = QuestionState.Closed;\\n            emit QuestionClosed(qId);\\n        }\\n    }\\n\\n    function answer(\\n        uint64 qId,\\n        einput ans,\\n        einput[] calldata metaAns,\\n        bytes calldata inputProof\\n    ) public questionValidAndOpen(qId) {\\n        if (hasAnswered[qId][msg.sender]) revert AlreadyAnswered(qId, msg.sender);\\n\\n        Question storage question = questions[qId];\\n\\n        // Check the metaAns len has to be equal to question metaOpts\\n        if (metaAns.length != question.metas.length)\\n            revert MetaAnswerNumberNotMatch(qId, metaAns.length, question.metas.length);\\n\\n        // Update the question state\\n        if (question.state != QuestionState.Open) question.state = QuestionState.Open;\\n\\n        // Check the encrypted input and put result in eValid.\\n        // Later on we will decrypt this value to check the validity\\n        euint32 eAns = TFHE.asEuint32(ans, inputProof);\\n        TFHE.allowThis(eAns);\\n\\n        ebool eValid = TFHE.and(TFHE.ge(eAns, question.main.min), TFHE.le(eAns, question.main.max));\\n\\n        euint32[] memory eMetaAns = new euint32[](metaAns.length);\\n        for (uint256 mIdx = 0; mIdx < metaAns.length; ++mIdx) {\\n            eMetaAns[mIdx] = TFHE.asEuint32(metaAns[mIdx], inputProof);\\n            TFHE.allowThis(eMetaAns[mIdx]);\\n\\n            eValid = TFHE.and(\\n                eValid,\\n                TFHE.and(\\n                    TFHE.ge(eMetaAns[mIdx], question.metas[mIdx].min),\\n                    TFHE.le(eMetaAns[mIdx], question.metas[mIdx].max)\\n                )\\n            );\\n        }\\n\\n        // We only want to decrypt the eValid to either confirm or reject the answer\\n        uint256[] memory cts = new uint256[](1);\\n        cts[0] = Gateway.toUint256(eValid);\\n        uint256 reqId = Gateway.requestDecryption(\\n            cts,\\n            this.confirmOrRejectAnswer.selector,\\n            0,\\n            block.timestamp + 100,\\n            false\\n        );\\n\\n        // Additional parameters to reconstruct back the Answer object\\n        addParamsUint256(reqId, uint256(qId));\\n        addParamsAddress(reqId, msg.sender);\\n        addParamsEUint32(reqId, eAns);\\n        for (uint256 mIdx = 0; mIdx < eMetaAns.length; ++mIdx) {\\n            addParamsEUint32(reqId, eMetaAns[mIdx]);\\n        }\\n    }\\n\\n    function confirmOrRejectAnswer(uint256 reqId, bool decValid) external onlyGateway {\\n        uint64 qId = uint64(getParamsUint256(reqId)[0]);\\n        address sender = getParamsAddress(reqId)[0];\\n\\n        // console.log(\\\"sender: %s, reqId: %s, decValid: %s\\\", sender, reqId, decValid);\\n\\n        if (!decValid) revert RejectAnswer(qId, sender);\\n\\n        // valid Answer\\n        euint32[] memory params = getParamsEUint32(reqId);\\n\\n        // console.log(\\\"qId: %s, param len: %s\\\", qId, params.length);\\n\\n        euint32[] memory metaVals = new euint32[](params.length - 1);\\n        for (uint256 i = 1; i < params.length; i++) {\\n            metaVals[i - 1] = params[i];\\n        }\\n\\n        Answer memory ans = Answer({ val: params[0], metaVals: metaVals });\\n        questionAnswers[qId].push(ans);\\n        hasAnswered[qId][sender] = true;\\n        // console.log(\\\"answer len: %s\\\", questionAnswers[qId].length);\\n\\n        emit ConfirmAnswer(qId, sender);\\n        // console.log(\\\"emit event\\\");\\n    }\\n\\n    function requestQuery(\\n        uint64 qId,\\n        Predicate[] calldata predicates\\n    ) public isQuestionAdmin(qId, msg.sender) aboveQueryThreshold(qId) returns (uint64 reqId) {\\n        reqId = nextQueryRequestId;\\n        Question storage question = questions[qId];\\n\\n        euint32 eZero = TFHE.asEuint32(0);\\n        euint32[] memory acc;\\n\\n        if (question.main.t == QuestionSpecLib.QuestionType.Option) {\\n            acc = new euint32[](question.main.max + 1);\\n            for (uint64 i = 0; i <= question.main.max; i++) {\\n                acc[i] = eZero;\\n            }\\n        } else {\\n            acc = new euint32[](STATS_ANS_SIZE);\\n            acc[uint256(StatsAnsPos.Min)] = TFHE.asEuint32(question.main.max);\\n            acc[uint256(StatsAnsPos.Sum)] = eZero;\\n            acc[uint256(StatsAnsPos.Max)] = TFHE.asEuint32(question.main.min);\\n        }\\n\\n        // create the queryRequest\\n        QueryRequest memory queryReq = QueryRequest({\\n            questionId: qId,\\n            owner: msg.sender,\\n            predicates: predicates,\\n            acc: acc,\\n            accSteps: 0,\\n            ansCount: eZero,\\n            state: RequestState.Initialized\\n        });\\n\\n        queryRequests[reqId] = queryReq;\\n        nextQueryRequestId += 1;\\n        userQueries[msg.sender].push(reqId);\\n\\n        // granting access\\n        for (uint256 i = 0; i < queryReq.acc.length; i++) {\\n            TFHE.allowThis(queryReq.acc[i]);\\n            TFHE.allow(queryReq.acc[i], msg.sender);\\n        }\\n\\n        TFHE.allowThis(queryReq.ansCount);\\n        TFHE.allow(queryReq.ansCount, msg.sender);\\n\\n        emit QueryRequestCreated(reqId, msg.sender);\\n    }\\n\\n    function deleteQuery(uint64 reqId) public queryValidIsOwner(reqId, msg.sender) {\\n        // Can only be deleted by the owner\\n        QueryRequest storage req = queryRequests[reqId];\\n        if (req.owner != msg.sender) revert NotQueryOwner(reqId);\\n        delete queryRequests[reqId];\\n\\n        // TODO: delete it from userQueries storage\\n\\n        emit QueryRequestDeleted(reqId);\\n    }\\n\\n    function executeQuery(uint64 reqId, uint32 steps) public queryValidIsOwner(reqId, msg.sender) {\\n        QueryRequest storage req = queryRequests[reqId];\\n        if (req.state == RequestState.Completed) revert QueryHasCompleted(reqId);\\n\\n        Question storage question = questions[req.questionId];\\n        Answer[] storage answers = questionAnswers[req.questionId];\\n\\n        uint32 actualSteps = steps;\\n        uint32 stepsToEnd = uint32(answers.length) - req.accSteps;\\n        if (stepsToEnd < steps) actualSteps = stepsToEnd;\\n\\n        ebool eTrue = TFHE.asEbool(true);\\n        euint32[] storage acc = req.acc;\\n\\n        for (uint32 ai = req.accSteps; ai < req.accSteps + actualSteps; ai += 1) {\\n            Answer storage ans = answers[ai];\\n            ebool accepted = eTrue;\\n\\n            // connect predicate together with \\\"AND\\\" operator\\n            for (uint256 pi = 0; pi < req.predicates.length; pi += 1) {\\n                accepted = TFHE.and(_checkPredicate(ans, req.predicates[pi]), accepted);\\n            }\\n            req.ansCount = TFHE.add(req.ansCount, TFHE.asEuint32(accepted));\\n\\n            if (question.main.t == QuestionSpecLib.QuestionType.Option) {\\n                _aggregateCountAns(acc, req.questionId, accepted, ans);\\n            } else {\\n                _aggregateStatsAns(acc, accepted, ans);\\n            }\\n        }\\n\\n        // writing back to the storage\\n        req.accSteps += actualSteps;\\n\\n        // granting read access to the req owner of the result\\n        TFHE.allowThis(req.ansCount);\\n        TFHE.allow(req.ansCount, req.owner);\\n        for (uint256 ai = 0; ai < req.acc.length; ai++) {\\n            TFHE.allowThis(req.acc[ai]);\\n            TFHE.allow(req.acc[ai], req.owner);\\n        }\\n\\n        if (req.accSteps == answers.length) {\\n            req.state = RequestState.Completed;\\n            emit QueryExecutionCompleted(reqId);\\n        } else {\\n            emit QueryExecutionRunning(reqId, req.accSteps, uint64(answers.length));\\n        }\\n    }\\n\\n    // --- Internal Helper methods ---\\n    function _aggregateStatsAns(euint32[] storage acc, ebool accepted, Answer storage ans) internal {\\n        // min\\n        uint256 minPos = uint256(StatsAnsPos.Min);\\n        acc[minPos] = TFHE.select(accepted, TFHE.min(acc[minPos], ans.val), acc[minPos]);\\n\\n        // avg - basically summation - avg is computed at client side\\n        uint256 avgPos = uint256(StatsAnsPos.Sum);\\n        acc[avgPos] = TFHE.select(accepted, TFHE.add(acc[avgPos], ans.val), acc[avgPos]);\\n\\n        // max\\n        uint256 maxPos = uint256(StatsAnsPos.Max);\\n        acc[maxPos] = TFHE.select(accepted, TFHE.max(acc[maxPos], ans.val), acc[maxPos]);\\n    }\\n\\n    function _aggregateCountAns(euint32[] storage acc, uint64 qId, ebool accepted, Answer storage ans) internal {\\n        Question storage question = questions[qId];\\n        // Add count\\n        for (uint32 accIdx = 0; accIdx <= question.main.max; accIdx++) {\\n            // cnt is either a 0 or 1\\n            // prettier-ignore\\n            euint32 cnt = TFHE.asEuint32(TFHE.and(\\n                accepted,\\n                TFHE.eq(ans.val, TFHE.asEuint32(accIdx))\\n            ));\\n\\n            acc[accIdx] = TFHE.add(acc[accIdx], cnt);\\n        }\\n    }\\n\\n    function _checkPredicate(Answer storage ans, Predicate storage predicate) internal returns (ebool) {\\n        if (predicate.op == PredicateOp.EQ) return TFHE.eq(ans.metaVals[predicate.metaOpt], predicate.metaVal);\\n        if (predicate.op == PredicateOp.NE) return TFHE.ne(ans.metaVals[predicate.metaOpt], predicate.metaVal);\\n        if (predicate.op == PredicateOp.GE) return TFHE.ge(ans.metaVals[predicate.metaOpt], predicate.metaVal);\\n        return TFHE.le(ans.metaVals[predicate.metaOpt], predicate.metaVal);\\n    }\\n}\\n\",\"keccak256\":\"0x3e6596c60f47814b7c03b9d1bd9e49209ce74f085e3f73ccd48207eca5780b86\",\"license\":\"BSD-3-Clause-Clear\"},\"contracts/QuestionSpecLib.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause-Clear\\npragma solidity ^0.8.24;\\n\\nuint16 constant TXT_MAX_LEN = 512;\\n\\nlibrary QuestionSpecLib {\\n    enum QuestionType {\\n        Option, // For example 1 - count on the options pollers choose\\n        Value // For example 2 - perform min,max,avg on the numeric ans people give\\n    }\\n\\n    struct QuestionSpec {\\n        string text;\\n        string[] options;\\n        uint32 min;\\n        uint32 max;\\n        QuestionType t;\\n    }\\n\\n    error InvalidQuestionSpecParam(string reason);\\n\\n    function validate(QuestionSpec memory self) public pure {\\n        if (bytes(self.text).length > TXT_MAX_LEN) revert InvalidQuestionSpecParam(\\\"questionText max length exceeded\\\");\\n        if (self.t == QuestionType.Option && self.options.length < 2)\\n            revert InvalidQuestionSpecParam(\\\"Options should be greater than 1\\\");\\n        if (self.min >= self.max) revert InvalidQuestionSpecParam(\\\"min should be less than max\\\");\\n    }\\n}\\n\",\"keccak256\":\"0x9164c84e1db922d291362ee8126f9609f9ed9a1d8e7e43b0f7faa6af37986afe\",\"license\":\"BSD-3-Clause-Clear\"},\"contracts/interfaces/IAnalytic.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause-Clear\\npragma solidity ^0.8.24;\\n\\nimport \\\"fhevm/lib/TFHE.sol\\\";\\nimport \\\"../QuestionSpecLib.sol\\\";\\n\\ninterface IAnalytic {\\n    enum StatsAnsPos {\\n        Min,\\n        Sum,\\n        Max\\n    }\\n\\n    enum PredicateOp {\\n        EQ,\\n        NE,\\n        GE,\\n        LE\\n    }\\n\\n    enum RequestState {\\n        Initialized,\\n        Completed\\n    }\\n\\n    enum QuestionState {\\n        Initialized,\\n        Open,\\n        Closed\\n    }\\n\\n    struct Question {\\n        QuestionSpecLib.QuestionSpec main;\\n        QuestionSpecLib.QuestionSpec[] metas;\\n        uint256 startTime;\\n        uint256 endTime;\\n        QuestionState state;\\n        uint32 queryThreshold;\\n    }\\n\\n    struct QueryRequest {\\n        uint64 questionId;\\n        address owner;\\n        Predicate[] predicates;\\n        euint32[] acc;\\n        euint32 ansCount;\\n        uint32 accSteps;\\n        RequestState state;\\n    }\\n\\n    struct QueryResult {\\n        euint32[] acc;\\n        euint32 filteredAnsCount;\\n        uint32 ttlAnsCount;\\n    }\\n\\n    struct Predicate {\\n        uint8 metaOpt;\\n        PredicateOp op;\\n        uint32 metaVal;\\n    }\\n\\n    struct Answer {\\n        euint32 val;\\n        euint32[] metaVals;\\n    }\\n\\n    // All errors\\n    error InvalidQuestionParam(string reason);\\n    error InvalidQuestionMetaParam(string reason);\\n    error InvalidQuestion(uint64 qId);\\n    error QuestionAlreadyClosed(uint64 qId);\\n    error QuestionNotOpenYet(uint64 qId);\\n    error AlreadyAnswered(uint64 qId, address sender);\\n    error MetaAnswerNumberNotMatch(uint64 qId, uint256 metaAnsLen, uint256 metaOptLen);\\n    error RejectAnswer(uint64 qId, address sender);\\n    error NotQuestionAdmin(uint64 qId);\\n    error QueryThresholdNotReach(uint64 qId);\\n\\n    error InvalidQueryRequest(uint64 queryReqId);\\n    error NotQueryOwner(uint64 queryReqId);\\n    error QueryHasCompleted(uint64 queryReqId);\\n    error QueryNotCompleted(uint64 queryReqId);\\n\\n    // All the events\\n    event QuestionCreated(address indexed sender, uint64 indexed qId, uint256 startTime, uint256 endTime);\\n    event QuestionClosed(uint64 indexed qId);\\n    event ConfirmAnswer(uint64 indexed qId, address indexed sender);\\n    event QueryRequestCreated(uint64 reqId, address owner);\\n    event QueryRequestDeleted(uint64 reqId);\\n\\n    event QueryExecutionCompleted(uint64 reqId);\\n    event QueryExecutionRunning(uint64 reqId, uint64 accSteps, uint64 ttl);\\n}\\n\",\"keccak256\":\"0x692a1a27ca15bc24636c6342bdec13878c883671944f82d097ec779399fe93da\",\"license\":\"BSD-3-Clause-Clear\"},\"fhevm/config/ZamaFHEVMConfig.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause-Clear\\npragma solidity ^0.8.24;\\n\\nimport {TFHE} from \\\"../lib/TFHE.sol\\\";\\nimport {FHEVMConfigStruct} from \\\"../lib/Impl.sol\\\";\\n\\n/**\\n * @title   ZamaFHEVMConfig.\\n * @notice  This library returns the TFHE config for different networks\\n *          with the contract addresses for\\n *          (1) ACL, (2) TFHEExecutor, (3) FHEPayment, (4) KMSVerifier,\\n *          which are deployed & maintained by Zama.\\n */\\nlibrary ZamaFHEVMConfig {\\n    function getSepoliaConfig() internal pure returns (FHEVMConfigStruct memory) {\\n        return\\n            FHEVMConfigStruct({\\n                ACLAddress: 0xFee8407e2f5e3Ee68ad77cAE98c434e637f516e5,\\n                TFHEExecutorAddress: 0x687408aB54661ba0b4aeF3a44156c616c6955E07,\\n                FHEPaymentAddress: 0xFb03BE574d14C256D56F09a198B586bdfc0A9de2,\\n                KMSVerifierAddress: 0x9D6891A6240D6130c54ae243d8005063D05fE14b\\n            });\\n    }\\n\\n    function getEthereumConfig() internal pure returns (FHEVMConfigStruct memory) {\\n        /// TODO\\n    }\\n}\\n\\n/**\\n * @title   SepoliaZamaFHEVMConfig.\\n * @dev     This contract can be inherited by a contract wishing to use the FHEVM contracts provided by Zama\\n *          on the Sepolia network (chainId = 11155111).\\n *          Other providers may offer similar contracts deployed at different addresses.\\n *          If you wish to use them, you should rely on the instructions from these providers.\\n */\\ncontract SepoliaZamaFHEVMConfig {\\n    constructor() {\\n        TFHE.setFHEVM(ZamaFHEVMConfig.getSepoliaConfig());\\n    }\\n}\\n\\n/**\\n * @title   EthereumZamaFHEVMConfig.\\n * @dev     This contract can be inherited by a contract wishing to use the FHEVM contracts provided by Zama\\n *          on the Ethereum (mainnet) network (chainId = 1).\\n *          Other providers may offer similar contracts deployed at different addresses.\\n *          If you wish to use them, you should rely on the instructions from these providers.\\n */\\ncontract EthereumZamaFHEVMConfig {\\n    constructor() {\\n        TFHE.setFHEVM(ZamaFHEVMConfig.getEthereumConfig());\\n    }\\n}\\n\",\"keccak256\":\"0x41782f4c707b81399916544fa2e7be94a695fa4ba468542732d29d3e383c0315\",\"license\":\"BSD-3-Clause-Clear\"},\"fhevm/config/ZamaGatewayConfig.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause-Clear\\npragma solidity ^0.8.24;\\n\\nimport {Gateway} from \\\"../gateway/lib/Gateway.sol\\\";\\n\\n/**\\n * @title   ZamaGatewayConfig.\\n * @notice  This library returns the Gateway config for different networks\\n *          with the address of the Gateway contract, which is\\n *          deployed & maintained by Zama.\\n */\\nlibrary ZamaGatewayConfig {\\n    function getSepoliaConfig() internal pure returns (address) {\\n        return 0x33347831500F1e73f0ccCBb95c9f86B94d7b1123;\\n    }\\n\\n    function getEthereumConfig() internal pure returns (address) {\\n        /// TODO\\n    }\\n}\\n\\n/**\\n * @title   SepoliaZamaGatewayConfig\\n * @dev     This contract can be inherited by a contract wishing to use the Gateway service\\n *          provided by Zama on the Sepolia network (chainId = 11155111).\\n *          Other providers may offer other Gateways that are deployed at different addresses.\\n *          If you wish to use them, you should rely on the instructions from these providers.\\n */\\ncontract SepoliaZamaGatewayConfig {\\n    constructor() {\\n        Gateway.setGateway(ZamaGatewayConfig.getSepoliaConfig());\\n    }\\n}\\n\\n/**\\n * @title   EthereumZamaGatewayConfig\\n * @dev     This contract can be inherited by a contract wishing to use the Gateway service\\n *          provided by Zama on the Ethereum (mainnet) network (chainId = 1).\\n *          Other providers may offer other Gateways that are deployed at different addresses.\\n *          If you wish to use them, you should rely on the instructions from these providers.\\n */\\ncontract EthereumZamaGatewayConfig {\\n    constructor() {\\n        Gateway.setGateway(ZamaGatewayConfig.getEthereumConfig());\\n    }\\n}\\n\",\"keccak256\":\"0xbed8bc18db61ffeb5ee31f577ab636d8563df27554e0ca66c53534f0bd82ffbd\",\"license\":\"BSD-3-Clause-Clear\"},\"fhevm/gateway/GatewayCaller.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause-Clear\\n\\npragma solidity ^0.8.24;\\n\\nimport \\\"../lib/TFHE.sol\\\";\\nimport \\\"./lib/Gateway.sol\\\";\\n\\nabstract contract GatewayCaller {\\n    modifier onlyGateway() {\\n        require(msg.sender == Gateway.gatewayContractAddress());\\n        _;\\n    }\\n    mapping(uint256 => ebool[]) private paramsEBool;\\n    mapping(uint256 => euint4[]) private paramsEUint4;\\n    mapping(uint256 => euint8[]) private paramsEUint8;\\n    mapping(uint256 => euint16[]) private paramsEUint16;\\n    mapping(uint256 => euint32[]) private paramsEUint32;\\n    mapping(uint256 => euint64[]) private paramsEUint64;\\n    mapping(uint256 => eaddress[]) private paramsEAddress;\\n    mapping(uint256 => address[]) private paramsAddress;\\n    mapping(uint256 => uint256[]) private paramsUint256;\\n    mapping(uint256 => uint256[]) private requestedHandles;\\n\\n    constructor() {}\\n\\n    function addParamsEBool(uint256 requestID, ebool _ebool) internal {\\n        paramsEBool[requestID].push(_ebool);\\n    }\\n\\n    function addParamsEUint4(uint256 requestID, euint4 _euint4) internal {\\n        paramsEUint4[requestID].push(_euint4);\\n    }\\n\\n    function addParamsEUint8(uint256 requestID, euint8 _euint8) internal {\\n        paramsEUint8[requestID].push(_euint8);\\n    }\\n\\n    function addParamsEUint16(uint256 requestID, euint16 _euint16) internal {\\n        paramsEUint16[requestID].push(_euint16);\\n    }\\n\\n    function addParamsEUint32(uint256 requestID, euint32 _euint32) internal {\\n        paramsEUint32[requestID].push(_euint32);\\n    }\\n\\n    function addParamsEUint64(uint256 requestID, euint64 _euint64) internal {\\n        paramsEUint64[requestID].push(_euint64);\\n    }\\n\\n    function addParamsEAddress(uint256 requestID, eaddress _eaddress) internal {\\n        paramsEAddress[requestID].push(_eaddress);\\n    }\\n\\n    function addParamsAddress(uint256 requestID, address _address) internal {\\n        paramsAddress[requestID].push(_address);\\n    }\\n\\n    function addParamsUint256(uint256 requestID, uint256 _uint) internal {\\n        paramsUint256[requestID].push(_uint);\\n    }\\n\\n    function saveRequestedHandles(uint256 requestID, uint256[] memory handlesList) internal {\\n        require(requestedHandles[requestID].length == 0, \\\"requested handles already saved\\\");\\n        requestedHandles[requestID] = handlesList;\\n    }\\n\\n    function loadRequestedHandles(uint256 requestID) internal view returns (uint256[] memory) {\\n        require(requestedHandles[requestID].length != 0, \\\"requested handles were not saved for this requestID\\\");\\n        return requestedHandles[requestID];\\n    }\\n\\n    function getParamsEBool(uint256 requestID) internal view returns (ebool[] memory) {\\n        return paramsEBool[requestID];\\n    }\\n\\n    function getParamsEUint4(uint256 requestID) internal view returns (euint4[] memory) {\\n        return paramsEUint4[requestID];\\n    }\\n\\n    function getParamsEUint8(uint256 requestID) internal view returns (euint8[] memory) {\\n        return paramsEUint8[requestID];\\n    }\\n\\n    function getParamsEUint16(uint256 requestID) internal view returns (euint16[] memory) {\\n        return paramsEUint16[requestID];\\n    }\\n\\n    function getParamsEUint32(uint256 requestID) internal view returns (euint32[] memory) {\\n        return paramsEUint32[requestID];\\n    }\\n\\n    function getParamsEUint64(uint256 requestID) internal view returns (euint64[] memory) {\\n        return paramsEUint64[requestID];\\n    }\\n\\n    function getParamsEAddress(uint256 requestID) internal view returns (eaddress[] memory) {\\n        return paramsEAddress[requestID];\\n    }\\n\\n    function getParamsAddress(uint256 requestID) internal view returns (address[] memory) {\\n        return paramsAddress[requestID];\\n    }\\n\\n    function getParamsUint256(uint256 requestID) internal view returns (uint256[] memory) {\\n        return paramsUint256[requestID];\\n    }\\n}\\n\",\"keccak256\":\"0xd19fd7715f0c5b479bf0cd8e3108cc8da7deae2d4fc7fb5ab089ebf2d76a0652\",\"license\":\"BSD-3-Clause-Clear\"},\"fhevm/gateway/lib/Gateway.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause-Clear\\n\\npragma solidity ^0.8.24;\\n\\nimport \\\"../../lib/Impl.sol\\\";\\n\\ninterface IKMSVerifier {\\n    function verifyDecryptionEIP712KMSSignatures(\\n        address aclAddress,\\n        uint256[] memory handlesList,\\n        bytes memory decryptedResult,\\n        bytes[] memory signatures\\n    ) external returns (bool);\\n}\\n\\ninterface IGatewayContract {\\n    function requestDecryption(\\n        uint256[] calldata ctsHandles,\\n        bytes4 callbackSelector,\\n        uint256 msgValue,\\n        uint256 maxTimestamp,\\n        bool passSignaturesToCaller\\n    ) external returns (uint256);\\n}\\n\\nstruct GatewayConfigStruct {\\n    address GatewayContractAddress;\\n}\\n\\nlibrary Gateway {\\n    // keccak256(abi.encode(uint256(keccak256(\\\"fhevm.storage.GatewayConfig\\\")) - 1)) & ~bytes32(uint256(0xff))\\n    bytes32 private constant GatewayLocation = 0x93ab6e17f2c461cce6ea5d4ec117e51dda77a64affc2b2c05f8cd440def0e700;\\n\\n    function getGetwayConfig() internal pure returns (GatewayConfigStruct storage $) {\\n        assembly {\\n            $.slot := GatewayLocation\\n        }\\n    }\\n\\n    function setGateway(address gatewayAddress) internal {\\n        GatewayConfigStruct storage $ = getGetwayConfig();\\n        $.GatewayContractAddress = gatewayAddress;\\n    }\\n\\n    function gatewayContractAddress() internal view returns (address) {\\n        GatewayConfigStruct storage $ = getGetwayConfig();\\n        return $.GatewayContractAddress;\\n    }\\n\\n    function toUint256(ebool newCT) internal pure returns (uint256 ct) {\\n        ct = ebool.unwrap(newCT);\\n    }\\n\\n    function toUint256(euint4 newCT) internal pure returns (uint256 ct) {\\n        ct = euint4.unwrap(newCT);\\n    }\\n\\n    function toUint256(euint8 newCT) internal pure returns (uint256 ct) {\\n        ct = euint8.unwrap(newCT);\\n    }\\n\\n    function toUint256(euint16 newCT) internal pure returns (uint256 ct) {\\n        ct = euint16.unwrap(newCT);\\n    }\\n\\n    function toUint256(euint32 newCT) internal pure returns (uint256 ct) {\\n        ct = euint32.unwrap(newCT);\\n    }\\n\\n    function toUint256(euint64 newCT) internal pure returns (uint256 ct) {\\n        ct = euint64.unwrap(newCT);\\n    }\\n\\n    function toUint256(euint128 newCT) internal pure returns (uint256 ct) {\\n        ct = euint128.unwrap(newCT);\\n    }\\n\\n    function toUint256(eaddress newCT) internal pure returns (uint256 ct) {\\n        ct = eaddress.unwrap(newCT);\\n    }\\n\\n    function toUint256(euint256 newCT) internal pure returns (uint256 ct) {\\n        ct = euint256.unwrap(newCT);\\n    }\\n\\n    function toUint256(ebytes64 newCT) internal pure returns (uint256 ct) {\\n        ct = ebytes64.unwrap(newCT);\\n    }\\n\\n    function toUint256(ebytes128 newCT) internal pure returns (uint256 ct) {\\n        ct = ebytes128.unwrap(newCT);\\n    }\\n\\n    function toUint256(ebytes256 newCT) internal pure returns (uint256 ct) {\\n        ct = ebytes256.unwrap(newCT);\\n    }\\n\\n    function requestDecryption(\\n        uint256[] memory ctsHandles,\\n        bytes4 callbackSelector,\\n        uint256 msgValue,\\n        uint256 maxTimestamp,\\n        bool passSignaturesToCaller\\n    ) internal returns (uint256 requestID) {\\n        FHEVMConfigStruct storage $ = Impl.getFHEVMConfig();\\n        IACL($.ACLAddress).allowForDecryption(ctsHandles);\\n        GatewayConfigStruct storage $$ = getGetwayConfig();\\n        requestID = IGatewayContract($$.GatewayContractAddress).requestDecryption(\\n            ctsHandles,\\n            callbackSelector,\\n            msgValue,\\n            maxTimestamp,\\n            passSignaturesToCaller\\n        );\\n    }\\n\\n    /// @dev this function is supposed to be called inside the callback function if the dev wants the dApp contract to verify the signatures\\n    /// @dev this is useful to give dev the choice not to rely on trusting the GatewayContract.\\n    /// @notice this could be used only when signatures are made available to the callback, i.e when `passSignaturesToCaller` is set to true during request\\n    function verifySignatures(uint256[] memory handlesList, bytes[] memory signatures) internal returns (bool) {\\n        uint256 start = 4 + 32; // start position after skipping the selector (4 bytes) and the first argument (index, 32 bytes)\\n        uint256 length = getSignedDataLength(handlesList);\\n        bytes memory decryptedResult = new bytes(length);\\n        assembly {\\n            calldatacopy(add(decryptedResult, 0x20), start, length) // Copy the relevant part of calldata to decryptedResult memory\\n        }\\n        decryptedResult = shiftOffsets(decryptedResult, handlesList);\\n        FHEVMConfigStruct storage $ = Impl.getFHEVMConfig();\\n        return\\n            IKMSVerifier($.KMSVerifierAddress).verifyDecryptionEIP712KMSSignatures(\\n                $.ACLAddress,\\n                handlesList,\\n                decryptedResult,\\n                signatures\\n            );\\n    }\\n\\n    function getSignedDataLength(uint256[] memory handlesList) private pure returns (uint256) {\\n        uint256 handlesListlen = handlesList.length;\\n        uint256 signedDataLength;\\n        for (uint256 i = 0; i < handlesListlen; i++) {\\n            uint8 typeCt = uint8(handlesList[i] >> 8);\\n            if (typeCt < 9) {\\n                signedDataLength += 32;\\n            } else if (typeCt == 9) {\\n                //ebytes64\\n                signedDataLength += 128;\\n            } else if (typeCt == 10) {\\n                //ebytes128\\n                signedDataLength += 192;\\n            } else if (typeCt == 11) {\\n                //ebytes256\\n                signedDataLength += 320;\\n            } else {\\n                revert(\\\"Unsupported handle type\\\");\\n            }\\n        }\\n        signedDataLength += 32; // add offset of signatures\\n        return signedDataLength;\\n    }\\n\\n    function shiftOffsets(bytes memory input, uint256[] memory handlesList) private pure returns (bytes memory) {\\n        uint256 numArgs = handlesList.length;\\n        for (uint256 i = 0; i < numArgs; i++) {\\n            uint8 typeCt = uint8(handlesList[i] >> 8);\\n            if (typeCt >= 9) {\\n                input = subToBytes32Slice(input, 32 * i); // because we append the signatures, all bytes offsets are shifted by 0x20\\n            }\\n        }\\n        input = remove32Slice(input, 32 * numArgs);\\n        return input;\\n    }\\n\\n    function subToBytes32Slice(bytes memory data, uint256 offset) private pure returns (bytes memory) {\\n        // @note: data is assumed to be more than 32+offset bytes long\\n        assembly {\\n            let ptr := add(add(data, 0x20), offset)\\n            let val := mload(ptr)\\n            val := sub(val, 0x20)\\n            mstore(ptr, val)\\n        }\\n        return data;\\n    }\\n\\n    function remove32Slice(bytes memory input, uint256 start) private pure returns (bytes memory) {\\n        // @note we assume start+32 is less than input.length\\n        bytes memory result = new bytes(input.length - 32);\\n\\n        for (uint256 i = 0; i < start; i++) {\\n            result[i] = input[i];\\n        }\\n\\n        for (uint256 i = start + 32; i < input.length; i++) {\\n            result[i - 32] = input[i];\\n        }\\n\\n        return result;\\n    }\\n}\\n\",\"keccak256\":\"0x9585a649e3001a4b8768ab6e2597b416f680bcc537309cd50b60e023e9791318\",\"license\":\"BSD-3-Clause-Clear\"},\"fhevm/lib/Impl.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause-Clear\\npragma solidity ^0.8.24;\\n\\nimport \\\"./TFHE.sol\\\";\\n\\n/**\\n * @title   FHEVMConfigStruct\\n * @notice  This struct contains all addresses of core contrats which are needed in a typical dApp.\\n */\\nstruct FHEVMConfigStruct {\\n    address ACLAddress;\\n    address TFHEExecutorAddress;\\n    address FHEPaymentAddress;\\n    address KMSVerifierAddress;\\n}\\n\\n/**\\n * @title   ITFHEExecutor\\n * @notice  This interface contains all functions to conduct FHE operations.\\n */\\ninterface ITFHEExecutor {\\n    function fheAdd(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheSub(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheMul(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheDiv(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheRem(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheBitAnd(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheBitOr(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheBitXor(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheShl(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheShr(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheRotl(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheRotr(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheEq(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheNe(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheGe(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheGt(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheLe(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheLt(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheMin(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheMax(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheNeg(uint256 ct) external returns (uint256 result);\\n    function fheNot(uint256 ct) external returns (uint256 result);\\n    function verifyCiphertext(\\n        bytes32 inputHandle,\\n        address callerAddress,\\n        bytes memory inputProof,\\n        bytes1 inputType\\n    ) external returns (uint256 result);\\n    function cast(uint256 ct, bytes1 toType) external returns (uint256 result);\\n    function trivialEncrypt(uint256 ct, bytes1 toType) external returns (uint256 result);\\n    function trivialEncrypt(bytes memory ct, bytes1 toType) external returns (uint256 result);\\n    function fheEq(uint256 lhs, bytes memory rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheNe(uint256 lhs, bytes memory rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheIfThenElse(uint256 control, uint256 ifTrue, uint256 ifFalse) external returns (uint256 result);\\n    function fheRand(bytes1 randType) external returns (uint256 result);\\n    function fheRandBounded(uint256 upperBound, bytes1 randType) external returns (uint256 result);\\n}\\n\\n/**\\n * @title   IACL\\n * @notice  This interface contains all functions that are used to conduct operations\\n *          with the ACL contract.\\n */\\ninterface IACL {\\n    function allowTransient(uint256 ciphertext, address account) external;\\n    function allow(uint256 handle, address account) external;\\n    function cleanTransientStorage() external;\\n    function isAllowed(uint256 handle, address account) external view returns (bool);\\n    function allowForDecryption(uint256[] memory handlesList) external;\\n}\\n\\n/**\\n * @title   Impl\\n * @notice  This library is the core implementation for computing FHE operations (e.g. add, sub, xor).\\n */\\nlibrary Impl {\\n    /// @dev keccak256(abi.encode(uint256(keccak256(\\\"fhevm.storage.FHEVMConfig\\\")) - 1)) & ~bytes32(uint256(0xff))\\n    bytes32 private constant FHEVMConfigLocation = 0xed8d60e34876f751cc8b014c560745351147d9de11b9347c854e881b128ea600;\\n\\n    function getFHEVMConfig() internal pure returns (FHEVMConfigStruct storage $) {\\n        assembly {\\n            $.slot := FHEVMConfigLocation\\n        }\\n    }\\n\\n    function setFHEVM(FHEVMConfigStruct memory fhevmConfig) internal {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        $.ACLAddress = fhevmConfig.ACLAddress;\\n        $.TFHEExecutorAddress = fhevmConfig.TFHEExecutorAddress;\\n        $.FHEPaymentAddress = fhevmConfig.FHEPaymentAddress;\\n        $.KMSVerifierAddress = fhevmConfig.KMSVerifierAddress;\\n    }\\n\\n    function add(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheAdd(lhs, rhs, scalarByte);\\n    }\\n\\n    function sub(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheSub(lhs, rhs, scalarByte);\\n    }\\n\\n    function mul(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheMul(lhs, rhs, scalarByte);\\n    }\\n\\n    function div(uint256 lhs, uint256 rhs) internal returns (uint256 result) {\\n        bytes1 scalarByte = 0x01;\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheDiv(lhs, rhs, scalarByte);\\n    }\\n\\n    function rem(uint256 lhs, uint256 rhs) internal returns (uint256 result) {\\n        bytes1 scalarByte = 0x01;\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheRem(lhs, rhs, scalarByte);\\n    }\\n\\n    function and(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheBitAnd(lhs, rhs, scalarByte);\\n    }\\n\\n    function or(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheBitOr(lhs, rhs, scalarByte);\\n    }\\n\\n    function xor(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheBitXor(lhs, rhs, scalarByte);\\n    }\\n\\n    function shl(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheShl(lhs, rhs, scalarByte);\\n    }\\n\\n    function shr(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheShr(lhs, rhs, scalarByte);\\n    }\\n\\n    function rotl(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheRotl(lhs, rhs, scalarByte);\\n    }\\n\\n    function rotr(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheRotr(lhs, rhs, scalarByte);\\n    }\\n\\n    function eq(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheEq(lhs, rhs, scalarByte);\\n    }\\n\\n    function ne(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheNe(lhs, rhs, scalarByte);\\n    }\\n\\n    function ge(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheGe(lhs, rhs, scalarByte);\\n    }\\n\\n    function gt(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheGt(lhs, rhs, scalarByte);\\n    }\\n\\n    function le(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheLe(lhs, rhs, scalarByte);\\n    }\\n\\n    function lt(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheLt(lhs, rhs, scalarByte);\\n    }\\n\\n    function min(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheMin(lhs, rhs, scalarByte);\\n    }\\n\\n    function max(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheMax(lhs, rhs, scalarByte);\\n    }\\n\\n    function neg(uint256 ct) internal returns (uint256 result) {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheNeg(ct);\\n    }\\n\\n    function not(uint256 ct) internal returns (uint256 result) {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheNot(ct);\\n    }\\n\\n    // If 'control's value is 'true', the result has the same value as 'ifTrue'.\\n    // If 'control's value is 'false', the result has the same value as 'ifFalse'.\\n    function select(uint256 control, uint256 ifTrue, uint256 ifFalse) internal returns (uint256 result) {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheIfThenElse(control, ifTrue, ifFalse);\\n    }\\n\\n    function verify(bytes32 inputHandle, bytes memory inputProof, uint8 toType) internal returns (uint256 result) {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).verifyCiphertext(\\n            inputHandle,\\n            msg.sender,\\n            inputProof,\\n            bytes1(toType)\\n        );\\n        IACL($.ACLAddress).allowTransient(result, msg.sender);\\n    }\\n\\n    function cast(uint256 ciphertext, uint8 toType) internal returns (uint256 result) {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).cast(ciphertext, bytes1(toType));\\n    }\\n\\n    function trivialEncrypt(uint256 value, uint8 toType) internal returns (uint256 result) {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).trivialEncrypt(value, bytes1(toType));\\n    }\\n\\n    function trivialEncrypt(bytes memory value, uint8 toType) internal returns (uint256 result) {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).trivialEncrypt(value, bytes1(toType));\\n    }\\n\\n    function eq(uint256 lhs, bytes memory rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheEq(lhs, rhs, scalarByte);\\n    }\\n\\n    function ne(uint256 lhs, bytes memory rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheNe(lhs, rhs, scalarByte);\\n    }\\n\\n    function rand(uint8 randType) internal returns (uint256 result) {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheRand(bytes1(randType));\\n    }\\n\\n    function randBounded(uint256 upperBound, uint8 randType) internal returns (uint256 result) {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheRandBounded(upperBound, bytes1(randType));\\n    }\\n\\n    function allowTransient(uint256 handle, address account) internal {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        IACL($.ACLAddress).allowTransient(handle, account);\\n    }\\n\\n    function allow(uint256 handle, address account) internal {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        IACL($.ACLAddress).allow(handle, account);\\n    }\\n\\n    function cleanTransientStorage() internal {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        IACL($.ACLAddress).cleanTransientStorage();\\n    }\\n\\n    function isAllowed(uint256 handle, address account) internal view returns (bool) {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        return IACL($.ACLAddress).isAllowed(handle, account);\\n    }\\n}\\n\",\"keccak256\":\"0x89d4968cd956a8931f1a8a177b3bef1c6cf88a03665083db74430add50b88f21\",\"license\":\"BSD-3-Clause-Clear\"},\"fhevm/lib/TFHE.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause-Clear\\npragma solidity ^0.8.24;\\n\\nimport \\\"./Impl.sol\\\";\\n\\ntype ebool is uint256;\\ntype euint4 is uint256;\\ntype euint8 is uint256;\\ntype euint16 is uint256;\\ntype euint32 is uint256;\\ntype euint64 is uint256;\\ntype euint128 is uint256;\\ntype euint256 is uint256;\\ntype eaddress is uint256;\\ntype ebytes64 is uint256;\\ntype ebytes128 is uint256;\\ntype ebytes256 is uint256;\\ntype einput is bytes32;\\n\\n/**\\n * @title   Common\\n * @notice  This library contains all the values used to communicate types to the run time.\\n */\\nlibrary Common {\\n    uint8 internal constant ebool_t = 0;\\n    uint8 internal constant euint4_t = 1;\\n    uint8 internal constant euint8_t = 2;\\n    uint8 internal constant euint16_t = 3;\\n    uint8 internal constant euint32_t = 4;\\n    uint8 internal constant euint64_t = 5;\\n    uint8 internal constant euint128_t = 6;\\n    uint8 internal constant euint160_t = 7;\\n    uint8 internal constant euint256_t = 8;\\n    uint8 internal constant ebytes64_t = 9;\\n    uint8 internal constant ebytes128_t = 10;\\n    uint8 internal constant ebytes256_t = 11;\\n}\\n\\n/**\\n * @title   TFHE\\n * @notice  This library is the interaction point for all smart contract developers\\n *          that interact with TFHE.\\n */\\nlibrary TFHE {\\n    function setFHEVM(FHEVMConfigStruct memory fhevmConfig) internal {\\n        Impl.setFHEVM(fhevmConfig);\\n    }\\n\\n    // Return true if the enrypted bool is initialized and false otherwise.\\n    function isInitialized(ebool v) internal pure returns (bool) {\\n        return ebool.unwrap(v) != 0;\\n    }\\n\\n    // Return true if the enrypted integer is initialized and false otherwise.\\n    function isInitialized(euint4 v) internal pure returns (bool) {\\n        return euint4.unwrap(v) != 0;\\n    }\\n\\n    // Return true if the enrypted integer is initialized and false otherwise.\\n    function isInitialized(euint8 v) internal pure returns (bool) {\\n        return euint8.unwrap(v) != 0;\\n    }\\n\\n    // Return true if the enrypted integer is initialized and false otherwise.\\n    function isInitialized(euint16 v) internal pure returns (bool) {\\n        return euint16.unwrap(v) != 0;\\n    }\\n\\n    // Return true if the enrypted integer is initialized and false otherwise.\\n    function isInitialized(euint32 v) internal pure returns (bool) {\\n        return euint32.unwrap(v) != 0;\\n    }\\n\\n    // Return true if the enrypted integer is initialized and false otherwise.\\n    function isInitialized(euint64 v) internal pure returns (bool) {\\n        return euint64.unwrap(v) != 0;\\n    }\\n\\n    // Return true if the enrypted integer is initialized and false otherwise.\\n    function isInitialized(euint128 v) internal pure returns (bool) {\\n        return euint128.unwrap(v) != 0;\\n    }\\n\\n    // Return true if the enrypted integer is initialized and false otherwise.\\n    function isInitialized(euint256 v) internal pure returns (bool) {\\n        return euint256.unwrap(v) != 0;\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint4 a, euint4 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.add(euint4.unwrap(a), euint4.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint4 a, euint4 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.sub(euint4.unwrap(a), euint4.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint4 a, euint4 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.mul(euint4.unwrap(a), euint4.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint4 a, euint4 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.and(euint4.unwrap(a), euint4.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint4 a, euint4 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.or(euint4.unwrap(a), euint4.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint4 a, euint4 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.xor(euint4.unwrap(a), euint4.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint4 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint4.unwrap(a), euint4.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint4 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint4.unwrap(a), euint4.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint4 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint4.unwrap(a), euint4.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint4 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint4.unwrap(a), euint4.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint4 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.le(euint4.unwrap(a), euint4.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint4 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint4.unwrap(a), euint4.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint4 a, euint4 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.min(euint4.unwrap(a), euint4.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint4 a, euint4 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.max(euint4.unwrap(a), euint4.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint4 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.add(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint4 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.sub(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint4 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.mul(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint4 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.and(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint4 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.or(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint4 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.xor(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint4 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint4 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint4 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint4 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint4 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.le(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint4 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint4 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.min(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint4 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.max(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint4 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.add(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint4 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.sub(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint4 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.mul(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint4 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.and(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint4 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.or(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint4 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.xor(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint4 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint4 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint4 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint4 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint4 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.le(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint4 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint4 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.min(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint4 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.max(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint4 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.add(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint4 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.sub(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint4 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.mul(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint4 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.and(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint4 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.or(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint4 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.xor(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint4 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint4 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint4 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint4 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint4 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.le(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint4 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint4 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.min(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint4 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.max(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint4 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.add(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint4 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.sub(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint4 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.mul(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint4 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.and(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint4 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.or(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint4 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.xor(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint4 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint4 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint4 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint4 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint4 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.le(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint4 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint4 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.min(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint4 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.max(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint4 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint4 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint4 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint4 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint4 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint4 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint4 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint4 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint4 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint4 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint4 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint4 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint4 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint4 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint4 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.add(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint4 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.sub(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint4 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.mul(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint4 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint4 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint4 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint4 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint4 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint4 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint4 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint4 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.le(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint4 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint4 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.min(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint4 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.max(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint4 a, uint8 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.add(euint4.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(uint8 a, euint4 b) internal returns (euint4) {\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.add(euint4.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint4 a, uint8 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.sub(euint4.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(uint8 a, euint4 b) internal returns (euint4) {\\n        euint4 aEnc = asEuint4(a);\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.sub(euint4.unwrap(aEnc), euint4.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint4 a, uint8 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.mul(euint4.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(uint8 a, euint4 b) internal returns (euint4) {\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.mul(euint4.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate div(a, b) and return the result.\\n    function div(euint4 a, uint8 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.div(euint4.unwrap(a), uint256(b)));\\n    }\\n\\n    // Evaluate rem(a, b) and return the result.\\n    function rem(euint4 a, uint8 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.rem(euint4.unwrap(a), uint256(b)));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint4 a, uint8 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.and(euint4.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(uint8 a, euint4 b) internal returns (euint4) {\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.and(euint4.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint4 a, uint8 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.or(euint4.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(uint8 a, euint4 b) internal returns (euint4) {\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.or(euint4.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint4 a, uint8 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.xor(euint4.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(uint8 a, euint4 b) internal returns (euint4) {\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.xor(euint4.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint4 a, uint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint4.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(uint8 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint4.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint4 a, uint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint4.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(uint8 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint4.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint4 a, uint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint4.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(uint8 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.le(euint4.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint4 a, uint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint4.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(uint8 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint4.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint4 a, uint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.le(euint4.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(uint8 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint4.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint4 a, uint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint4.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(uint8 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint4.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint4 a, uint8 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.min(euint4.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(uint8 a, euint4 b) internal returns (euint4) {\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.min(euint4.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint4 a, uint8 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.max(euint4.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(uint8 a, euint4 b) internal returns (euint4) {\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.max(euint4.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint8 a, euint4 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint8.wrap(Impl.add(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint8 a, euint4 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint8.wrap(Impl.sub(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint8 a, euint4 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint8.wrap(Impl.mul(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint8 a, euint4 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint8.wrap(Impl.and(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint8 a, euint4 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint8.wrap(Impl.or(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint8 a, euint4 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint8.wrap(Impl.xor(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint8 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint8 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint8 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint8 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint8 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.le(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint8 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint8 a, euint4 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint8.wrap(Impl.min(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint8 a, euint4 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint8.wrap(Impl.max(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.add(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.sub(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.mul(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.and(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.or(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.xor(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.le(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.min(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.max(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint8 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.add(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint8 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.sub(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint8 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.mul(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint8 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.and(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint8 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.or(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint8 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.xor(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint8 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint8 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint8 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint8 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint8 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.le(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint8 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint8 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.min(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint8 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.max(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint8 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.add(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint8 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.sub(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint8 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.mul(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint8 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.and(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint8 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.or(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint8 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.xor(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint8 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint8 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint8 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint8 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint8 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.le(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint8 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint8 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.min(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint8 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.max(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint8 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.add(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint8 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.sub(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint8 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.mul(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint8 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.and(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint8 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.or(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint8 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.xor(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint8 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint8 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint8 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint8 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint8 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.le(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint8 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint8 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.min(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint8 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.max(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint8 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint8 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint8 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint8 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint8 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint8 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint8 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint8 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint8 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint8 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint8 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint8 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint8 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint8 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint8 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.add(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint8 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.sub(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint8 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.mul(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint8 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint8 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint8 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint8 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint8 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint8 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint8 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint8 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.le(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint8 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint8 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.min(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint8 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.max(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.add(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(uint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.add(euint8.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.sub(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(uint8 a, euint8 b) internal returns (euint8) {\\n        euint8 aEnc = asEuint8(a);\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.sub(euint8.unwrap(aEnc), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.mul(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(uint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.mul(euint8.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate div(a, b) and return the result.\\n    function div(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.div(euint8.unwrap(a), uint256(b)));\\n    }\\n\\n    // Evaluate rem(a, b) and return the result.\\n    function rem(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.rem(euint8.unwrap(a), uint256(b)));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.and(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(uint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.and(euint8.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.or(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(uint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.or(euint8.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.xor(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(uint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.xor(euint8.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint8 a, uint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(uint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint8.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint8 a, uint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(uint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint8.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint8 a, uint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(uint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.le(euint8.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint8 a, uint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(uint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint8.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint8 a, uint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.le(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(uint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint8.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint8 a, uint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(uint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint8.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.min(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(uint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.min(euint8.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.max(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(uint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.max(euint8.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint16 a, euint4 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint16.wrap(Impl.add(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint16 a, euint4 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint16.wrap(Impl.sub(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint16 a, euint4 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint16.wrap(Impl.mul(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint16 a, euint4 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint16.wrap(Impl.and(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint16 a, euint4 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint16.wrap(Impl.or(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint16 a, euint4 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint16.wrap(Impl.xor(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint16 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint16 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint16 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint16 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint16 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.le(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint16 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint16 a, euint4 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint16.wrap(Impl.min(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint16 a, euint4 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint16.wrap(Impl.max(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.add(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.sub(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.mul(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.and(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.or(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.xor(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint16 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint16 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint16 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint16 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint16 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.le(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint16 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.min(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.max(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.add(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.sub(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.mul(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.and(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.or(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.xor(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.le(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.min(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.max(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint16 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.add(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint16 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.sub(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint16 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.mul(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint16 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.and(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint16 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.or(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint16 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.xor(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint16 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint16 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint16 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint16 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint16 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.le(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint16 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint16 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.min(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint16 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.max(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint16 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.add(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint16 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.sub(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint16 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.mul(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint16 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.and(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint16 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.or(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint16 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.xor(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint16 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint16 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint16 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint16 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint16 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.le(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint16 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint16 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.min(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint16 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.max(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint16 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint16 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint16 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint16 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint16 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint16 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint16 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint16 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint16 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint16 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint16 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint16 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint16 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint16 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint16 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.add(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint16 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.sub(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint16 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.mul(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint16 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint16 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint16 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint16 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint16 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint16 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint16 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint16 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.le(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint16 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint16 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.min(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint16 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.max(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint16 a, uint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.add(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(uint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.add(euint16.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint16 a, uint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.sub(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(uint16 a, euint16 b) internal returns (euint16) {\\n        euint16 aEnc = asEuint16(a);\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.sub(euint16.unwrap(aEnc), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint16 a, uint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.mul(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(uint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.mul(euint16.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate div(a, b) and return the result.\\n    function div(euint16 a, uint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.div(euint16.unwrap(a), uint256(b)));\\n    }\\n\\n    // Evaluate rem(a, b) and return the result.\\n    function rem(euint16 a, uint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.rem(euint16.unwrap(a), uint256(b)));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint16 a, uint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.and(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(uint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.and(euint16.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint16 a, uint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.or(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(uint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.or(euint16.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint16 a, uint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.xor(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(uint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.xor(euint16.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint16 a, uint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(uint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint16.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint16 a, uint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(uint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint16.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint16 a, uint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(uint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.le(euint16.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint16 a, uint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(uint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint16.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint16 a, uint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.le(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(uint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint16.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint16 a, uint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(uint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint16.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint16 a, uint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.min(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(uint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.min(euint16.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint16 a, uint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.max(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(uint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.max(euint16.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint32 a, euint4 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint32.wrap(Impl.add(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint32 a, euint4 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint32.wrap(Impl.sub(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint32 a, euint4 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint32.wrap(Impl.mul(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint32 a, euint4 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint32.wrap(Impl.and(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint32 a, euint4 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint32.wrap(Impl.or(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint32 a, euint4 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint32.wrap(Impl.xor(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint32 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint32 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint32 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint32 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint32 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.le(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint32 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint32 a, euint4 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint32.wrap(Impl.min(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint32 a, euint4 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint32.wrap(Impl.max(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.add(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.sub(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.mul(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.and(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.or(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.xor(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint32 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint32 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint32 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint32 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint32 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.le(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint32 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.min(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.max(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint32 a, euint16 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint32.wrap(Impl.add(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint32 a, euint16 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint32.wrap(Impl.sub(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint32 a, euint16 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint32.wrap(Impl.mul(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint32 a, euint16 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint32.wrap(Impl.and(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint32 a, euint16 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint32.wrap(Impl.or(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint32 a, euint16 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint32.wrap(Impl.xor(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint32 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint32 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint32 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint32 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint32 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.le(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint32 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint32 a, euint16 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint32.wrap(Impl.min(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint32 a, euint16 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint32.wrap(Impl.max(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.add(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.sub(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.mul(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.and(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.or(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.xor(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.le(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.min(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.max(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint32 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.add(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint32 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.sub(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint32 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.mul(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint32 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.and(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint32 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.or(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint32 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.xor(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint32 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint32 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint32 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint32 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint32 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.le(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint32 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint32 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.min(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint32 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.max(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint32 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint32 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint32 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint32 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint32 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint32 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint32 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint32 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint32 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint32 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint32 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint32 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint32 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint32 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint32 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.add(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint32 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.sub(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint32 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.mul(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint32 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint32 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint32 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint32 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint32 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint32 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint32 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint32 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.le(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint32 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint32 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.min(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint32 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.max(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint32 a, uint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.add(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(uint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.add(euint32.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint32 a, uint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.sub(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(uint32 a, euint32 b) internal returns (euint32) {\\n        euint32 aEnc = asEuint32(a);\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.sub(euint32.unwrap(aEnc), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint32 a, uint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.mul(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(uint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.mul(euint32.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate div(a, b) and return the result.\\n    function div(euint32 a, uint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.div(euint32.unwrap(a), uint256(b)));\\n    }\\n\\n    // Evaluate rem(a, b) and return the result.\\n    function rem(euint32 a, uint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.rem(euint32.unwrap(a), uint256(b)));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint32 a, uint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.and(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(uint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.and(euint32.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint32 a, uint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.or(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(uint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.or(euint32.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint32 a, uint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.xor(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(uint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.xor(euint32.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint32 a, uint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(uint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint32.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint32 a, uint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(uint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint32.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint32 a, uint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(uint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.le(euint32.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint32 a, uint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(uint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint32.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint32 a, uint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.le(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(uint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint32.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint32 a, uint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(uint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint32.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint32 a, uint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.min(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(uint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.min(euint32.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint32 a, uint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.max(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(uint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.max(euint32.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint64 a, euint4 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint64.wrap(Impl.add(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint64 a, euint4 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint64.wrap(Impl.sub(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint64 a, euint4 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint64.wrap(Impl.mul(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint64 a, euint4 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint64.wrap(Impl.and(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint64 a, euint4 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint64.wrap(Impl.or(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint64 a, euint4 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint64.wrap(Impl.xor(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint64 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint64 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint64 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint64 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint64 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.le(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint64 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint64 a, euint4 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint64.wrap(Impl.min(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint64 a, euint4 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint64.wrap(Impl.max(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.add(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.sub(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.mul(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.and(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.or(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.xor(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint64 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint64 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint64 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint64 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint64 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.le(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint64 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.min(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.max(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint64 a, euint16 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint64.wrap(Impl.add(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint64 a, euint16 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint64.wrap(Impl.sub(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint64 a, euint16 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint64.wrap(Impl.mul(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint64 a, euint16 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint64.wrap(Impl.and(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint64 a, euint16 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint64.wrap(Impl.or(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint64 a, euint16 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint64.wrap(Impl.xor(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint64 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint64 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint64 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint64 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint64 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.le(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint64 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint64 a, euint16 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint64.wrap(Impl.min(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint64 a, euint16 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint64.wrap(Impl.max(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint64 a, euint32 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint64.wrap(Impl.add(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint64 a, euint32 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint64.wrap(Impl.sub(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint64 a, euint32 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint64.wrap(Impl.mul(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint64 a, euint32 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint64.wrap(Impl.and(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint64 a, euint32 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint64.wrap(Impl.or(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint64 a, euint32 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint64.wrap(Impl.xor(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint64 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint64 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint64 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint64 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint64 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.le(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint64 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint64 a, euint32 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint64.wrap(Impl.min(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint64 a, euint32 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint64.wrap(Impl.max(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.add(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.sub(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.mul(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.and(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.or(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.xor(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.le(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.min(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.max(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint64 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint64 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint64 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint64 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint64 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint64 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint64 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint64 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint64 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint64 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint64 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint64 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint64 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint64 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint64 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.add(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint64 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.sub(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint64 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.mul(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint64 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint64 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint64 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint64 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint64 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint64 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint64 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint64 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.le(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint64 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint64 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.min(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint64 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.max(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint64 a, uint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.add(euint64.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(uint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.add(euint64.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint64 a, uint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.sub(euint64.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(uint64 a, euint64 b) internal returns (euint64) {\\n        euint64 aEnc = asEuint64(a);\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.sub(euint64.unwrap(aEnc), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint64 a, uint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.mul(euint64.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(uint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.mul(euint64.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate div(a, b) and return the result.\\n    function div(euint64 a, uint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.div(euint64.unwrap(a), uint256(b)));\\n    }\\n\\n    // Evaluate rem(a, b) and return the result.\\n    function rem(euint64 a, uint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.rem(euint64.unwrap(a), uint256(b)));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint64 a, uint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.and(euint64.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(uint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.and(euint64.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint64 a, uint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.or(euint64.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(uint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.or(euint64.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint64 a, uint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.xor(euint64.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(uint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.xor(euint64.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint64 a, uint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint64.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(uint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint64.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint64 a, uint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint64.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(uint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint64.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint64 a, uint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint64.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(uint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.le(euint64.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint64 a, uint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint64.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(uint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint64.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint64 a, uint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.le(euint64.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(uint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint64.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint64 a, uint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint64.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(uint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint64.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint64 a, uint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.min(euint64.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(uint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.min(euint64.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint64 a, uint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.max(euint64.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(uint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.max(euint64.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint128 a, euint4 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint128 a, euint4 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint128 a, euint4 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint128 a, euint4 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint128 a, euint4 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint128 a, euint4 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint128 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint128 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint128 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint128 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint128 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint128 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint128 a, euint4 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint128 a, euint4 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint128 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint128 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint128 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint128 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint128 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint128 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint128 a, euint16 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint128 a, euint16 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint128 a, euint16 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint128 a, euint16 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint128 a, euint16 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint128 a, euint16 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint128 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint128 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint128 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint128 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint128 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint128 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint128 a, euint16 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint128 a, euint16 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint128 a, euint32 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint128 a, euint32 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint128 a, euint32 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint128 a, euint32 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint128 a, euint32 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint128 a, euint32 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint128 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint128 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint128 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint128 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint128 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint128 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint128 a, euint32 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint128 a, euint32 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint128 a, euint64 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint128 a, euint64 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint128 a, euint64 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint128 a, euint64 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint128 a, euint64 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint128 a, euint64 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint128 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint128 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint128 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint128 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint128 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint128 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint128 a, euint64 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint128 a, euint64 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint128 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.add(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint128 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.sub(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint128 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.mul(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint128 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint128 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint128 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint128 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint128 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint128 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint128 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint128 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.le(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint128 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint128 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.min(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint128 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.max(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint128 a, uint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(uint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint128 a, uint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(uint128 a, euint128 b) internal returns (euint128) {\\n        euint128 aEnc = asEuint128(a);\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(aEnc), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint128 a, uint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(uint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate div(a, b) and return the result.\\n    function div(euint128 a, uint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.div(euint128.unwrap(a), uint256(b)));\\n    }\\n\\n    // Evaluate rem(a, b) and return the result.\\n    function rem(euint128 a, uint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.rem(euint128.unwrap(a), uint256(b)));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint128 a, uint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(uint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint128 a, uint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(uint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint128 a, uint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(uint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint128 a, uint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(uint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint128 a, uint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(uint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint128 a, uint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(uint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint128 a, uint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(uint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint128 a, uint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(uint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint128 a, uint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(uint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint128 a, uint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(uint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint128 a, uint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(uint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint256 a, euint4 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint256.wrap(Impl.add(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint256 a, euint4 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint256.wrap(Impl.sub(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint256 a, euint4 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint256.wrap(Impl.mul(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint256 a, euint4 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint256 a, euint4 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint256 a, euint4 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint256 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint256 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint256 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint256 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint256 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.le(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint256 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint256 a, euint4 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint256.wrap(Impl.min(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint256 a, euint4 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint256.wrap(Impl.max(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint256 a, euint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint256.wrap(Impl.add(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint256 a, euint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint256.wrap(Impl.sub(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint256 a, euint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint256.wrap(Impl.mul(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint256 a, euint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint256 a, euint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint256 a, euint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint256 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint256 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint256 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint256 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint256 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.le(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint256 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint256 a, euint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint256.wrap(Impl.min(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint256 a, euint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint256.wrap(Impl.max(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint256 a, euint16 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint256.wrap(Impl.add(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint256 a, euint16 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint256.wrap(Impl.sub(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint256 a, euint16 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint256.wrap(Impl.mul(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint256 a, euint16 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint256 a, euint16 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint256 a, euint16 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint256 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint256 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint256 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint256 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint256 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.le(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint256 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint256 a, euint16 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint256.wrap(Impl.min(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint256 a, euint16 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint256.wrap(Impl.max(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint256 a, euint32 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint256.wrap(Impl.add(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint256 a, euint32 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint256.wrap(Impl.sub(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint256 a, euint32 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint256.wrap(Impl.mul(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint256 a, euint32 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint256 a, euint32 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint256 a, euint32 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint256 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint256 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint256 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint256 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint256 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.le(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint256 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint256 a, euint32 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint256.wrap(Impl.min(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint256 a, euint32 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint256.wrap(Impl.max(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint256 a, euint64 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint256.wrap(Impl.add(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint256 a, euint64 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint256.wrap(Impl.sub(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint256 a, euint64 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint256.wrap(Impl.mul(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint256 a, euint64 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint256 a, euint64 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint256 a, euint64 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint256 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint256 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint256 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint256 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint256 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.le(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint256 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint256 a, euint64 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint256.wrap(Impl.min(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint256 a, euint64 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint256.wrap(Impl.max(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint256 a, euint128 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint256.wrap(Impl.add(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint256 a, euint128 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint256.wrap(Impl.sub(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint256 a, euint128 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint256.wrap(Impl.mul(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint256 a, euint128 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint256 a, euint128 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint256 a, euint128 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint256 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint256 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint256 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint256 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint256 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.le(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint256 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint256 a, euint128 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint256.wrap(Impl.min(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint256 a, euint128 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint256.wrap(Impl.max(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.add(euint256.unwrap(a), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.sub(euint256.unwrap(a), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.mul(euint256.unwrap(a), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(a), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(a), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint256 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint256 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint256 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint256.unwrap(a), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint256 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint256.unwrap(a), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint256 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.le(euint256.unwrap(a), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint256 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint256.unwrap(a), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.min(euint256.unwrap(a), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.max(euint256.unwrap(a), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint256 a, uint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.add(euint256.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(uint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.add(euint256.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint256 a, uint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.sub(euint256.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(uint256 a, euint256 b) internal returns (euint256) {\\n        euint256 aEnc = asEuint256(a);\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.sub(euint256.unwrap(aEnc), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint256 a, uint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.mul(euint256.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(uint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.mul(euint256.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate div(a, b) and return the result.\\n    function div(euint256 a, uint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.div(euint256.unwrap(a), uint256(b)));\\n    }\\n\\n    // Evaluate rem(a, b) and return the result.\\n    function rem(euint256 a, uint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.rem(euint256.unwrap(a), uint256(b)));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint256 a, uint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(uint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint256 a, uint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(uint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint256 a, uint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(uint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint256 a, uint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(uint256 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint256 a, uint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(uint256 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint256 a, uint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint256.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(uint256 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.le(euint256.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint256 a, uint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint256.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(uint256 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint256.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint256 a, uint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.le(euint256.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(uint256 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint256.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint256 a, uint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint256.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(uint256 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint256.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint256 a, uint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.min(euint256.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(uint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.min(euint256.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint256 a, uint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.max(euint256.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(uint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.max(euint256.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate shl(a, b) and return the result.\\n    function shl(euint4 a, uint8 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.shl(euint4.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate shr(a, b) and return the result.\\n    function shr(euint4 a, uint8 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.shr(euint4.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate rotl(a, b) and return the result.\\n    function rotl(euint4 a, uint8 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.rotl(euint4.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate rotr(a, b) and return the result.\\n    function rotr(euint4 a, uint8 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.rotr(euint4.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate shl(a, b) and return the result.\\n    function shl(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.shl(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate shl(a, b) and return the result.\\n    function shl(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.shl(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate shr(a, b) and return the result.\\n    function shr(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.shr(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate shr(a, b) and return the result.\\n    function shr(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.shr(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate rotl(a, b) and return the result.\\n    function rotl(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.rotl(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate rotl(a, b) and return the result.\\n    function rotl(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.rotl(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate rotr(a, b) and return the result.\\n    function rotr(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.rotr(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate rotr(a, b) and return the result.\\n    function rotr(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.rotr(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate shl(a, b) and return the result.\\n    function shl(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.shl(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate shl(a, b) and return the result.\\n    function shl(euint16 a, uint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.shl(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate shr(a, b) and return the result.\\n    function shr(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.shr(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate shr(a, b) and return the result.\\n    function shr(euint16 a, uint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.shr(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate rotl(a, b) and return the result.\\n    function rotl(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.rotl(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate rotl(a, b) and return the result.\\n    function rotl(euint16 a, uint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.rotl(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate rotr(a, b) and return the result.\\n    function rotr(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.rotr(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate rotr(a, b) and return the result.\\n    function rotr(euint16 a, uint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.rotr(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate shl(a, b) and return the result.\\n    function shl(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.shl(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate shl(a, b) and return the result.\\n    function shl(euint32 a, uint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.shl(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate shr(a, b) and return the result.\\n    function shr(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.shr(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate shr(a, b) and return the result.\\n    function shr(euint32 a, uint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.shr(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate rotl(a, b) and return the result.\\n    function rotl(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.rotl(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate rotl(a, b) and return the result.\\n    function rotl(euint32 a, uint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.rotl(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate rotr(a, b) and return the result.\\n    function rotr(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.rotr(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate rotr(a, b) and return the result.\\n    function rotr(euint32 a, uint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.rotr(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate shl(a, b) and return the result.\\n    function shl(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.shl(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate shl(a, b) and return the result.\\n    function shl(euint64 a, uint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.shl(euint64.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate shr(a, b) and return the result.\\n    function shr(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.shr(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate shr(a, b) and return the result.\\n    function shr(euint64 a, uint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.shr(euint64.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate rotl(a, b) and return the result.\\n    function rotl(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.rotl(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate rotl(a, b) and return the result.\\n    function rotl(euint64 a, uint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.rotl(euint64.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate rotr(a, b) and return the result.\\n    function rotr(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.rotr(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate rotr(a, b) and return the result.\\n    function rotr(euint64 a, uint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.rotr(euint64.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate shl(a, b) and return the result.\\n    function shl(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.shl(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate shl(a, b) and return the result.\\n    function shl(euint128 a, uint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.shl(euint128.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate shr(a, b) and return the result.\\n    function shr(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.shr(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate shr(a, b) and return the result.\\n    function shr(euint128 a, uint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.shr(euint128.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate rotl(a, b) and return the result.\\n    function rotl(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.rotl(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate rotl(a, b) and return the result.\\n    function rotl(euint128 a, uint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.rotl(euint128.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate rotr(a, b) and return the result.\\n    function rotr(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.rotr(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate rotr(a, b) and return the result.\\n    function rotr(euint128 a, uint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.rotr(euint128.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate shl(a, b) and return the result.\\n    function shl(euint256 a, euint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint256.wrap(Impl.shl(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate shl(a, b) and return the result.\\n    function shl(euint256 a, uint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.shl(euint256.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate shr(a, b) and return the result.\\n    function shr(euint256 a, euint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint256.wrap(Impl.shr(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate shr(a, b) and return the result.\\n    function shr(euint256 a, uint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.shr(euint256.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate rotl(a, b) and return the result.\\n    function rotl(euint256 a, euint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint256.wrap(Impl.rotl(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate rotl(a, b) and return the result.\\n    function rotl(euint256 a, uint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.rotl(euint256.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate rotr(a, b) and return the result.\\n    function rotr(euint256 a, euint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint256.wrap(Impl.rotr(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate rotr(a, b) and return the result.\\n    function rotr(euint256 a, uint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.rotr(euint256.unwrap(a), uint256(b), true));\\n    }\\n\\n    // If 'control''s value is 'true', the result has the same value as 'a'.\\n    // If 'control''s value is 'false', the result has the same value as 'b'.\\n    function select(ebool control, euint4 a, euint4 b) internal returns (euint4) {\\n        return euint4.wrap(Impl.select(ebool.unwrap(control), euint4.unwrap(a), euint4.unwrap(b)));\\n    }\\n    // If 'control''s value is 'true', the result has the same value as 'a'.\\n    // If 'control''s value is 'false', the result has the same value as 'b'.\\n    function select(ebool control, euint8 a, euint8 b) internal returns (euint8) {\\n        return euint8.wrap(Impl.select(ebool.unwrap(control), euint8.unwrap(a), euint8.unwrap(b)));\\n    }\\n    // If 'control''s value is 'true', the result has the same value as 'a'.\\n    // If 'control''s value is 'false', the result has the same value as 'b'.\\n    function select(ebool control, euint16 a, euint16 b) internal returns (euint16) {\\n        return euint16.wrap(Impl.select(ebool.unwrap(control), euint16.unwrap(a), euint16.unwrap(b)));\\n    }\\n    // If 'control''s value is 'true', the result has the same value as 'a'.\\n    // If 'control''s value is 'false', the result has the same value as 'b'.\\n    function select(ebool control, euint32 a, euint32 b) internal returns (euint32) {\\n        return euint32.wrap(Impl.select(ebool.unwrap(control), euint32.unwrap(a), euint32.unwrap(b)));\\n    }\\n    // If 'control''s value is 'true', the result has the same value as 'a'.\\n    // If 'control''s value is 'false', the result has the same value as 'b'.\\n    function select(ebool control, euint64 a, euint64 b) internal returns (euint64) {\\n        return euint64.wrap(Impl.select(ebool.unwrap(control), euint64.unwrap(a), euint64.unwrap(b)));\\n    }\\n    // If 'control''s value is 'true', the result has the same value as 'a'.\\n    // If 'control''s value is 'false', the result has the same value as 'b'.\\n    function select(ebool control, euint128 a, euint128 b) internal returns (euint128) {\\n        return euint128.wrap(Impl.select(ebool.unwrap(control), euint128.unwrap(a), euint128.unwrap(b)));\\n    }\\n    // If 'control''s value is 'true', the result has the same value as 'a'.\\n    // If 'control''s value is 'false', the result has the same value as 'b'.\\n    function select(ebool control, euint256 a, euint256 b) internal returns (euint256) {\\n        return euint256.wrap(Impl.select(ebool.unwrap(control), euint256.unwrap(a), euint256.unwrap(b)));\\n    }\\n    // Cast an encrypted integer from euint8 to euint4.\\n    function asEuint4(euint8 value) internal returns (euint4) {\\n        return euint4.wrap(Impl.cast(euint8.unwrap(value), Common.euint4_t));\\n    }\\n\\n    // Cast an encrypted integer from euint16 to euint4.\\n    function asEuint4(euint16 value) internal returns (euint4) {\\n        return euint4.wrap(Impl.cast(euint16.unwrap(value), Common.euint4_t));\\n    }\\n\\n    // Cast an encrypted integer from euint32 to euint4.\\n    function asEuint4(euint32 value) internal returns (euint4) {\\n        return euint4.wrap(Impl.cast(euint32.unwrap(value), Common.euint4_t));\\n    }\\n\\n    // Cast an encrypted integer from euint64 to euint4.\\n    function asEuint4(euint64 value) internal returns (euint4) {\\n        return euint4.wrap(Impl.cast(euint64.unwrap(value), Common.euint4_t));\\n    }\\n\\n    // Cast an encrypted integer from euint128 to euint4.\\n    function asEuint4(euint128 value) internal returns (euint4) {\\n        return euint4.wrap(Impl.cast(euint128.unwrap(value), Common.euint4_t));\\n    }\\n\\n    // Cast an encrypted integer from euint256 to euint4.\\n    function asEuint4(euint256 value) internal returns (euint4) {\\n        return euint4.wrap(Impl.cast(euint256.unwrap(value), Common.euint4_t));\\n    }\\n\\n    // Cast an encrypted integer from euint4 to ebool.\\n    function asEbool(euint4 value) internal returns (ebool) {\\n        return ne(value, 0);\\n    }\\n\\n    // Converts an 'ebool' to an 'euint4'.\\n    function asEuint4(ebool b) internal returns (euint4) {\\n        return euint4.wrap(Impl.cast(ebool.unwrap(b), Common.euint4_t));\\n    }\\n\\n    // Cast an encrypted integer from euint4 to euint8.\\n    function asEuint8(euint4 value) internal returns (euint8) {\\n        return euint8.wrap(Impl.cast(euint4.unwrap(value), Common.euint8_t));\\n    }\\n\\n    // Cast an encrypted integer from euint16 to euint8.\\n    function asEuint8(euint16 value) internal returns (euint8) {\\n        return euint8.wrap(Impl.cast(euint16.unwrap(value), Common.euint8_t));\\n    }\\n\\n    // Cast an encrypted integer from euint32 to euint8.\\n    function asEuint8(euint32 value) internal returns (euint8) {\\n        return euint8.wrap(Impl.cast(euint32.unwrap(value), Common.euint8_t));\\n    }\\n\\n    // Cast an encrypted integer from euint64 to euint8.\\n    function asEuint8(euint64 value) internal returns (euint8) {\\n        return euint8.wrap(Impl.cast(euint64.unwrap(value), Common.euint8_t));\\n    }\\n\\n    // Cast an encrypted integer from euint128 to euint8.\\n    function asEuint8(euint128 value) internal returns (euint8) {\\n        return euint8.wrap(Impl.cast(euint128.unwrap(value), Common.euint8_t));\\n    }\\n\\n    // Cast an encrypted integer from euint256 to euint8.\\n    function asEuint8(euint256 value) internal returns (euint8) {\\n        return euint8.wrap(Impl.cast(euint256.unwrap(value), Common.euint8_t));\\n    }\\n\\n    // Cast an encrypted integer from euint8 to ebool.\\n    function asEbool(euint8 value) internal returns (ebool) {\\n        return ne(value, 0);\\n    }\\n\\n    // Convert an inputHandle with corresponding inputProof to an encrypted boolean.\\n    function asEbool(einput inputHandle, bytes memory inputProof) internal returns (ebool) {\\n        return ebool.wrap(Impl.verify(einput.unwrap(inputHandle), inputProof, Common.ebool_t));\\n    }\\n\\n    // Convert a plaintext value to an encrypted boolean.\\n    function asEbool(uint256 value) internal returns (ebool) {\\n        return ebool.wrap(Impl.trivialEncrypt(value, Common.ebool_t));\\n    }\\n\\n    // Convert a plaintext boolean to an encrypted boolean.\\n    function asEbool(bool value) internal returns (ebool) {\\n        if (value) {\\n            return asEbool(1);\\n        } else {\\n            return asEbool(0);\\n        }\\n    }\\n\\n    // Converts an 'ebool' to an 'euint8'.\\n    function asEuint8(ebool value) internal returns (euint8) {\\n        return euint8.wrap(Impl.cast(ebool.unwrap(value), Common.euint8_t));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(ebool a, ebool b) internal returns (ebool) {\\n        return ebool.wrap(Impl.and(ebool.unwrap(a), ebool.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(ebool a, bool b) internal returns (ebool) {\\n        return ebool.wrap(Impl.and(ebool.unwrap(a), b ? 1 : 0, true));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(bool a, ebool b) internal returns (ebool) {\\n        return ebool.wrap(Impl.and(ebool.unwrap(b), a ? 1 : 0, true));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(ebool a, ebool b) internal returns (ebool) {\\n        return ebool.wrap(Impl.or(ebool.unwrap(a), ebool.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(ebool a, bool b) internal returns (ebool) {\\n        return ebool.wrap(Impl.or(ebool.unwrap(a), b ? 1 : 0, true));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(bool a, ebool b) internal returns (ebool) {\\n        return ebool.wrap(Impl.or(ebool.unwrap(b), a ? 1 : 0, true));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(ebool a, ebool b) internal returns (ebool) {\\n        return ebool.wrap(Impl.xor(ebool.unwrap(a), ebool.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(ebool a, bool b) internal returns (ebool) {\\n        return ebool.wrap(Impl.xor(ebool.unwrap(a), b ? 1 : 0, true));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(bool a, ebool b) internal returns (ebool) {\\n        return ebool.wrap(Impl.xor(ebool.unwrap(b), a ? 1 : 0, true));\\n    }\\n\\n    function not(ebool a) internal returns (ebool) {\\n        return ebool.wrap(Impl.not(ebool.unwrap(a)));\\n    }\\n\\n    // Cast an encrypted integer from euint4 to euint16.\\n    function asEuint16(euint4 value) internal returns (euint16) {\\n        return euint16.wrap(Impl.cast(euint4.unwrap(value), Common.euint16_t));\\n    }\\n\\n    // Cast an encrypted integer from euint8 to euint16.\\n    function asEuint16(euint8 value) internal returns (euint16) {\\n        return euint16.wrap(Impl.cast(euint8.unwrap(value), Common.euint16_t));\\n    }\\n\\n    // Cast an encrypted integer from euint32 to euint16.\\n    function asEuint16(euint32 value) internal returns (euint16) {\\n        return euint16.wrap(Impl.cast(euint32.unwrap(value), Common.euint16_t));\\n    }\\n\\n    // Cast an encrypted integer from euint64 to euint16.\\n    function asEuint16(euint64 value) internal returns (euint16) {\\n        return euint16.wrap(Impl.cast(euint64.unwrap(value), Common.euint16_t));\\n    }\\n\\n    // Cast an encrypted integer from euint128 to euint16.\\n    function asEuint16(euint128 value) internal returns (euint16) {\\n        return euint16.wrap(Impl.cast(euint128.unwrap(value), Common.euint16_t));\\n    }\\n\\n    // Cast an encrypted integer from euint256 to euint16.\\n    function asEuint16(euint256 value) internal returns (euint16) {\\n        return euint16.wrap(Impl.cast(euint256.unwrap(value), Common.euint16_t));\\n    }\\n\\n    // Cast an encrypted integer from euint16 to ebool.\\n    function asEbool(euint16 value) internal returns (ebool) {\\n        return ne(value, 0);\\n    }\\n\\n    // Converts an 'ebool' to an 'euint16'.\\n    function asEuint16(ebool b) internal returns (euint16) {\\n        return euint16.wrap(Impl.cast(ebool.unwrap(b), Common.euint16_t));\\n    }\\n\\n    // Cast an encrypted integer from euint4 to euint32.\\n    function asEuint32(euint4 value) internal returns (euint32) {\\n        return euint32.wrap(Impl.cast(euint4.unwrap(value), Common.euint32_t));\\n    }\\n\\n    // Cast an encrypted integer from euint8 to euint32.\\n    function asEuint32(euint8 value) internal returns (euint32) {\\n        return euint32.wrap(Impl.cast(euint8.unwrap(value), Common.euint32_t));\\n    }\\n\\n    // Cast an encrypted integer from euint16 to euint32.\\n    function asEuint32(euint16 value) internal returns (euint32) {\\n        return euint32.wrap(Impl.cast(euint16.unwrap(value), Common.euint32_t));\\n    }\\n\\n    // Cast an encrypted integer from euint64 to euint32.\\n    function asEuint32(euint64 value) internal returns (euint32) {\\n        return euint32.wrap(Impl.cast(euint64.unwrap(value), Common.euint32_t));\\n    }\\n\\n    // Cast an encrypted integer from euint128 to euint32.\\n    function asEuint32(euint128 value) internal returns (euint32) {\\n        return euint32.wrap(Impl.cast(euint128.unwrap(value), Common.euint32_t));\\n    }\\n\\n    // Cast an encrypted integer from euint256 to euint32.\\n    function asEuint32(euint256 value) internal returns (euint32) {\\n        return euint32.wrap(Impl.cast(euint256.unwrap(value), Common.euint32_t));\\n    }\\n\\n    // Cast an encrypted integer from euint32 to ebool.\\n    function asEbool(euint32 value) internal returns (ebool) {\\n        return ne(value, 0);\\n    }\\n\\n    // Converts an 'ebool' to an 'euint32'.\\n    function asEuint32(ebool b) internal returns (euint32) {\\n        return euint32.wrap(Impl.cast(ebool.unwrap(b), Common.euint32_t));\\n    }\\n\\n    // Cast an encrypted integer from euint4 to euint64.\\n    function asEuint64(euint4 value) internal returns (euint64) {\\n        return euint64.wrap(Impl.cast(euint4.unwrap(value), Common.euint64_t));\\n    }\\n\\n    // Cast an encrypted integer from euint8 to euint64.\\n    function asEuint64(euint8 value) internal returns (euint64) {\\n        return euint64.wrap(Impl.cast(euint8.unwrap(value), Common.euint64_t));\\n    }\\n\\n    // Cast an encrypted integer from euint16 to euint64.\\n    function asEuint64(euint16 value) internal returns (euint64) {\\n        return euint64.wrap(Impl.cast(euint16.unwrap(value), Common.euint64_t));\\n    }\\n\\n    // Cast an encrypted integer from euint32 to euint64.\\n    function asEuint64(euint32 value) internal returns (euint64) {\\n        return euint64.wrap(Impl.cast(euint32.unwrap(value), Common.euint64_t));\\n    }\\n\\n    // Cast an encrypted integer from euint128 to euint64.\\n    function asEuint64(euint128 value) internal returns (euint64) {\\n        return euint64.wrap(Impl.cast(euint128.unwrap(value), Common.euint64_t));\\n    }\\n\\n    // Cast an encrypted integer from euint256 to euint64.\\n    function asEuint64(euint256 value) internal returns (euint64) {\\n        return euint64.wrap(Impl.cast(euint256.unwrap(value), Common.euint64_t));\\n    }\\n\\n    // Cast an encrypted integer from euint64 to ebool.\\n    function asEbool(euint64 value) internal returns (ebool) {\\n        return ne(value, 0);\\n    }\\n\\n    // Converts an 'ebool' to an 'euint64'.\\n    function asEuint64(ebool b) internal returns (euint64) {\\n        return euint64.wrap(Impl.cast(ebool.unwrap(b), Common.euint64_t));\\n    }\\n\\n    // Cast an encrypted integer from euint4 to euint128.\\n    function asEuint128(euint4 value) internal returns (euint128) {\\n        return euint128.wrap(Impl.cast(euint4.unwrap(value), Common.euint128_t));\\n    }\\n\\n    // Cast an encrypted integer from euint8 to euint128.\\n    function asEuint128(euint8 value) internal returns (euint128) {\\n        return euint128.wrap(Impl.cast(euint8.unwrap(value), Common.euint128_t));\\n    }\\n\\n    // Cast an encrypted integer from euint16 to euint128.\\n    function asEuint128(euint16 value) internal returns (euint128) {\\n        return euint128.wrap(Impl.cast(euint16.unwrap(value), Common.euint128_t));\\n    }\\n\\n    // Cast an encrypted integer from euint32 to euint128.\\n    function asEuint128(euint32 value) internal returns (euint128) {\\n        return euint128.wrap(Impl.cast(euint32.unwrap(value), Common.euint128_t));\\n    }\\n\\n    // Cast an encrypted integer from euint64 to euint128.\\n    function asEuint128(euint64 value) internal returns (euint128) {\\n        return euint128.wrap(Impl.cast(euint64.unwrap(value), Common.euint128_t));\\n    }\\n\\n    // Cast an encrypted integer from euint256 to euint128.\\n    function asEuint128(euint256 value) internal returns (euint128) {\\n        return euint128.wrap(Impl.cast(euint256.unwrap(value), Common.euint128_t));\\n    }\\n\\n    // Cast an encrypted integer from euint128 to ebool.\\n    function asEbool(euint128 value) internal returns (ebool) {\\n        return ne(value, 0);\\n    }\\n\\n    // Converts an 'ebool' to an 'euint128'.\\n    function asEuint128(ebool b) internal returns (euint128) {\\n        return euint128.wrap(Impl.cast(ebool.unwrap(b), Common.euint128_t));\\n    }\\n\\n    // Cast an encrypted integer from euint4 to euint256.\\n    function asEuint256(euint4 value) internal returns (euint256) {\\n        return euint256.wrap(Impl.cast(euint4.unwrap(value), Common.euint256_t));\\n    }\\n\\n    // Cast an encrypted integer from euint8 to euint256.\\n    function asEuint256(euint8 value) internal returns (euint256) {\\n        return euint256.wrap(Impl.cast(euint8.unwrap(value), Common.euint256_t));\\n    }\\n\\n    // Cast an encrypted integer from euint16 to euint256.\\n    function asEuint256(euint16 value) internal returns (euint256) {\\n        return euint256.wrap(Impl.cast(euint16.unwrap(value), Common.euint256_t));\\n    }\\n\\n    // Cast an encrypted integer from euint32 to euint256.\\n    function asEuint256(euint32 value) internal returns (euint256) {\\n        return euint256.wrap(Impl.cast(euint32.unwrap(value), Common.euint256_t));\\n    }\\n\\n    // Cast an encrypted integer from euint64 to euint256.\\n    function asEuint256(euint64 value) internal returns (euint256) {\\n        return euint256.wrap(Impl.cast(euint64.unwrap(value), Common.euint256_t));\\n    }\\n\\n    // Cast an encrypted integer from euint128 to euint256.\\n    function asEuint256(euint128 value) internal returns (euint256) {\\n        return euint256.wrap(Impl.cast(euint128.unwrap(value), Common.euint256_t));\\n    }\\n\\n    // Cast an encrypted integer from euint256 to ebool.\\n    function asEbool(euint256 value) internal returns (ebool) {\\n        return ne(value, 0);\\n    }\\n\\n    // Converts an 'ebool' to an 'euint256'.\\n    function asEuint256(ebool b) internal returns (euint256) {\\n        return euint256.wrap(Impl.cast(ebool.unwrap(b), Common.euint256_t));\\n    }\\n\\n    function neg(euint4 value) internal returns (euint4) {\\n        return euint4.wrap(Impl.neg(euint4.unwrap(value)));\\n    }\\n\\n    function not(euint4 value) internal returns (euint4) {\\n        return euint4.wrap(Impl.not(euint4.unwrap(value)));\\n    }\\n\\n    function neg(euint8 value) internal returns (euint8) {\\n        return euint8.wrap(Impl.neg(euint8.unwrap(value)));\\n    }\\n\\n    function not(euint8 value) internal returns (euint8) {\\n        return euint8.wrap(Impl.not(euint8.unwrap(value)));\\n    }\\n\\n    function neg(euint16 value) internal returns (euint16) {\\n        return euint16.wrap(Impl.neg(euint16.unwrap(value)));\\n    }\\n\\n    function not(euint16 value) internal returns (euint16) {\\n        return euint16.wrap(Impl.not(euint16.unwrap(value)));\\n    }\\n\\n    function neg(euint32 value) internal returns (euint32) {\\n        return euint32.wrap(Impl.neg(euint32.unwrap(value)));\\n    }\\n\\n    function not(euint32 value) internal returns (euint32) {\\n        return euint32.wrap(Impl.not(euint32.unwrap(value)));\\n    }\\n\\n    function neg(euint64 value) internal returns (euint64) {\\n        return euint64.wrap(Impl.neg(euint64.unwrap(value)));\\n    }\\n\\n    function not(euint64 value) internal returns (euint64) {\\n        return euint64.wrap(Impl.not(euint64.unwrap(value)));\\n    }\\n\\n    function neg(euint128 value) internal returns (euint128) {\\n        return euint128.wrap(Impl.neg(euint128.unwrap(value)));\\n    }\\n\\n    function not(euint128 value) internal returns (euint128) {\\n        return euint128.wrap(Impl.not(euint128.unwrap(value)));\\n    }\\n\\n    function neg(euint256 value) internal returns (euint256) {\\n        return euint256.wrap(Impl.neg(euint256.unwrap(value)));\\n    }\\n\\n    function not(euint256 value) internal returns (euint256) {\\n        return euint256.wrap(Impl.not(euint256.unwrap(value)));\\n    }\\n\\n    // Convert an inputHandle with corresponding inputProof to an encrypted euint4 integer.\\n    function asEuint4(einput inputHandle, bytes memory inputProof) internal returns (euint4) {\\n        return euint4.wrap(Impl.verify(einput.unwrap(inputHandle), inputProof, Common.euint4_t));\\n    }\\n\\n    // Convert a plaintext value to an encrypted euint4 integer.\\n    function asEuint4(uint256 value) internal returns (euint4) {\\n        return euint4.wrap(Impl.trivialEncrypt(value, Common.euint4_t));\\n    }\\n\\n    // Convert an inputHandle with corresponding inputProof to an encrypted euint8 integer.\\n    function asEuint8(einput inputHandle, bytes memory inputProof) internal returns (euint8) {\\n        return euint8.wrap(Impl.verify(einput.unwrap(inputHandle), inputProof, Common.euint8_t));\\n    }\\n\\n    // Convert a plaintext value to an encrypted euint8 integer.\\n    function asEuint8(uint256 value) internal returns (euint8) {\\n        return euint8.wrap(Impl.trivialEncrypt(value, Common.euint8_t));\\n    }\\n\\n    // Convert an inputHandle with corresponding inputProof to an encrypted euint16 integer.\\n    function asEuint16(einput inputHandle, bytes memory inputProof) internal returns (euint16) {\\n        return euint16.wrap(Impl.verify(einput.unwrap(inputHandle), inputProof, Common.euint16_t));\\n    }\\n\\n    // Convert a plaintext value to an encrypted euint16 integer.\\n    function asEuint16(uint256 value) internal returns (euint16) {\\n        return euint16.wrap(Impl.trivialEncrypt(value, Common.euint16_t));\\n    }\\n\\n    // Convert an inputHandle with corresponding inputProof to an encrypted euint32 integer.\\n    function asEuint32(einput inputHandle, bytes memory inputProof) internal returns (euint32) {\\n        return euint32.wrap(Impl.verify(einput.unwrap(inputHandle), inputProof, Common.euint32_t));\\n    }\\n\\n    // Convert a plaintext value to an encrypted euint32 integer.\\n    function asEuint32(uint256 value) internal returns (euint32) {\\n        return euint32.wrap(Impl.trivialEncrypt(value, Common.euint32_t));\\n    }\\n\\n    // Convert an inputHandle with corresponding inputProof to an encrypted euint64 integer.\\n    function asEuint64(einput inputHandle, bytes memory inputProof) internal returns (euint64) {\\n        return euint64.wrap(Impl.verify(einput.unwrap(inputHandle), inputProof, Common.euint64_t));\\n    }\\n\\n    // Convert a plaintext value to an encrypted euint64 integer.\\n    function asEuint64(uint256 value) internal returns (euint64) {\\n        return euint64.wrap(Impl.trivialEncrypt(value, Common.euint64_t));\\n    }\\n\\n    // Convert an inputHandle with corresponding inputProof to an encrypted euint128 integer.\\n    function asEuint128(einput inputHandle, bytes memory inputProof) internal returns (euint128) {\\n        return euint128.wrap(Impl.verify(einput.unwrap(inputHandle), inputProof, Common.euint128_t));\\n    }\\n\\n    // Convert a plaintext value to an encrypted euint128 integer.\\n    function asEuint128(uint256 value) internal returns (euint128) {\\n        return euint128.wrap(Impl.trivialEncrypt(value, Common.euint128_t));\\n    }\\n\\n    // Convert an inputHandle with corresponding inputProof to an encrypted euint256 integer.\\n    function asEuint256(einput inputHandle, bytes memory inputProof) internal returns (euint256) {\\n        return euint256.wrap(Impl.verify(einput.unwrap(inputHandle), inputProof, Common.euint256_t));\\n    }\\n\\n    // Convert a plaintext value to an encrypted euint256 integer.\\n    function asEuint256(uint256 value) internal returns (euint256) {\\n        return euint256.wrap(Impl.trivialEncrypt(value, Common.euint256_t));\\n    }\\n\\n    // Generates a random encrypted boolean.\\n    function randEbool() internal returns (ebool) {\\n        return ebool.wrap(Impl.rand(Common.ebool_t));\\n    }\\n\\n    // Generates a random encrypted 4-bit unsigned integer.\\n    function randEuint4() internal returns (euint4) {\\n        return euint4.wrap(Impl.rand(Common.euint4_t));\\n    }\\n\\n    // Generates a random encrypted 4-bit unsigned integer in the [0, upperBound) range.\\n    // The upperBound must be a power of 2.\\n    function randEuint4(uint8 upperBound) internal returns (euint4) {\\n        return euint4.wrap(Impl.randBounded(upperBound, Common.euint4_t));\\n    }\\n\\n    // Generates a random encrypted 8-bit unsigned integer.\\n    function randEuint8() internal returns (euint8) {\\n        return euint8.wrap(Impl.rand(Common.euint8_t));\\n    }\\n\\n    // Generates a random encrypted 8-bit unsigned integer in the [0, upperBound) range.\\n    // The upperBound must be a power of 2.\\n    function randEuint8(uint8 upperBound) internal returns (euint8) {\\n        return euint8.wrap(Impl.randBounded(upperBound, Common.euint8_t));\\n    }\\n\\n    // Generates a random encrypted 16-bit unsigned integer.\\n    function randEuint16() internal returns (euint16) {\\n        return euint16.wrap(Impl.rand(Common.euint16_t));\\n    }\\n\\n    // Generates a random encrypted 16-bit unsigned integer in the [0, upperBound) range.\\n    // The upperBound must be a power of 2.\\n    function randEuint16(uint16 upperBound) internal returns (euint16) {\\n        return euint16.wrap(Impl.randBounded(upperBound, Common.euint16_t));\\n    }\\n\\n    // Generates a random encrypted 32-bit unsigned integer.\\n    function randEuint32() internal returns (euint32) {\\n        return euint32.wrap(Impl.rand(Common.euint32_t));\\n    }\\n\\n    // Generates a random encrypted 32-bit unsigned integer in the [0, upperBound) range.\\n    // The upperBound must be a power of 2.\\n    function randEuint32(uint32 upperBound) internal returns (euint32) {\\n        return euint32.wrap(Impl.randBounded(upperBound, Common.euint32_t));\\n    }\\n\\n    // Generates a random encrypted 64-bit unsigned integer.\\n    function randEuint64() internal returns (euint64) {\\n        return euint64.wrap(Impl.rand(Common.euint64_t));\\n    }\\n\\n    // Generates a random encrypted 64-bit unsigned integer in the [0, upperBound) range.\\n    // The upperBound must be a power of 2.\\n    function randEuint64(uint64 upperBound) internal returns (euint64) {\\n        return euint64.wrap(Impl.randBounded(upperBound, Common.euint64_t));\\n    }\\n\\n    // Generates a random encrypted 128-bit unsigned integer.\\n    function randEuint128() internal returns (euint128) {\\n        return euint128.wrap(Impl.rand(Common.euint128_t));\\n    }\\n\\n    // Generates a random encrypted 128-bit unsigned integer in the [0, upperBound) range.\\n    // The upperBound must be a power of 2.\\n    function randEuint128(uint128 upperBound) internal returns (euint128) {\\n        return euint128.wrap(Impl.randBounded(upperBound, Common.euint128_t));\\n    }\\n\\n    // Generates a random encrypted 256-bit unsigned integer.\\n    function randEuint256() internal returns (euint256) {\\n        return euint256.wrap(Impl.rand(Common.euint256_t));\\n    }\\n\\n    // Generates a random encrypted 256-bit unsigned integer in the [0, upperBound) range.\\n    // The upperBound must be a power of 2.\\n    function randEuint256(uint256 upperBound) internal returns (euint256) {\\n        return euint256.wrap(Impl.randBounded(upperBound, Common.euint256_t));\\n    }\\n\\n    // Generates a random encrypted 512-bit unsigned integer.\\n    function randEbytes64() internal returns (ebytes64) {\\n        return ebytes64.wrap(Impl.rand(Common.ebytes64_t));\\n    }\\n\\n    // Generates a random encrypted 1024-bit unsigned integer.\\n    function randEbytes128() internal returns (ebytes128) {\\n        return ebytes128.wrap(Impl.rand(Common.ebytes128_t));\\n    }\\n\\n    // Generates a random encrypted 2048-bit unsigned integer.\\n    function randEbytes256() internal returns (ebytes256) {\\n        return ebytes256.wrap(Impl.rand(Common.ebytes256_t));\\n    }\\n\\n    // Convert an inputHandle with corresponding inputProof to an encrypted eaddress.\\n    function asEaddress(einput inputHandle, bytes memory inputProof) internal returns (eaddress) {\\n        return eaddress.wrap(Impl.verify(einput.unwrap(inputHandle), inputProof, Common.euint160_t));\\n    }\\n\\n    // Convert a plaintext value to an encrypted address.\\n    function asEaddress(address value) internal returns (eaddress) {\\n        return eaddress.wrap(Impl.trivialEncrypt(uint160(value), Common.euint160_t));\\n    }\\n\\n    // Convert the given inputHandle and inputProof to an encrypted ebytes64 value.\\n    function asEbytes64(einput inputHandle, bytes memory inputProof) internal returns (ebytes64) {\\n        return ebytes64.wrap(Impl.verify(einput.unwrap(inputHandle), inputProof, Common.ebytes64_t));\\n    }\\n\\n    // Left-pad a bytes array with zeros such that it becomes of length 64.\\n    function padToBytes64(bytes memory input) internal pure returns (bytes memory) {\\n        require(input.length <= 64, \\\"Input exceeds 64 bytes\\\");\\n        bytes memory result = new bytes(64);\\n        uint256 paddingLength = 64 - input.length;\\n        for (uint256 i = 0; i < paddingLength; i++) {\\n            result[i] = 0;\\n        }\\n        for (uint256 i = 0; i < input.length; i++) {\\n            result[paddingLength + i] = input[i];\\n        }\\n        return result;\\n    }\\n\\n    // Convert a plaintext value - must be a bytes array of size 64 - to an encrypted Bytes64.\\n    function asEbytes64(bytes memory value) internal returns (ebytes64) {\\n        return ebytes64.wrap(Impl.trivialEncrypt(value, Common.ebytes64_t));\\n    }\\n\\n    // Convert the given inputHandle and inputProof to an encrypted ebytes128 value.\\n    function asEbytes128(einput inputHandle, bytes memory inputProof) internal returns (ebytes128) {\\n        return ebytes128.wrap(Impl.verify(einput.unwrap(inputHandle), inputProof, Common.ebytes128_t));\\n    }\\n\\n    // Left-pad a bytes array with zeros such that it becomes of length 128.\\n    function padToBytes128(bytes memory input) internal pure returns (bytes memory) {\\n        require(input.length <= 128, \\\"Input exceeds 128 bytes\\\");\\n        bytes memory result = new bytes(128);\\n        uint256 paddingLength = 128 - input.length;\\n        for (uint256 i = 0; i < paddingLength; i++) {\\n            result[i] = 0;\\n        }\\n        for (uint256 i = 0; i < input.length; i++) {\\n            result[paddingLength + i] = input[i];\\n        }\\n        return result;\\n    }\\n\\n    // Convert a plaintext value - must be a bytes array of size 128 - to an encrypted Bytes128.\\n    function asEbytes128(bytes memory value) internal returns (ebytes128) {\\n        return ebytes128.wrap(Impl.trivialEncrypt(value, Common.ebytes128_t));\\n    }\\n\\n    // Convert the given inputHandle and inputProof to an encrypted ebytes256 value.\\n    function asEbytes256(einput inputHandle, bytes memory inputProof) internal returns (ebytes256) {\\n        return ebytes256.wrap(Impl.verify(einput.unwrap(inputHandle), inputProof, Common.ebytes256_t));\\n    }\\n\\n    // Left-pad a bytes array with zeros such that it becomes of length 256.\\n    function padToBytes256(bytes memory input) internal pure returns (bytes memory) {\\n        require(input.length <= 256, \\\"Input exceeds 256 bytes\\\");\\n        bytes memory result = new bytes(256);\\n        uint256 paddingLength = 256 - input.length;\\n        for (uint256 i = 0; i < paddingLength; i++) {\\n            result[i] = 0;\\n        }\\n        for (uint256 i = 0; i < input.length; i++) {\\n            result[paddingLength + i] = input[i];\\n        }\\n        return result;\\n    }\\n\\n    // Convert a plaintext value - must be a bytes array of size 256 - to an encrypted Bytes256.\\n    function asEbytes256(bytes memory value) internal returns (ebytes256) {\\n        return ebytes256.wrap(Impl.trivialEncrypt(value, Common.ebytes256_t));\\n    }\\n\\n    // Return true if the enrypted address is initialized and false otherwise.\\n    function isInitialized(eaddress v) internal pure returns (bool) {\\n        return eaddress.unwrap(v) != 0;\\n    }\\n\\n    // Return true if the enrypted value is initialized and false otherwise.\\n    function isInitialized(ebytes64 v) internal pure returns (bool) {\\n        return ebytes64.unwrap(v) != 0;\\n    }\\n\\n    // Return true if the enrypted value is initialized and false otherwise.\\n    function isInitialized(ebytes128 v) internal pure returns (bool) {\\n        return ebytes128.unwrap(v) != 0;\\n    }\\n\\n    // Return true if the enrypted value is initialized and false otherwise.\\n    function isInitialized(ebytes256 v) internal pure returns (bool) {\\n        return ebytes256.unwrap(v) != 0;\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(ebool a, ebool b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbool(false);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEbool(false);\\n        }\\n        return ebool.wrap(Impl.eq(ebool.unwrap(a), ebool.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(ebool a, ebool b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbool(false);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEbool(false);\\n        }\\n        return ebool.wrap(Impl.ne(ebool.unwrap(a), ebool.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(ebool a, bool b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbool(false);\\n        }\\n        uint256 bProc = b ? 1 : 0;\\n        return ebool.wrap(Impl.eq(ebool.unwrap(a), bProc, true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(bool b, ebool a) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbool(false);\\n        }\\n        uint256 bProc = b ? 1 : 0;\\n        return ebool.wrap(Impl.eq(ebool.unwrap(a), bProc, true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(ebool a, bool b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbool(false);\\n        }\\n        uint256 bProc = b ? 1 : 0;\\n        return ebool.wrap(Impl.ne(ebool.unwrap(a), bProc, true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(bool b, ebool a) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbool(false);\\n        }\\n        uint256 bProc = b ? 1 : 0;\\n        return ebool.wrap(Impl.ne(ebool.unwrap(a), bProc, true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(eaddress a, eaddress b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEaddress(address(0));\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEaddress(address(0));\\n        }\\n        return ebool.wrap(Impl.eq(eaddress.unwrap(a), eaddress.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(eaddress a, eaddress b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEaddress(address(0));\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEaddress(address(0));\\n        }\\n        return ebool.wrap(Impl.ne(eaddress.unwrap(a), eaddress.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(eaddress a, address b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEaddress(address(0));\\n        }\\n        uint256 bProc = uint256(uint160(b));\\n        return ebool.wrap(Impl.eq(eaddress.unwrap(a), bProc, true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(address b, eaddress a) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEaddress(address(0));\\n        }\\n        uint256 bProc = uint256(uint160(b));\\n        return ebool.wrap(Impl.eq(eaddress.unwrap(a), bProc, true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(eaddress a, address b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEaddress(address(0));\\n        }\\n        uint256 bProc = uint256(uint160(b));\\n        return ebool.wrap(Impl.ne(eaddress.unwrap(a), bProc, true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(address b, eaddress a) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEaddress(address(0));\\n        }\\n        uint256 bProc = uint256(uint160(b));\\n        return ebool.wrap(Impl.ne(eaddress.unwrap(a), bProc, true));\\n    }\\n\\n    // If 'control''s value is 'true', the result has the same value as 'a'.\\n    // If 'control''s value is 'false', the result has the same value as 'b'.\\n    function select(ebool control, ebool a, ebool b) internal returns (ebool) {\\n        return ebool.wrap(Impl.select(ebool.unwrap(control), ebool.unwrap(a), ebool.unwrap(b)));\\n    }\\n\\n    // If 'control''s value is 'true', the result has the same value as 'a'.\\n    // If 'control''s value is 'false', the result has the same value as 'b'.\\n    function select(ebool control, eaddress a, eaddress b) internal returns (eaddress) {\\n        return eaddress.wrap(Impl.select(ebool.unwrap(control), eaddress.unwrap(a), eaddress.unwrap(b)));\\n    }\\n\\n    // If 'control''s value is 'true', the result has the same value as 'a'.\\n    // If 'control''s value is 'false', the result has the same value as 'b'.\\n    function select(ebool control, ebytes64 a, ebytes64 b) internal returns (ebytes64) {\\n        return ebytes64.wrap(Impl.select(ebool.unwrap(control), ebytes64.unwrap(a), ebytes64.unwrap(b)));\\n    }\\n\\n    // If 'control''s value is 'true', the result has the same value as 'a'.\\n    // If 'control''s value is 'false', the result has the same value as 'b'.\\n    function select(ebool control, ebytes128 a, ebytes128 b) internal returns (ebytes128) {\\n        return ebytes128.wrap(Impl.select(ebool.unwrap(control), ebytes128.unwrap(a), ebytes128.unwrap(b)));\\n    }\\n\\n    // If 'control''s value is 'true', the result has the same value as 'a'.\\n    // If 'control''s value is 'false', the result has the same value as 'b'.\\n    function select(ebool control, ebytes256 a, ebytes256 b) internal returns (ebytes256) {\\n        return ebytes256.wrap(Impl.select(ebool.unwrap(control), ebytes256.unwrap(a), ebytes256.unwrap(b)));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(ebytes64 a, ebytes64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbytes64(padToBytes64(hex\\\"\\\"));\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEbytes64(padToBytes64(hex\\\"\\\"));\\n        }\\n        return ebool.wrap(Impl.eq(ebytes64.unwrap(a), ebytes64.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(ebytes64 a, bytes memory b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbytes64(padToBytes64(hex\\\"\\\"));\\n        }\\n        return ebool.wrap(Impl.eq(ebytes64.unwrap(a), b, true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(bytes memory a, ebytes64 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEbytes64(padToBytes64(hex\\\"\\\"));\\n        }\\n        return ebool.wrap(Impl.eq(ebytes64.unwrap(b), a, true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(ebytes64 a, ebytes64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbytes64(padToBytes64(hex\\\"\\\"));\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEbytes64(padToBytes64(hex\\\"\\\"));\\n        }\\n        return ebool.wrap(Impl.ne(ebytes64.unwrap(a), ebytes64.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(ebytes64 a, bytes memory b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbytes64(padToBytes64(hex\\\"\\\"));\\n        }\\n        return ebool.wrap(Impl.ne(ebytes64.unwrap(a), b, true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(bytes memory a, ebytes64 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEbytes64(padToBytes64(hex\\\"\\\"));\\n        }\\n        return ebool.wrap(Impl.ne(ebytes64.unwrap(b), a, true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(ebytes128 a, ebytes128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbytes128(padToBytes128(hex\\\"\\\"));\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEbytes128(padToBytes128(hex\\\"\\\"));\\n        }\\n        return ebool.wrap(Impl.eq(ebytes128.unwrap(a), ebytes128.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(ebytes128 a, bytes memory b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbytes128(padToBytes128(hex\\\"\\\"));\\n        }\\n        return ebool.wrap(Impl.eq(ebytes128.unwrap(a), b, true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(bytes memory a, ebytes128 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEbytes128(padToBytes128(hex\\\"\\\"));\\n        }\\n        return ebool.wrap(Impl.eq(ebytes128.unwrap(b), a, true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(ebytes128 a, ebytes128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbytes128(padToBytes128(hex\\\"\\\"));\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEbytes128(padToBytes128(hex\\\"\\\"));\\n        }\\n        return ebool.wrap(Impl.ne(ebytes128.unwrap(a), ebytes128.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(ebytes128 a, bytes memory b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbytes128(padToBytes128(hex\\\"\\\"));\\n        }\\n        return ebool.wrap(Impl.ne(ebytes128.unwrap(a), b, true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(bytes memory a, ebytes128 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEbytes128(padToBytes128(hex\\\"\\\"));\\n        }\\n        return ebool.wrap(Impl.ne(ebytes128.unwrap(b), a, true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(ebytes256 a, ebytes256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbytes256(padToBytes256(hex\\\"\\\"));\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEbytes256(padToBytes256(hex\\\"\\\"));\\n        }\\n        return ebool.wrap(Impl.eq(ebytes256.unwrap(a), ebytes256.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(ebytes256 a, bytes memory b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbytes256(padToBytes256(hex\\\"\\\"));\\n        }\\n        return ebool.wrap(Impl.eq(ebytes256.unwrap(a), b, true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(bytes memory a, ebytes256 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEbytes256(padToBytes256(hex\\\"\\\"));\\n        }\\n        return ebool.wrap(Impl.eq(ebytes256.unwrap(b), a, true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(ebytes256 a, ebytes256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbytes256(padToBytes256(hex\\\"\\\"));\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEbytes256(padToBytes256(hex\\\"\\\"));\\n        }\\n        return ebool.wrap(Impl.ne(ebytes256.unwrap(a), ebytes256.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(ebytes256 a, bytes memory b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbytes256(padToBytes256(hex\\\"\\\"));\\n        }\\n        return ebool.wrap(Impl.ne(ebytes256.unwrap(a), b, true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(bytes memory a, ebytes256 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEbytes256(padToBytes256(hex\\\"\\\"));\\n        }\\n        return ebool.wrap(Impl.ne(ebytes256.unwrap(b), a, true));\\n    }\\n\\n    // cleans the transient storage of ACL containing all the allowedTransient accounts\\n    // to be used for integration with Account Abstraction or when bundling UserOps calling the FHEVMCoprocessor\\n    function cleanTransientStorage() internal {\\n        return Impl.cleanTransientStorage();\\n    }\\n\\n    function isAllowed(ebool value, address account) internal view returns (bool) {\\n        return Impl.isAllowed(ebool.unwrap(value), account);\\n    }\\n    function isAllowed(euint4 value, address account) internal view returns (bool) {\\n        return Impl.isAllowed(euint4.unwrap(value), account);\\n    }\\n    function isAllowed(euint8 value, address account) internal view returns (bool) {\\n        return Impl.isAllowed(euint8.unwrap(value), account);\\n    }\\n    function isAllowed(euint16 value, address account) internal view returns (bool) {\\n        return Impl.isAllowed(euint16.unwrap(value), account);\\n    }\\n    function isAllowed(euint32 value, address account) internal view returns (bool) {\\n        return Impl.isAllowed(euint32.unwrap(value), account);\\n    }\\n    function isAllowed(euint64 value, address account) internal view returns (bool) {\\n        return Impl.isAllowed(euint64.unwrap(value), account);\\n    }\\n    function isAllowed(euint128 value, address account) internal view returns (bool) {\\n        return Impl.isAllowed(euint128.unwrap(value), account);\\n    }\\n    function isAllowed(euint256 value, address account) internal view returns (bool) {\\n        return Impl.isAllowed(euint256.unwrap(value), account);\\n    }\\n    function isAllowed(eaddress value, address account) internal view returns (bool) {\\n        return Impl.isAllowed(eaddress.unwrap(value), account);\\n    }\\n\\n    function isAllowed(ebytes256 value, address account) internal view returns (bool) {\\n        return Impl.isAllowed(ebytes256.unwrap(value), account);\\n    }\\n\\n    function isSenderAllowed(ebool value) internal view returns (bool) {\\n        return Impl.isAllowed(ebool.unwrap(value), msg.sender);\\n    }\\n\\n    function isSenderAllowed(euint4 value) internal view returns (bool) {\\n        return Impl.isAllowed(euint4.unwrap(value), msg.sender);\\n    }\\n\\n    function isSenderAllowed(euint8 value) internal view returns (bool) {\\n        return Impl.isAllowed(euint8.unwrap(value), msg.sender);\\n    }\\n\\n    function isSenderAllowed(euint16 value) internal view returns (bool) {\\n        return Impl.isAllowed(euint16.unwrap(value), msg.sender);\\n    }\\n\\n    function isSenderAllowed(euint32 value) internal view returns (bool) {\\n        return Impl.isAllowed(euint32.unwrap(value), msg.sender);\\n    }\\n\\n    function isSenderAllowed(euint64 value) internal view returns (bool) {\\n        return Impl.isAllowed(euint64.unwrap(value), msg.sender);\\n    }\\n\\n    function isSenderAllowed(euint128 value) internal view returns (bool) {\\n        return Impl.isAllowed(euint128.unwrap(value), msg.sender);\\n    }\\n\\n    function isSenderAllowed(euint256 value) internal view returns (bool) {\\n        return Impl.isAllowed(euint256.unwrap(value), msg.sender);\\n    }\\n\\n    function isSenderAllowed(eaddress value) internal view returns (bool) {\\n        return Impl.isAllowed(eaddress.unwrap(value), msg.sender);\\n    }\\n\\n    function isSenderAllowed(ebytes256 value) internal view returns (bool) {\\n        return Impl.isAllowed(ebytes256.unwrap(value), msg.sender);\\n    }\\n\\n    function allow(ebool value, address account) internal {\\n        Impl.allow(ebool.unwrap(value), account);\\n    }\\n\\n    function allowThis(ebool value) internal {\\n        Impl.allow(ebool.unwrap(value), address(this));\\n    }\\n\\n    function allow(euint4 value, address account) internal {\\n        Impl.allow(euint4.unwrap(value), account);\\n    }\\n\\n    function allowThis(euint4 value) internal {\\n        Impl.allow(euint4.unwrap(value), address(this));\\n    }\\n\\n    function allow(euint8 value, address account) internal {\\n        Impl.allow(euint8.unwrap(value), account);\\n    }\\n\\n    function allowThis(euint8 value) internal {\\n        Impl.allow(euint8.unwrap(value), address(this));\\n    }\\n\\n    function allow(euint16 value, address account) internal {\\n        Impl.allow(euint16.unwrap(value), account);\\n    }\\n\\n    function allowThis(euint16 value) internal {\\n        Impl.allow(euint16.unwrap(value), address(this));\\n    }\\n\\n    function allow(euint32 value, address account) internal {\\n        Impl.allow(euint32.unwrap(value), account);\\n    }\\n\\n    function allowThis(euint32 value) internal {\\n        Impl.allow(euint32.unwrap(value), address(this));\\n    }\\n\\n    function allow(euint64 value, address account) internal {\\n        Impl.allow(euint64.unwrap(value), account);\\n    }\\n\\n    function allowThis(euint64 value) internal {\\n        Impl.allow(euint64.unwrap(value), address(this));\\n    }\\n\\n    function allow(euint128 value, address account) internal {\\n        Impl.allow(euint128.unwrap(value), account);\\n    }\\n\\n    function allowThis(euint128 value) internal {\\n        Impl.allow(euint128.unwrap(value), address(this));\\n    }\\n\\n    function allow(euint256 value, address account) internal {\\n        Impl.allow(euint256.unwrap(value), account);\\n    }\\n\\n    function allowThis(euint256 value) internal {\\n        Impl.allow(euint256.unwrap(value), address(this));\\n    }\\n\\n    function allow(eaddress value, address account) internal {\\n        Impl.allow(eaddress.unwrap(value), account);\\n    }\\n\\n    function allowThis(eaddress value) internal {\\n        Impl.allow(eaddress.unwrap(value), address(this));\\n    }\\n\\n    function allow(ebytes64 value, address account) internal {\\n        Impl.allow(ebytes64.unwrap(value), account);\\n    }\\n\\n    function allowThis(ebytes64 value) internal {\\n        Impl.allow(ebytes64.unwrap(value), address(this));\\n    }\\n\\n    function allow(ebytes128 value, address account) internal {\\n        Impl.allow(ebytes128.unwrap(value), account);\\n    }\\n\\n    function allowThis(ebytes128 value) internal {\\n        Impl.allow(ebytes128.unwrap(value), address(this));\\n    }\\n\\n    function allow(ebytes256 value, address account) internal {\\n        Impl.allow(ebytes256.unwrap(value), account);\\n    }\\n\\n    function allowThis(ebytes256 value) internal {\\n        Impl.allow(ebytes256.unwrap(value), address(this));\\n    }\\n\\n    function allowTransient(ebool value, address account) internal {\\n        Impl.allowTransient(ebool.unwrap(value), account);\\n    }\\n\\n    function allowTransient(euint4 value, address account) internal {\\n        Impl.allowTransient(euint4.unwrap(value), account);\\n    }\\n\\n    function allowTransient(euint8 value, address account) internal {\\n        Impl.allowTransient(euint8.unwrap(value), account);\\n    }\\n\\n    function allowTransient(euint16 value, address account) internal {\\n        Impl.allowTransient(euint16.unwrap(value), account);\\n    }\\n\\n    function allowTransient(euint32 value, address account) internal {\\n        Impl.allowTransient(euint32.unwrap(value), account);\\n    }\\n\\n    function allowTransient(euint64 value, address account) internal {\\n        Impl.allowTransient(euint64.unwrap(value), account);\\n    }\\n\\n    function allowTransient(euint128 value, address account) internal {\\n        Impl.allowTransient(euint128.unwrap(value), account);\\n    }\\n\\n    function allowTransient(euint256 value, address account) internal {\\n        Impl.allowTransient(euint256.unwrap(value), account);\\n    }\\n\\n    function allowTransient(eaddress value, address account) internal {\\n        Impl.allowTransient(eaddress.unwrap(value), account);\\n    }\\n\\n    function allowTransient(ebytes64 value, address account) internal {\\n        Impl.allowTransient(ebytes64.unwrap(value), account);\\n    }\\n\\n    function allowTransient(ebytes128 value, address account) internal {\\n        Impl.allowTransient(ebytes128.unwrap(value), account);\\n    }\\n\\n    function allowTransient(ebytes256 value, address account) internal {\\n        Impl.allowTransient(ebytes256.unwrap(value), account);\\n    }\\n}\\n\",\"keccak256\":\"0x221799c8332f83ab65a0b71746409f0c2c89f1cd8d9ba4091d967c667e1df734\",\"license\":\"BSD-3-Clause-Clear\"},\"hardhat/console.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.4.22 <0.9.0;\\n\\nlibrary console {\\n    address constant CONSOLE_ADDRESS =\\n        0x000000000000000000636F6e736F6c652e6c6f67;\\n\\n    function _sendLogPayloadImplementation(bytes memory payload) internal view {\\n        address consoleAddress = CONSOLE_ADDRESS;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            pop(\\n                staticcall(\\n                    gas(),\\n                    consoleAddress,\\n                    add(payload, 32),\\n                    mload(payload),\\n                    0,\\n                    0\\n                )\\n            )\\n        }\\n    }\\n\\n    function _castToPure(\\n      function(bytes memory) internal view fnIn\\n    ) internal pure returns (function(bytes memory) pure fnOut) {\\n        assembly {\\n            fnOut := fnIn\\n        }\\n    }\\n\\n    function _sendLogPayload(bytes memory payload) internal pure {\\n        _castToPure(_sendLogPayloadImplementation)(payload);\\n    }\\n\\n    function log() internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log()\\\"));\\n    }\\n\\n    function logInt(int256 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(int256)\\\", p0));\\n    }\\n\\n    function logUint(uint256 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256)\\\", p0));\\n    }\\n\\n    function logString(string memory p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n    }\\n\\n    function logBool(bool p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n    }\\n\\n    function logAddress(address p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n    }\\n\\n    function logBytes(bytes memory p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes)\\\", p0));\\n    }\\n\\n    function logBytes1(bytes1 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes1)\\\", p0));\\n    }\\n\\n    function logBytes2(bytes2 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes2)\\\", p0));\\n    }\\n\\n    function logBytes3(bytes3 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes3)\\\", p0));\\n    }\\n\\n    function logBytes4(bytes4 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes4)\\\", p0));\\n    }\\n\\n    function logBytes5(bytes5 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes5)\\\", p0));\\n    }\\n\\n    function logBytes6(bytes6 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes6)\\\", p0));\\n    }\\n\\n    function logBytes7(bytes7 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes7)\\\", p0));\\n    }\\n\\n    function logBytes8(bytes8 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes8)\\\", p0));\\n    }\\n\\n    function logBytes9(bytes9 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes9)\\\", p0));\\n    }\\n\\n    function logBytes10(bytes10 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes10)\\\", p0));\\n    }\\n\\n    function logBytes11(bytes11 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes11)\\\", p0));\\n    }\\n\\n    function logBytes12(bytes12 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes12)\\\", p0));\\n    }\\n\\n    function logBytes13(bytes13 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes13)\\\", p0));\\n    }\\n\\n    function logBytes14(bytes14 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes14)\\\", p0));\\n    }\\n\\n    function logBytes15(bytes15 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes15)\\\", p0));\\n    }\\n\\n    function logBytes16(bytes16 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes16)\\\", p0));\\n    }\\n\\n    function logBytes17(bytes17 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes17)\\\", p0));\\n    }\\n\\n    function logBytes18(bytes18 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes18)\\\", p0));\\n    }\\n\\n    function logBytes19(bytes19 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes19)\\\", p0));\\n    }\\n\\n    function logBytes20(bytes20 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes20)\\\", p0));\\n    }\\n\\n    function logBytes21(bytes21 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes21)\\\", p0));\\n    }\\n\\n    function logBytes22(bytes22 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes22)\\\", p0));\\n    }\\n\\n    function logBytes23(bytes23 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes23)\\\", p0));\\n    }\\n\\n    function logBytes24(bytes24 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes24)\\\", p0));\\n    }\\n\\n    function logBytes25(bytes25 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes25)\\\", p0));\\n    }\\n\\n    function logBytes26(bytes26 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes26)\\\", p0));\\n    }\\n\\n    function logBytes27(bytes27 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes27)\\\", p0));\\n    }\\n\\n    function logBytes28(bytes28 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes28)\\\", p0));\\n    }\\n\\n    function logBytes29(bytes29 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes29)\\\", p0));\\n    }\\n\\n    function logBytes30(bytes30 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes30)\\\", p0));\\n    }\\n\\n    function logBytes31(bytes31 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes31)\\\", p0));\\n    }\\n\\n    function logBytes32(bytes32 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes32)\\\", p0));\\n    }\\n\\n    function log(uint256 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256)\\\", p0));\\n    }\\n\\n    function log(string memory p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n    }\\n\\n    function log(bool p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n    }\\n\\n    function log(address p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n    }\\n\\n    function log(uint256 p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n}\\n\",\"keccak256\":\"0xf2560b5386574153057104d19a9e68a32ee912cf23c0c8df1fe9a0607f42d543\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x608060405234620001af575f606062000017620001b3565b828152826020820152826040820152015262000032620001b3565b606073fee8407e2f5e3ee68ad77cae98c434e637f516e59182815273687408ab54661ba0b4aef3a44156c616c6955e0780602083015273fb03be574d14c256d56f09a198b586bdfc0a9de291826040820152739d6891a6240d6130c54ae243d8005063d05fe14b938491015260018060a01b0319937fed8d60e34876f751cc8b014c560745351147d9de11b9347c854e881b128ea60090858254161790557fed8d60e34876f751cc8b014c560745351147d9de11b9347c854e881b128ea60190848254161790557fed8d60e34876f751cc8b014c560745351147d9de11b9347c854e881b128ea60290838254161790557fed8d60e34876f751cc8b014c560745351147d9de11b9347c854e881b128ea60390828254161790557333347831500f1e73f0cccbb95c9f86b94d7b11237f93ab6e17f2c461cce6ea5d4ec117e51dda77a64affc2b2c05f8cd440def0e7009182541617905560018060401b031980600a5416600a55600f5416600f556040516143889081620001e88239f35b5f80fd5b60405190608082016001600160401b03811183821017620001d357604052565b634e487b7160e01b5f52604160045260245ffdfe6080806040526004361015610012575f80fd5b5f905f3560e01c9081630d79e8ec1461280457508063336f3dbc146127745780633c5e7587146126af5780633d14f4c9146126365780635c556160146125dc5780635d4f28bc146125b557806362c2a450146122c05780636fa78d39146122605780638a0d72021461213157806398829d3314611f24578063a667533f14611ca9578063b9e073d114611b62578063c82c77b11461104c578063c9f68c4714610ffa578063d67758ba14610fce578063e50752eb14610f4d578063e62d604a14610f31578063eb264b9c14610f0a578063f4f8a4a214610eb0578063f601440614610836578063f665c3a21461012e5763f9e46a1414610110575f80fd5b3461012b578060031936011261012b57602060405160038152f35b80fd5b503461012b57608036600319011261012b57610148613275565b6001600160401b0391906044358381116108325761016a903690600401613234565b90936064359281841161082e573660238501121561082e578184600401351161082e5736602485600401358601011161082e5781600a54168282161015610815578181168552600b60205260408520600260ff6006830154166101cc816135e6565b146107fb57600581015442116107fb576004015442106107e3578181168552600e60205260408520335f5260205260ff60405f2054166107ba578181168552600b602052604085209260038401548082036107965750600684015461023360ff82166135e6565b600160ff821603610784575b5061025d61025536876004013560248901613689565b602435613fdb565b93610268308661423a565b6102e26020886002840161029263ffffffff610287818454168c6140e6565b9254851c168a61415e565b826001600160a01b035f8051602061435c83398151915254169260405196879586948593630ccd46b160e31b8552600485019192604091949360608401958452602084015260ff60f81b16910152565b03925af1908115610779578891610747575b509795919061030282613ae5565b9688935b83851061059d5750505050506040519561031f876132f1565b600187526020368189013761033387613967565b526064420195864211610589576001600160a01b037fed8d60e34876f751cc8b014c560745351147d9de11b9347c854e881b128ea6005416803b156105855786604051809263155f840160e21b82526020600483015281838161039960248201896141d6565b03925af1801561057a57908791610562575b50506104046020916001600160a01b037f93ab6e17f2c461cce6ea5d4ec117e51dda77a64affc2b2c05f8cd440def0e70054169088604051809b81958294634c0d927760e01b845260a0600485015260a48401906141d6565b9063062c2a4560e41b6024840152836044840152606483015282608483015203925af195861561055757859661051f575b50858552600860205260408520918254600160401b938482101561050b57816104679160016104809594018155613c14565b919093169083549060031b91821b915f19901b19161790565b90558484526007602052604084208054918210156104f757816104ac9160016104cb9594018155613c14565b81549060031b906001600160a01b0333831b921b191617905584614209565b815b81518110156104f357806104ed6104e660019385613974565b5186614209565b016104cd565b8280f35b634e487b7160e01b85526041600452602485fd5b634e487b7160e01b88526041600452602488fd5b9095506020813d60201161054f575b8161053b6020938361335d565b8101031261054b5751945f610435565b5f80fd5b3d915061052e565b6040513d87823e3d90fd5b61056b906132c3565b61057657855f6103ab565b8580fd5b6040513d89823e3d90fd5b8680fd5b634e487b7160e01b86526011600452602486fd5b909192939961063f60208b8b6102928f63ffffffff600261063383600361061b8f968f8f8888610623858f61061b8f968b926105f761062d9a6105eb87943690602481600401359101613689565b908460051b0135613fdb565b6106018383613974565b52610616306106108484613974565b5161423a565b613974565b519501613cbf565b50015416906140e6565b99613974565b500154861c169061415e565b03925af190811561073c57908b92918391610704575b505f8051602061435c83398151915254604051630ccd46b160e31b8152600481019390935260248301919091526001600160f81b031983166044830152909160209183916064918391906001600160a01b03165af180156106f9578a906106c6575b600191509a0193929190610306565b506020813d6020116106f1575b816106e06020938361335d565b8101031261054b57600190516106b7565b3d91506106d3565b6040513d8c823e3d90fd5b9250506020823d602011610734575b816107206020938361335d565b8101031261054b5790518a91906020610655565b3d9150610713565b6040513d8d823e3d90fd5b90506020813d602011610771575b816107626020938361335d565b8101031261054b57515f6102f4565b3d9150610755565b6040513d8a823e3d90fd5b60ff191660011760068501555f61023f565b90606493604051936375bf0e8360e01b855216600484015260248301526044820152fd5b604051632728f33d60e11b81526001600160401b03919091166004820152336024820152604490fd5b60405162c0df1b60e21b815291166004820152602490fd5b50604051635c6d3af360e01b815291166004820152602490fd5b60405163277e73b360e11b815291166004820152602490fd5b8480fd5b8280fd5b503461012b57604036600319011261012b57610850613275565b906001600160401b036024351161012b5736602360243501121561012b576001600160401b03602435600401351161012b57366024606081356004013502813501011161012b576001600160401b03600a54166001600160401b0383161015610e8f576001600160401b0382168152600d60205260408120335f5260205260ff60405f20541615610e6e576001600160401b0382168152600b6020526040812063ffffffff600661090085613c29565b92015460081c1611610e4d576001600160401b03600f5416906001600160401b0383168152600b602052604081206109366142b4565b90600281015460ff8160401c1661094c81613437565b610db55750600263ffffffff91015460201c169261097763ffffffff61097186613ba5565b16613ae5565b90835b856001600160401b038216116109d4578361099e6001600160401b03831685613974565b526001600160401b03808216146109c0576001600160401b031660010161097a565b634e487b7160e01b85526011600452602485fd5b5093505b6001600160401b03604051956109ed87613327565b168552336020860152610a0560243560040135613420565b610a12604051918261335d565b602480356004810135835201602082015b6024606081356004013502813501018210610d585750506040860152606085015260808401528060a08401528060c08401528181526010602052604081206001600160401b038451168154907bffffffffffffffffffffffffffffffffffffffff0000000000000000602087015160401b169163ffffffff60e01b16171781556040840151805190600160401b8211610d44576001830154826001850155808310610d1a575b5060200190600183018452602084209184905b828210610cb0575050505060608401518051906001600160401b038211610c9c57602090610b0d8360028601613b17565b0160028301845260208420845b838110610c885750505050600490608085015160038201550163ffffffff60a08501511681549064ff0000000060c0870151610b5581613437565b610b5e81613437565b60201b169164ffffffffff191617179055600f546001600160401b03610b8581831661393b565b16906001600160401b03191617600f55338152601160205260408120805490600160401b821015610c745790610bc09160018201815561361c565b81549060031b906001600160401b0385831b921b19161790555b60608301518051821015610c125790610bfa600192610610833092613974565b610c0c33610610836060880151613974565b01610bda565b602083610c3286610c2730608083015161423a565b60803391015161423a565b604080516001600160401b03831681523360208201527fc151e2ad5f7ea91d34238328a2fcfd1328147d1625b5b491a917ce06a7ca4cdc9190a1604051908152f35b634e487b7160e01b83526041600452602483fd5b600190602084519401938184015501610b1a565b634e487b7160e01b84526041600452602484fd5b805160ff815116908554916020820151916004831015610d06579260209261ff006001969365ffffffff000060408998015160101b169365ffffffffffff1916179160081b161717875501940191019092610adc565b634e487b7160e01b8a52602160045260248afd5b600184015f5260205f20908382015b8183018110610d39575050610ac9565b5f8155600101610d29565b634e487b7160e01b5f52604160045260245ffd5b60608236031261057657604051610d6e81613342565b60ff8335168335036105855782358152600460208401351015610585576060916020918285013583820152610da560408601613264565b6040820152815201910190610a23565b90604051908160808101106001600160401b03608084011117610d445760808201604052600382526060366020840137610df863ffffffff839460201c16614305565b610e0183613967565b52815160011015610e395763ffffffff6002610e2592866040860152015416614305565b90805160021015610e3957606001526109d8565b634e487b7160e01b5f52603260045260245ffd5b6040516332b2c03d60e11b81526001600160401b0383166004820152602490fd5b6040516388f9834f60e01b81526001600160401b0383166004820152602490fd5b60405163277e73b360e11b81526001600160401b0383166004820152602490fd5b503461012b57604036600319011261012b576001600160a01b036040610ed4613275565b926001600160401b03610ee5613606565b94168152600d6020522091165f52602052602060ff60405f2054166040519015158152f35b503461012b578060031936011261012b5760206001600160401b03600a5416604051908152f35b503461012b578060031936011261012b57602060405160048152f35b503461012b57602036600319011261012b5760a09060406001600160401b039182610f76613275565b16815260106020522063ffffffff81549160046003820154910154906001600160a01b0360ff8360201c1694604051968116875260401c1660208601526040850152166060830152610fc781613437565b6080820152f35b503461012b57602036600319011261012b576020610ff2610fed613275565b613c29565b604051908152f35b503461012b57604036600319011261012b57611014613275565b6001600160401b03168152600c602052604081208054602435929083101561012b5760206110428484613670565b5054604051908152f35b503461012b57604036600319011261012b57611066613275565b906024359163ffffffff8316830361054b576001600160401b03600f54166001600160401b0382161015611b40576001600160401b038116825260106020526001600160a01b03604083205460401c163303611b1e576001600160401b0381168252601060205260408220600481015490600160ff8360201c166110e981613437565b14611afd576001600160401b038154168452600b6020526040842094600c6020526040852090809363ffffffff8354169163ffffffff808316840311611ae95763ffffffff1663ffffffff80831684031610611ad8575b50505f929360206001600160a01b035f8051602061435c8339815191525416604460405180978193631ce2e8d760e31b8352600160048401528160248401525af1938415611505575f94611aa4575b50929363ffffffff600484015416915b63ffffffff6111b48382600488015416613bba565b1663ffffffff84161015611941576111cc8382613670565b50948792875b60018701548510156112bf5760208a611252926111fc6111f58960018d01613c14565b508c613cd8565b5f8051602061435c83398151915254604051630ccd46b160e31b8152600481019290925260248201929092526001600160f81b0319831660448201529384926001600160a01b0390921691839182906064820190565b03925af19081156106f9578a9161128d575b509360018101811161127957600101936111d2565b634e487b7160e01b8a52601160045260248afd5b90506020813d6020116112b7575b816112a86020938361335d565b8101031261054b57515f611264565b3d915061129b565b969597909193509891986112e060038901546112da89613f00565b90613f56565b600389015560ff600284015460401c166112f981613437565b61154f576001600160401b038854168952600b6020526040892099895b63ffffffff60028d015460201c1663ffffffff82161161153257875461134163ffffffff8316614305565b8115611522575b8015611510575b60209060646001600160a01b035f8051602061435c8339815191525416935f6040519586948593630d7c62eb60e31b8552600485015260248401528160448401525af1908115611505578c918b915f916114cc575b505f8051602061435c83398151915254604051630ccd46b160e31b8152600481019390935260248301919091526001600160f81b031983166044830152909160209183916064918391906001600160a01b03165af19081156114c1578b9183918e91611487575b5061145691600261143961142161144094613f00565b61142d84848901613c14565b90549060031b1c613f56565b9401613c14565b819391549060031b91821b915f19901b19161790565b905563ffffffff808216146114735763ffffffff16600101611316565b634e487b7160e01b8b52601160045260248bfd5b925050506020813d6020116114b9575b816114a46020938361335d565b8101031261054b57518a90829061145661140b565b3d9150611497565b6040513d8e823e3d90fd5b925050506020813d6020116114fd575b816114e96020938361335d565b8101031261054b57518b908a9060206113a4565b3d91506114dc565b6040513d5f823e3d90fd5b50602061151b6142b4565b905061134f565b905061152c6142b4565b90611348565b5094919795509550611545919850613ba5565b919490939461119f565b959198939096946115cf60208a61156860028a01613bd2565b90549060031b1c84548115611931575b8015611923575b826001600160a01b035f8051602061435c83398151915254169260405196879586948593632a1f7ab160e21b8552600485019192604091949360608401958452602084015260ff60f81b16910152565b03925af19081156106f9578a916118f1575b5060206115f060028901613bd2565b90549060031b1c60646001600160a01b035f8051602061435c8339815191525416938d604051958694859363cb3b940760e01b85528b6004860152602485015260448401525af19081156106f9578a916118bf575b5061165561144060028901613bd2565b905561167461166660028801613be4565b905483549160031b1c613f56565b602061168260028901613be4565b90549060031b1c60646001600160a01b035f8051602061435c8339815191525416938d604051958694859363cb3b940760e01b85528b6004860152602485015260448401525af19081156106f957908a92918391611887575b5091602091611768936116f361144060028c01613be4565b905561170160028a01613bfc565b90549060031b1c90548115611877575b8015611869575b826001600160a01b035f8051602061435c8339815191525416926040519687958694859363a86e9de560e01b8552600485019192604091949360608401958452602084015260ff60f81b16910152565b03925af1801561185e57899061182b575b60209150606461178b60028901613bfc565b90549060031b1c948b6001600160a01b035f8051602061435c8339815191525416604051978895869463cb3b940760e01b86526004860152602485015260448401525af180156107795788906117f7575b61154592506117f061144060028801613bfc565b9055613ba5565b506020823d602011611823575b816118116020938361335d565b8101031261054b5761154591516117dc565b3d9150611804565b506020813d602011611856575b816118456020938361335d565b8101031261054b5760209051611779565b3d9150611838565b6040513d8b823e3d90fd5b506118726142b4565b611718565b90506118816142b4565b90611711565b9250506020823d6020116118b7575b816118a36020938361335d565b8101031261054b57905189919060206116db565b3d9150611896565b90506020813d6020116118e9575b816118da6020938361335d565b8101031261054b57515f611645565b3d91506118cd565b90506020813d60201161191b575b8161190c6020938361335d565b8101031261054b57515f6115e1565b3d91506118ff565b5061192c6142b4565b61157f565b905061193b6142b4565b90611578565b8385889363ffffffff61195b600485015492828416613bba565b169063ffffffff19161760048301556119796003830154309061423a565b61199560038301546001600160a01b03845460401c169061423a565b835b60028301548110156119f357806119c36119b660019360028701613c14565b3091549060031b1c61423a565b6119ed6119d38260028701613c14565b9054865460401c6001600160a01b03169160031b1c61423a565b01611997565b506004820154925490929063ffffffff8216818103611a5b5750509160209160046401000000007f4ceed57a97e26038270b156f5920479e6f3e9c4f1baa29470699b228d11657ac9564ff000000001916179101556001600160401b0360405191168152a180f35b606093507ffd463f5f8ea810259e60a8d43e0d3ea145fcac45521e164bd65dc6b9a4d8d563949250906001600160401b039182604051941684526020840152166040820152a180f35b9093506020813d602011611ad0575b81611ac06020938361335d565b8101031261054b5751925f61118f565b3d9150611ab3565b63ffffffff16900392505f80611140565b634e487b7160e01b88526011600452602488fd5b60405163cd74a76b60e01b81526001600160401b0384166004820152602490fd5b604051634959d18760e01b81526001600160401b039091166004820152602490fd5b60405163e5267a5f60e01b81526001600160401b039091166004820152602490fd5b503461012b57602080600319360112611ca557611b7d613275565b918060408051611b8c81613342565b60608152828582015201526001600160401b0380600f5416931692831015611c8c57828152601082526001600160a01b03604082205460401c163303611c7357808360409252601083522090600482015490600160ff83831c16611bef81613437565b03611c5a5760609350600383015491611c4863ffffffff92611c1f600260405197611c1989613342565b01613b57565b86528086019485528360408701931683526040519687968288525191870152608086019061363d565b92516040850152511660608301520390f35b604051631161704360e11b815260048101859052602490fd5b604051634959d18760e01b815260048101849052602490fd5b60405163e5267a5f60e01b815260048101849052602490fd5b5080fd5b503461012b57602036600319011261012b576001600160401b03611ccb613275565b8260c0604051611cda81613327565b828152826020820152606060408201526060808201528260808201528260a082015201521681526010602052604081209060405191611d1883613327565b6001600160a01b0381546001600160401b038116855260401c16602084015260018101805490611d4782613420565b91611d55604051938461335d565b808352602083019185526020852085925b828410611ebe57878760ff600489896040860152611d8660028201613b57565b606086015260038101546080860152015463ffffffff811660a0850152611db1828260201c16613437565b60201c1660c08301526040519182916020835261010083016001600160401b0383511660208501526001600160a01b03602084015116604085015260408301519160e06060860152825180925260206101208601930191815b818310611e5f5750505050611e3160c0916060840151601f1986830301608087015261363d565b91608081015160a085015263ffffffff60a082015116828501520151611e5681613437565b60e08301520390f35b91939092809596505160ff815116825260208101516004811015611eaa578263ffffffff60406020946060948660019801520151166040820152019501930190918695949392611e0a565b634e487b7160e01b84526021600452602484fd5b604097969751611ecd81613342565b825460ff80821683528160081c166004811015611f1057928263ffffffff602093600196858897015260101c166040820152815201920193019290969596611d66565b634e487b7160e01b8b52602160045260248bfd5b503461012b57602080600319360112611ca557611f3f613275565b9060405191611f4d836132d6565b8360a060405194611f5d8661330c565b6060958681528686820152836040820152838782015283608082015281528585820152826040820152828682015282608082015201526001600160401b0380600a5416911690811015612119578352600b8152604083209260405192611fc2846132d6565b611fcb85613455565b84526003946003810195865490611fe182613420565b97611fef604051998a61335d565b8289528552858520859087808b015b8584106120fb57508901998a525050505060048101546040860190815260058201548387019081526006909201549260808701929160ff8516612040816135e6565b845263ffffffff958660a08a019660081c16865261206f60405199898b525160c08a8c015260e08b019061353c565b995197601f1990818b8d030160408c0152895191828d528c8280808301928660051b01019c0194915b8483106120cd575050505050508798505190870152516080860152516120bd816135e6565b60a0850152511660c08301520390f35b90919293949b848f6120eb8f9360019486859483030188525161353c565b9e01930193019194939290612098565b600191859161210985613455565b8152019201920191908890611ffe565b6024906040519063277e73b360e11b82526004820152fd5b503461012b576020908160031936011261012b5761214d613275565b916001600160401b0380600f5416931692831015611c8c57828252601081526001600160a01b0380604084205460401c16330361224757838352601082523390604084205460401c1603611c735782825260108152604082209282845560018085018054905f815581612224575b5050600285018054905f815581612208575b505050826004855f60037f6447dad21daa2a79315bced174e6f1b1dd3555cfcfdc7bd7fa34191f64795e80979801550155604051908152a180f35b5f52835f20908101905b818110156121cd575f81558201612212565b5f5281845f20918201915b82811061223c57506121bb565b5f815501829061222f565b604051634959d18760e01b815260048101859052602490fd5b503461012b57604036600319011261012b5761227a6135f0565b6001600160a01b031681526011602052604081208054602435929083101561012b5760206001600160401b036122b0858561361c565b9190546040519260031b1c168152f35b503461012b57604036600319011261012b576004359060248035801590811503610832576001600160a01b0391827f93ab6e17f2c461cce6ea5d4ec117e51dda77a64affc2b2c05f8cd440def0e700541633036125b15784845260209160088352604085209560405180858954918281520198885285882090885b81811061259d57505050612355816123659899038261335d565b6001600160401b03968791613967565b511694818852600785526040882060405190818782549182815201918b52878b20908b5b898282106125875750505050906123a5816123aa93038261335d565b613967565b511691612554578652600483526123c360408720613b57565b908151945f1995868101908111612541576123dd90613ae5565b9460015b8451811015612427576123f48186613974565b51888201828111612414579061240d600193928a613974565b52016123e1565b634e487b7160e01b8c526011600452878cfd5b508786866124358c97613967565b5160405190612443826132f1565b8152848101928352858852600c855260408820805490600160401b82101561252e579061247591600182018155613670565b91909161251b57906001915181550191519081519384116125095750839061249d8484613b17565b01908652828620865b8381106124f75750505050818452600e81526040842090835f525260405f20600160ff198254161790557fb0674b169738a11731fb64a0088f28388c55ee0e0e0fdab53943bc2335c7f3848380a380f35b825182820155918401916001016124a6565b634e487b7160e01b8852604160045287fd5b634e487b7160e01b895260048990528289fd5b634e487b7160e01b8a526041600452838afd5b634e487b7160e01b895260116004528489fd5b50604051630f1bb9e760e41b81526001600160401b03851660048201526001600160a01b03919091166024820152604490fd5b8354871685529093019260019283019201612389565b82548b52998701996001928301920161233b565b8380fd5b503461012b578060031936011261012b5760206001600160401b03600f5416604051908152f35b503461012b57604036600319011261012b576001600160a01b036040612600613275565b926001600160401b03612611613606565b94168152600e6020522091165f52602052602060ff60405f2054166040519015158152f35b503461012b57604036600319011261012b576126506135f0565b6001600160401b039190602435838116810361054b5761266f91613988565b604051916020808401906020855283518092526020604086019401925b8281106126995785850386f35b835187168552938101939281019260010161268c565b503461012b57602036600319011261012b576126c9613275565b6001600160401b0380600a541691169081101561211957808252600d60205260408220335f5260205260ff60405f2054161561275c57808252600b602052600660408320018054600260ff821661271f816135e6565b03612728578380f35b60ff191660021790557f14883c8b2ec2887f4d5131ced01a22713b9040addbfd70ef20b904821671f1d48280a25f80808380f35b602490604051906388f9834f60e01b82526004820152fd5b503461012b57602036600319011261012b5760406127de916001600160401b0361279c613275565b168152600b602052206127ae81613455565b9063ffffffff600482015491600660058201549101549060ff82169060405196879660a0885260a088019061353c565b94602087015260408601526127f2816135e6565b606085015260081c1660808301520390f35b90503461054b5760031960a03682011261054b57600435906001600160401b03821161054b5760a09082600401923603011261054b576024356001600160401b03811161054b57612859903690600401613234565b6084939193359163ffffffff8316830361054b57600482116131f1575060643560443510156131855761288c36846136ec565b730Ea37D3264b940C94D68DA1EB34C291D62Ba8Ab590813b1561054b576040515f81806128c763b4d54fdb60e01b95868352600483016137e6565b0381865af4801561150557613172575b5086805b8481106130f557505050506001600160401b03600a54169361290a60405194612903866132d6565b36906136ec565b845261291582613420565b91612923604051938461335d565b80835260051b8101602083013682116130f15782905b8282106130c157505050509063ffffffff916020840152604435604084015260643560608401528460808401521660a0820152818352600d60205260408320335f5260205260405f20600160ff19825416179055818352600b60205260408320815180518051906001600160401b0382116130ad576129b8845461328b565b601f811161307d575b50602090601f8311600114613015576129f19291889183612cdd575b50508160011b915f199060031b1c19161790565b82555b600182016020820151906020825192612a0d84846138f4565b019087526020872087915b838310612f0c5750505050600282019063ffffffff6040820151169082549168ff0000000000000000608067ffffffff00000000606085015160201b16930151612a6181613437565b612a6a81613437565b60401b169268ffffffffffffffffff191617171790556020820151805190600160401b8211612ef8576003830154826003850155808310612e4f575b50602001906003830186526020862086925b828410612b75575050505060069060408301516004820155606083015160058201550190608081015190612aeb826135e6565b612af4826135e6565b60ff64ffffffff0060a0855493015160081b1692169064ffffffffff191617179055600a546001600160401b03612b2c81831661393b565b16906001600160401b03191617600a55604051604435815260643560208201527f49db07058829aa7f58f443df35f9612682dc944257eb8d87915f0017424243f360403392a380f35b805180518051906001600160401b038211612e3b57612b94855461328b565b601f8111612e0b575b50602090601f8311600114612da357612bcc92918c9183612cdd5750508160011b915f199060031b1c19161790565b83555b600183016020820151906020825192612be884846138f4565b01908b5260208b20908b905b838210612c6f57505050506020600192600392600286019063ffffffff6040820151169082549168ff0000000000000000608067ffffffff000000006060850151891b16930151612c4481613437565b612c4d81613437565b60401b169268ffffffffffffffffff1916171717905501920193019290612ab8565b80518051906001600160401b038211612d8f578e90612c8e865461328b565b601f8111612d54575b50602091601f8411600114612ce8578360019592946020948796612cce9492612cdd5750508160011b915f199060031b1c19161790565b86555b01930191019091612bf4565b015190505f806129dd565b919086835260208320925b601f1985168110612d3c575083602093600196938796938794601f19811610612d24575b505050811b018655612cd1565b01515f1960f88460031b161c191690555f8080612d17565b91926020600181928685015181550194019201612cf3565b612d7f9087845260208420601f860160051c81019160208710612d85575b601f0160051c0190613896565b5f612c97565b9091508190612d72565b634e487b7160e01b8f52604160045260248ffd5b9190858c5260208c20908c935b601f1984168510612df0576001945083601f19811610612dd8575b505050811b018355612bcf565b01515f1960f88460031b161c191690555f8080612dcb565b81810151835560209485019460019093019290910190612db0565b612e3590868d5260208d20601f850160051c81019160208610612d8557601f0160051c0190613896565b5f612b9d565b634e487b7160e01b8b52604160045260248bfd5b6003818102048103612ee4576003838102048303612ee457600384018752602087208360030281015b8260030282018110612e8b575050612aa6565b612e94816138ac565b60018101545f600183015580612eb5575b5080896002600393015501612e78565b600182015f5260205f2090815b8183018110612ed2575050612ea5565b80612ede6001926138ac565b01612ec2565b634e487b7160e01b87526011600452602487fd5b634e487b7160e01b86526041600452602486fd5b80518051906001600160401b038211612e3b57612f29845461328b565b601f8111612fe5575b506020908b601f8411600114612f79578360019592946020948796612f6a9492612cdd5750508160011b915f199060031b1c19161790565b85555b01920192019190612a18565b85905260208c2091908c5b601f1985168110612fcd575083602093600196938796938794601f19811610612fb5575b505050811b018555612f6d565b01515f1960f88460031b161c191690555f8080612fa8565b91926020600181928685015181550194019201612f84565b61300f90858d5260208d20601f850160051c81019160208610612d8557601f0160051c0190613896565b5f612f32565b9190848852602088209088935b601f1984168510613062576001945083601f1981161061304a575b505050811b0182556129f4565b01515f1960f88460031b161c191690555f808061303d565b81810151835560209485019460019093019290910190613022565b6130a79085895260208920601f850160051c81019160208610612d8557601f0160051c0190613896565b5f6129c1565b634e487b7160e01b87526041600452602487fd5b81356001600160401b0381116130ed576020916130e28392369088016136ec565b815201910190612939565b8980fd5b8780fd5b8060051b880135609e1989360301811215610832576131179036908a016136ec565b843b1561083257826131369160405180938192888352600483016137e6565b0381885af4908115613167578391613153575b50506001016128db565b61315c906132c3565b611ca557815f613149565b6040513d85823e3d90fd5b61317d9197506132c3565b5f955f6128d7565b604051632c3efebd60e01b815260206004820152602760248201527f53746172742074696d652073686f756c64206265206c657373207468616e206560448201527f6e642074696d65000000000000000000000000000000000000000000000000006064820152608490fd5b632c3efebd60e01b815260206004820152601960248201527f6d6178206d657461206f7074696f6e73206578636565646564000000000000006044820152606490fd5b9181601f8401121561054b578235916001600160401b03831161054b576020808501948460051b01011161054b57565b359063ffffffff8216820361054b57565b600435906001600160401b038216820361054b57565b90600182811c921680156132b9575b60208310146132a557565b634e487b7160e01b5f52602260045260245ffd5b91607f169161329a565b6001600160401b038111610d4457604052565b60c081019081106001600160401b03821117610d4457604052565b604081019081106001600160401b03821117610d4457604052565b60a081019081106001600160401b03821117610d4457604052565b60e081019081106001600160401b03821117610d4457604052565b606081019081106001600160401b03821117610d4457604052565b90601f801991011681019081106001600160401b03821117610d4457604052565b9060405191825f82546133908161328b565b908184526020946001916001811690815f146133fe57506001146133c0575b5050506133be9250038361335d565b565b5f90815285812095935091905b8183106133e65750506133be93508201015f80806133af565b855488840185015294850194879450918301916133cd565b925050506133be94925060ff191682840152151560051b8201015f80806133af565b6001600160401b038111610d445760051b60200190565b6002111561344157565b634e487b7160e01b5f52602160045260245ffd5b906040516134628161330c565b809261346d8161337e565b8252600180820190815461348081613420565b9261348e604051948561335d565b8184525f90815260208082208186015b8484106134e357505050505050600260809260ff926020860152015463ffffffff80821660408601528160201c16606085015260401c16916134df83613437565b0152565b858381926134f08561337e565b81520192019301929061349e565b91908251928382525f5b848110613528575050825f602080949584010152601f8019910116010190565b602081830181015184830182015201613508565b90613550825160a0835260a08301906134fe565b916020928382015193838203818501528451908183528083019281808460051b8301019701935f915b8483106135b85750505050505060808160408293015163ffffffff809116604086015260608201511660608501520151916135b383613437565b015290565b90919293949784806135d6600193601f198682030187528c516134fe565b9a01930193019194939290613579565b6003111561344157565b600435906001600160a01b038216820361054b57565b602435906001600160a01b038216820361054b57565b9190918054831015610e39575f52601860205f208360021c019260031b1690565b9081518082526020808093019301915f5b82811061365c575050505090565b83518552938101939281019260010161364e565b8054821015610e39575f5260205f209060011b01905f90565b9291926001600160401b038211610d4457604051916136b2601f8201601f19166020018461335d565b82948184528183011161054b578281602093845f960137010152565b9080601f8301121561054b578160206136e993359101613689565b90565b91909160a08184031261054b57604051906137068261330c565b81938135906001600160401b039182811161054b57816137279185016136ce565b84526020908184013583811161054b57840181601f8201121561054b57803561374f81613420565b9461375d604051968761335d565b818652848087019260051b8401019380851161054b57858401925b8584106137c157505050505050906080929184015261379960408201613264565b60408401526137aa60608201613264565b6060840152013590600282101561054b5760800152565b833583811161054b5787916137db848480948a01016136ce565b815201930192613778565b602091828252613801815160a08585015260c08401906134fe565b928082015193601f19918285830301604086015285519182815281810182808560051b8401019801945f925b8584106138685750505050505050608081604060a093015163ffffffff8091166060860152606082015116828501520151916135b383613437565b909192939495988580613885838686600196030188528d516134fe565b9b019401940192959493919061382d565b8181106138a1575050565b5f8155600101613896565b6138b6815461328b565b90816138c0575050565b81601f5f93116001146138d1575055565b9080839182526138f0601f60208420940160051c840160018501613896565b5555565b90600160401b8111610d445781549181815582821061391257505050565b5f5260205f2091820191015b818110613929575050565b806139356001926138ac565b0161391e565b9060016001600160401b038093160191821161395357565b634e487b7160e01b5f52601160045260245ffd5b805115610e395760200190565b8051821015610e395760209160051b010190565b6001600160a01b03165f526011602091601160205260409260405f20935f945f938154945b858110613a8657506139be87613420565b966139cc604051988961335d565b808852601f196139db82613420565b013660208a013715613a7d575f935f5b8681106139fd57505050505050505090565b613a07818561361c565b6001600160401b03809254600392831b1c165f526010845281875f20541682861614613a38575b50506001016139eb565b613a45838799949961361c565b9054911b1c16613a55828b613974565b5260018101809111613a6a579460015f613a2e565b87634e487b7160e01b5f5260045260245ffd5b50505050505090565b613a90818461361c565b906001600160401b03918291549060031b1c165f526010865280855f20541690831614613ac0575b6001016139ad565b9660018101809111613ad25796613ab8565b86634e487b7160e01b5f5260045260245ffd5b90613aef82613420565b613afc604051918261335d565b8281528092613b0d601f1991613420565b0190602036910137565b90600160401b8111610d4457815491818155828210613b3557505050565b5f5260205f2091820191015b818110613b4c575050565b5f8155600101613b41565b90604051918281549182825260209260208301915f5260205f20935f905b828210613b8b575050506133be9250038361335d565b855484526001958601958895509381019390910190613b75565b90600163ffffffff8093160191821161395357565b91909163ffffffff8080941691160191821161395357565b805415610e39575f5260205f20905f90565b805460011015610e39575f52600160205f2001905f90565b805460021015610e39575f52600260205f2001905f90565b8054821015610e39575f5260205f2001905f90565b6001600160401b0380600a5416911690811015612119575f526020600c60205260409060405f20805491613c5c83613420565b93613c6a604051958661335d565b83855260208501925f5260205f20905f935b858510613c8d575050505050505190565b6002846001928451613c9e816132f1565b86548152613cad858801613b57565b83820152815201930194019391613c7c565b8054821015610e39575f52600360205f20910201905f90565b81549160ff92838160081c169060049182811015613e585715613e6b57508154848160081c1682811015613e5857600114613d945750815490848260081c169080821015613d815750600214613d555750546136e99263ffffffff92613d4391831690600101613c14565b9290549160101c169160031b1c61415e565b9050613d6f63ffffffff9260016136e99584169101613c14565b9290549160101c169160031b1c6140e6565b602190634e487b7160e01b5f525260245ffd5b93613daa91925092600160209486169101613c14565b90549060031b1c908115613e44575b6064905f6001600160a01b035f8051602061435c833981519152541663ffffffff6040519788968795631927108160e01b875286015260101c166024840152600160f81b60448401525af1908115611505575f91613e15575090565b90506020813d602011613e3c575b81613e306020938361335d565b8101031261054b575190565b3d9150613e23565b90506064613e506142b4565b919050613db9565b602183634e487b7160e01b5f525260245ffd5b93613e8191925092600160209486169101613c14565b90549060031b1c908115613eec575b6064905f6001600160a01b035f8051602061435c833981519152541663ffffffff6040519788968795630d7c62eb60e31b875286015260101c166024840152600160f81b60448401525af1908115611505575f91613e15575090565b90506064613ef86142b4565b919050613e90565b5f8051602061435c8339815191525460405163025f346960e51b81526004810192909252600160fa1b6024830152602090829060449082905f906001600160a01b03165af1908115611505575f91613e15575090565b908115613fcb575b8015613fb9575b60209060646001600160a01b035f8051602061435c8339815191525416935f604051958694859363f953e42760e01b8552600485015260248401528160448401525af1908115611505575f91613e15575090565b506020613fc46142b4565b9050613f65565b9050613fd56142b4565b90613f5e565b602061402c926001600160a01b0392835f8051602061435c8339815191525416905f6040518097819582946302e817ff60e41b845260048401523360248401526080604484015260848301906134fe565b600160fa1b606483015203925af1918215611505575f926140b2575b507fed8d60e34876f751cc8b014c560745351147d9de11b9347c854e881b128ea6005416803b1561054b576040516346ce4e4960e11b815260048101839052336024820152905f908290604490829084905af18015611505576140a9575090565b6136e9906132c3565b9091506020813d6020116140de575b816140ce6020938361335d565b8101031261054b5751905f614048565b3d91506140c1565b63ffffffff91602091801561414c575b6064905f6001600160a01b035f8051602061435c8339815191525416604051968795869463052896f160e01b86526004860152166024840152600160f81b60448401525af1908115611505575f91613e15575090565b5060646141576142b4565b90506140f6565b63ffffffff9160209180156141c4575b6064905f6001600160a01b035f8051602061435c833981519152541660405196879586946334a6d7b960e11b86526004860152166024840152600160f81b60448401525af1908115611505575f91613e15575090565b5060646141cf6142b4565b905061416e565b9081518082526020808093019301915f5b8281106141f5575050505090565b8351855293810193928101926001016141e7565b5f52600460205260405f20805490600160401b821015610d44578161144091600161423694018155613c14565b9055565b6001600160a01b037fed8d60e34876f751cc8b014c560745351147d9de11b9347c854e881b128ea600541691823b1561054b57604051631974142760e21b815260048101929092526001600160a01b03166024820152905f908290604490829084905af18015611505576142ab5750565b6133be906132c3565b5f60206001600160a01b035f8051602061435c8339815191525416604460405180948193631ce2e8d760e31b8352816004840152600160fa1b60248401525af1908115611505575f91613e15575090565b5f8051602061435c83398151915254604051631ce2e8d760e31b81526004810192909252600160fa1b6024830152602090829060449082905f906001600160a01b03165af1908115611505575f91613e1557509056feed8d60e34876f751cc8b014c560745351147d9de11b9347c854e881b128ea601a164736f6c6343000818000a",
  "deployedBytecode": "0x6080806040526004361015610012575f80fd5b5f905f3560e01c9081630d79e8ec1461280457508063336f3dbc146127745780633c5e7587146126af5780633d14f4c9146126365780635c556160146125dc5780635d4f28bc146125b557806362c2a450146122c05780636fa78d39146122605780638a0d72021461213157806398829d3314611f24578063a667533f14611ca9578063b9e073d114611b62578063c82c77b11461104c578063c9f68c4714610ffa578063d67758ba14610fce578063e50752eb14610f4d578063e62d604a14610f31578063eb264b9c14610f0a578063f4f8a4a214610eb0578063f601440614610836578063f665c3a21461012e5763f9e46a1414610110575f80fd5b3461012b578060031936011261012b57602060405160038152f35b80fd5b503461012b57608036600319011261012b57610148613275565b6001600160401b0391906044358381116108325761016a903690600401613234565b90936064359281841161082e573660238501121561082e578184600401351161082e5736602485600401358601011161082e5781600a54168282161015610815578181168552600b60205260408520600260ff6006830154166101cc816135e6565b146107fb57600581015442116107fb576004015442106107e3578181168552600e60205260408520335f5260205260ff60405f2054166107ba578181168552600b602052604085209260038401548082036107965750600684015461023360ff82166135e6565b600160ff821603610784575b5061025d61025536876004013560248901613689565b602435613fdb565b93610268308661423a565b6102e26020886002840161029263ffffffff610287818454168c6140e6565b9254851c168a61415e565b826001600160a01b035f8051602061435c83398151915254169260405196879586948593630ccd46b160e31b8552600485019192604091949360608401958452602084015260ff60f81b16910152565b03925af1908115610779578891610747575b509795919061030282613ae5565b9688935b83851061059d5750505050506040519561031f876132f1565b600187526020368189013761033387613967565b526064420195864211610589576001600160a01b037fed8d60e34876f751cc8b014c560745351147d9de11b9347c854e881b128ea6005416803b156105855786604051809263155f840160e21b82526020600483015281838161039960248201896141d6565b03925af1801561057a57908791610562575b50506104046020916001600160a01b037f93ab6e17f2c461cce6ea5d4ec117e51dda77a64affc2b2c05f8cd440def0e70054169088604051809b81958294634c0d927760e01b845260a0600485015260a48401906141d6565b9063062c2a4560e41b6024840152836044840152606483015282608483015203925af195861561055757859661051f575b50858552600860205260408520918254600160401b938482101561050b57816104679160016104809594018155613c14565b919093169083549060031b91821b915f19901b19161790565b90558484526007602052604084208054918210156104f757816104ac9160016104cb9594018155613c14565b81549060031b906001600160a01b0333831b921b191617905584614209565b815b81518110156104f357806104ed6104e660019385613974565b5186614209565b016104cd565b8280f35b634e487b7160e01b85526041600452602485fd5b634e487b7160e01b88526041600452602488fd5b9095506020813d60201161054f575b8161053b6020938361335d565b8101031261054b5751945f610435565b5f80fd5b3d915061052e565b6040513d87823e3d90fd5b61056b906132c3565b61057657855f6103ab565b8580fd5b6040513d89823e3d90fd5b8680fd5b634e487b7160e01b86526011600452602486fd5b909192939961063f60208b8b6102928f63ffffffff600261063383600361061b8f968f8f8888610623858f61061b8f968b926105f761062d9a6105eb87943690602481600401359101613689565b908460051b0135613fdb565b6106018383613974565b52610616306106108484613974565b5161423a565b613974565b519501613cbf565b50015416906140e6565b99613974565b500154861c169061415e565b03925af190811561073c57908b92918391610704575b505f8051602061435c83398151915254604051630ccd46b160e31b8152600481019390935260248301919091526001600160f81b031983166044830152909160209183916064918391906001600160a01b03165af180156106f9578a906106c6575b600191509a0193929190610306565b506020813d6020116106f1575b816106e06020938361335d565b8101031261054b57600190516106b7565b3d91506106d3565b6040513d8c823e3d90fd5b9250506020823d602011610734575b816107206020938361335d565b8101031261054b5790518a91906020610655565b3d9150610713565b6040513d8d823e3d90fd5b90506020813d602011610771575b816107626020938361335d565b8101031261054b57515f6102f4565b3d9150610755565b6040513d8a823e3d90fd5b60ff191660011760068501555f61023f565b90606493604051936375bf0e8360e01b855216600484015260248301526044820152fd5b604051632728f33d60e11b81526001600160401b03919091166004820152336024820152604490fd5b60405162c0df1b60e21b815291166004820152602490fd5b50604051635c6d3af360e01b815291166004820152602490fd5b60405163277e73b360e11b815291166004820152602490fd5b8480fd5b8280fd5b503461012b57604036600319011261012b57610850613275565b906001600160401b036024351161012b5736602360243501121561012b576001600160401b03602435600401351161012b57366024606081356004013502813501011161012b576001600160401b03600a54166001600160401b0383161015610e8f576001600160401b0382168152600d60205260408120335f5260205260ff60405f20541615610e6e576001600160401b0382168152600b6020526040812063ffffffff600661090085613c29565b92015460081c1611610e4d576001600160401b03600f5416906001600160401b0383168152600b602052604081206109366142b4565b90600281015460ff8160401c1661094c81613437565b610db55750600263ffffffff91015460201c169261097763ffffffff61097186613ba5565b16613ae5565b90835b856001600160401b038216116109d4578361099e6001600160401b03831685613974565b526001600160401b03808216146109c0576001600160401b031660010161097a565b634e487b7160e01b85526011600452602485fd5b5093505b6001600160401b03604051956109ed87613327565b168552336020860152610a0560243560040135613420565b610a12604051918261335d565b602480356004810135835201602082015b6024606081356004013502813501018210610d585750506040860152606085015260808401528060a08401528060c08401528181526010602052604081206001600160401b038451168154907bffffffffffffffffffffffffffffffffffffffff0000000000000000602087015160401b169163ffffffff60e01b16171781556040840151805190600160401b8211610d44576001830154826001850155808310610d1a575b5060200190600183018452602084209184905b828210610cb0575050505060608401518051906001600160401b038211610c9c57602090610b0d8360028601613b17565b0160028301845260208420845b838110610c885750505050600490608085015160038201550163ffffffff60a08501511681549064ff0000000060c0870151610b5581613437565b610b5e81613437565b60201b169164ffffffffff191617179055600f546001600160401b03610b8581831661393b565b16906001600160401b03191617600f55338152601160205260408120805490600160401b821015610c745790610bc09160018201815561361c565b81549060031b906001600160401b0385831b921b19161790555b60608301518051821015610c125790610bfa600192610610833092613974565b610c0c33610610836060880151613974565b01610bda565b602083610c3286610c2730608083015161423a565b60803391015161423a565b604080516001600160401b03831681523360208201527fc151e2ad5f7ea91d34238328a2fcfd1328147d1625b5b491a917ce06a7ca4cdc9190a1604051908152f35b634e487b7160e01b83526041600452602483fd5b600190602084519401938184015501610b1a565b634e487b7160e01b84526041600452602484fd5b805160ff815116908554916020820151916004831015610d06579260209261ff006001969365ffffffff000060408998015160101b169365ffffffffffff1916179160081b161717875501940191019092610adc565b634e487b7160e01b8a52602160045260248afd5b600184015f5260205f20908382015b8183018110610d39575050610ac9565b5f8155600101610d29565b634e487b7160e01b5f52604160045260245ffd5b60608236031261057657604051610d6e81613342565b60ff8335168335036105855782358152600460208401351015610585576060916020918285013583820152610da560408601613264565b6040820152815201910190610a23565b90604051908160808101106001600160401b03608084011117610d445760808201604052600382526060366020840137610df863ffffffff839460201c16614305565b610e0183613967565b52815160011015610e395763ffffffff6002610e2592866040860152015416614305565b90805160021015610e3957606001526109d8565b634e487b7160e01b5f52603260045260245ffd5b6040516332b2c03d60e11b81526001600160401b0383166004820152602490fd5b6040516388f9834f60e01b81526001600160401b0383166004820152602490fd5b60405163277e73b360e11b81526001600160401b0383166004820152602490fd5b503461012b57604036600319011261012b576001600160a01b036040610ed4613275565b926001600160401b03610ee5613606565b94168152600d6020522091165f52602052602060ff60405f2054166040519015158152f35b503461012b578060031936011261012b5760206001600160401b03600a5416604051908152f35b503461012b578060031936011261012b57602060405160048152f35b503461012b57602036600319011261012b5760a09060406001600160401b039182610f76613275565b16815260106020522063ffffffff81549160046003820154910154906001600160a01b0360ff8360201c1694604051968116875260401c1660208601526040850152166060830152610fc781613437565b6080820152f35b503461012b57602036600319011261012b576020610ff2610fed613275565b613c29565b604051908152f35b503461012b57604036600319011261012b57611014613275565b6001600160401b03168152600c602052604081208054602435929083101561012b5760206110428484613670565b5054604051908152f35b503461012b57604036600319011261012b57611066613275565b906024359163ffffffff8316830361054b576001600160401b03600f54166001600160401b0382161015611b40576001600160401b038116825260106020526001600160a01b03604083205460401c163303611b1e576001600160401b0381168252601060205260408220600481015490600160ff8360201c166110e981613437565b14611afd576001600160401b038154168452600b6020526040842094600c6020526040852090809363ffffffff8354169163ffffffff808316840311611ae95763ffffffff1663ffffffff80831684031610611ad8575b50505f929360206001600160a01b035f8051602061435c8339815191525416604460405180978193631ce2e8d760e31b8352600160048401528160248401525af1938415611505575f94611aa4575b50929363ffffffff600484015416915b63ffffffff6111b48382600488015416613bba565b1663ffffffff84161015611941576111cc8382613670565b50948792875b60018701548510156112bf5760208a611252926111fc6111f58960018d01613c14565b508c613cd8565b5f8051602061435c83398151915254604051630ccd46b160e31b8152600481019290925260248201929092526001600160f81b0319831660448201529384926001600160a01b0390921691839182906064820190565b03925af19081156106f9578a9161128d575b509360018101811161127957600101936111d2565b634e487b7160e01b8a52601160045260248afd5b90506020813d6020116112b7575b816112a86020938361335d565b8101031261054b57515f611264565b3d915061129b565b969597909193509891986112e060038901546112da89613f00565b90613f56565b600389015560ff600284015460401c166112f981613437565b61154f576001600160401b038854168952600b6020526040892099895b63ffffffff60028d015460201c1663ffffffff82161161153257875461134163ffffffff8316614305565b8115611522575b8015611510575b60209060646001600160a01b035f8051602061435c8339815191525416935f6040519586948593630d7c62eb60e31b8552600485015260248401528160448401525af1908115611505578c918b915f916114cc575b505f8051602061435c83398151915254604051630ccd46b160e31b8152600481019390935260248301919091526001600160f81b031983166044830152909160209183916064918391906001600160a01b03165af19081156114c1578b9183918e91611487575b5061145691600261143961142161144094613f00565b61142d84848901613c14565b90549060031b1c613f56565b9401613c14565b819391549060031b91821b915f19901b19161790565b905563ffffffff808216146114735763ffffffff16600101611316565b634e487b7160e01b8b52601160045260248bfd5b925050506020813d6020116114b9575b816114a46020938361335d565b8101031261054b57518a90829061145661140b565b3d9150611497565b6040513d8e823e3d90fd5b925050506020813d6020116114fd575b816114e96020938361335d565b8101031261054b57518b908a9060206113a4565b3d91506114dc565b6040513d5f823e3d90fd5b50602061151b6142b4565b905061134f565b905061152c6142b4565b90611348565b5094919795509550611545919850613ba5565b919490939461119f565b959198939096946115cf60208a61156860028a01613bd2565b90549060031b1c84548115611931575b8015611923575b826001600160a01b035f8051602061435c83398151915254169260405196879586948593632a1f7ab160e21b8552600485019192604091949360608401958452602084015260ff60f81b16910152565b03925af19081156106f9578a916118f1575b5060206115f060028901613bd2565b90549060031b1c60646001600160a01b035f8051602061435c8339815191525416938d604051958694859363cb3b940760e01b85528b6004860152602485015260448401525af19081156106f9578a916118bf575b5061165561144060028901613bd2565b905561167461166660028801613be4565b905483549160031b1c613f56565b602061168260028901613be4565b90549060031b1c60646001600160a01b035f8051602061435c8339815191525416938d604051958694859363cb3b940760e01b85528b6004860152602485015260448401525af19081156106f957908a92918391611887575b5091602091611768936116f361144060028c01613be4565b905561170160028a01613bfc565b90549060031b1c90548115611877575b8015611869575b826001600160a01b035f8051602061435c8339815191525416926040519687958694859363a86e9de560e01b8552600485019192604091949360608401958452602084015260ff60f81b16910152565b03925af1801561185e57899061182b575b60209150606461178b60028901613bfc565b90549060031b1c948b6001600160a01b035f8051602061435c8339815191525416604051978895869463cb3b940760e01b86526004860152602485015260448401525af180156107795788906117f7575b61154592506117f061144060028801613bfc565b9055613ba5565b506020823d602011611823575b816118116020938361335d565b8101031261054b5761154591516117dc565b3d9150611804565b506020813d602011611856575b816118456020938361335d565b8101031261054b5760209051611779565b3d9150611838565b6040513d8b823e3d90fd5b506118726142b4565b611718565b90506118816142b4565b90611711565b9250506020823d6020116118b7575b816118a36020938361335d565b8101031261054b57905189919060206116db565b3d9150611896565b90506020813d6020116118e9575b816118da6020938361335d565b8101031261054b57515f611645565b3d91506118cd565b90506020813d60201161191b575b8161190c6020938361335d565b8101031261054b57515f6115e1565b3d91506118ff565b5061192c6142b4565b61157f565b905061193b6142b4565b90611578565b8385889363ffffffff61195b600485015492828416613bba565b169063ffffffff19161760048301556119796003830154309061423a565b61199560038301546001600160a01b03845460401c169061423a565b835b60028301548110156119f357806119c36119b660019360028701613c14565b3091549060031b1c61423a565b6119ed6119d38260028701613c14565b9054865460401c6001600160a01b03169160031b1c61423a565b01611997565b506004820154925490929063ffffffff8216818103611a5b5750509160209160046401000000007f4ceed57a97e26038270b156f5920479e6f3e9c4f1baa29470699b228d11657ac9564ff000000001916179101556001600160401b0360405191168152a180f35b606093507ffd463f5f8ea810259e60a8d43e0d3ea145fcac45521e164bd65dc6b9a4d8d563949250906001600160401b039182604051941684526020840152166040820152a180f35b9093506020813d602011611ad0575b81611ac06020938361335d565b8101031261054b5751925f61118f565b3d9150611ab3565b63ffffffff16900392505f80611140565b634e487b7160e01b88526011600452602488fd5b60405163cd74a76b60e01b81526001600160401b0384166004820152602490fd5b604051634959d18760e01b81526001600160401b039091166004820152602490fd5b60405163e5267a5f60e01b81526001600160401b039091166004820152602490fd5b503461012b57602080600319360112611ca557611b7d613275565b918060408051611b8c81613342565b60608152828582015201526001600160401b0380600f5416931692831015611c8c57828152601082526001600160a01b03604082205460401c163303611c7357808360409252601083522090600482015490600160ff83831c16611bef81613437565b03611c5a5760609350600383015491611c4863ffffffff92611c1f600260405197611c1989613342565b01613b57565b86528086019485528360408701931683526040519687968288525191870152608086019061363d565b92516040850152511660608301520390f35b604051631161704360e11b815260048101859052602490fd5b604051634959d18760e01b815260048101849052602490fd5b60405163e5267a5f60e01b815260048101849052602490fd5b5080fd5b503461012b57602036600319011261012b576001600160401b03611ccb613275565b8260c0604051611cda81613327565b828152826020820152606060408201526060808201528260808201528260a082015201521681526010602052604081209060405191611d1883613327565b6001600160a01b0381546001600160401b038116855260401c16602084015260018101805490611d4782613420565b91611d55604051938461335d565b808352602083019185526020852085925b828410611ebe57878760ff600489896040860152611d8660028201613b57565b606086015260038101546080860152015463ffffffff811660a0850152611db1828260201c16613437565b60201c1660c08301526040519182916020835261010083016001600160401b0383511660208501526001600160a01b03602084015116604085015260408301519160e06060860152825180925260206101208601930191815b818310611e5f5750505050611e3160c0916060840151601f1986830301608087015261363d565b91608081015160a085015263ffffffff60a082015116828501520151611e5681613437565b60e08301520390f35b91939092809596505160ff815116825260208101516004811015611eaa578263ffffffff60406020946060948660019801520151166040820152019501930190918695949392611e0a565b634e487b7160e01b84526021600452602484fd5b604097969751611ecd81613342565b825460ff80821683528160081c166004811015611f1057928263ffffffff602093600196858897015260101c166040820152815201920193019290969596611d66565b634e487b7160e01b8b52602160045260248bfd5b503461012b57602080600319360112611ca557611f3f613275565b9060405191611f4d836132d6565b8360a060405194611f5d8661330c565b6060958681528686820152836040820152838782015283608082015281528585820152826040820152828682015282608082015201526001600160401b0380600a5416911690811015612119578352600b8152604083209260405192611fc2846132d6565b611fcb85613455565b84526003946003810195865490611fe182613420565b97611fef604051998a61335d565b8289528552858520859087808b015b8584106120fb57508901998a525050505060048101546040860190815260058201548387019081526006909201549260808701929160ff8516612040816135e6565b845263ffffffff958660a08a019660081c16865261206f60405199898b525160c08a8c015260e08b019061353c565b995197601f1990818b8d030160408c0152895191828d528c8280808301928660051b01019c0194915b8483106120cd575050505050508798505190870152516080860152516120bd816135e6565b60a0850152511660c08301520390f35b90919293949b848f6120eb8f9360019486859483030188525161353c565b9e01930193019194939290612098565b600191859161210985613455565b8152019201920191908890611ffe565b6024906040519063277e73b360e11b82526004820152fd5b503461012b576020908160031936011261012b5761214d613275565b916001600160401b0380600f5416931692831015611c8c57828252601081526001600160a01b0380604084205460401c16330361224757838352601082523390604084205460401c1603611c735782825260108152604082209282845560018085018054905f815581612224575b5050600285018054905f815581612208575b505050826004855f60037f6447dad21daa2a79315bced174e6f1b1dd3555cfcfdc7bd7fa34191f64795e80979801550155604051908152a180f35b5f52835f20908101905b818110156121cd575f81558201612212565b5f5281845f20918201915b82811061223c57506121bb565b5f815501829061222f565b604051634959d18760e01b815260048101859052602490fd5b503461012b57604036600319011261012b5761227a6135f0565b6001600160a01b031681526011602052604081208054602435929083101561012b5760206001600160401b036122b0858561361c565b9190546040519260031b1c168152f35b503461012b57604036600319011261012b576004359060248035801590811503610832576001600160a01b0391827f93ab6e17f2c461cce6ea5d4ec117e51dda77a64affc2b2c05f8cd440def0e700541633036125b15784845260209160088352604085209560405180858954918281520198885285882090885b81811061259d57505050612355816123659899038261335d565b6001600160401b03968791613967565b511694818852600785526040882060405190818782549182815201918b52878b20908b5b898282106125875750505050906123a5816123aa93038261335d565b613967565b511691612554578652600483526123c360408720613b57565b908151945f1995868101908111612541576123dd90613ae5565b9460015b8451811015612427576123f48186613974565b51888201828111612414579061240d600193928a613974565b52016123e1565b634e487b7160e01b8c526011600452878cfd5b508786866124358c97613967565b5160405190612443826132f1565b8152848101928352858852600c855260408820805490600160401b82101561252e579061247591600182018155613670565b91909161251b57906001915181550191519081519384116125095750839061249d8484613b17565b01908652828620865b8381106124f75750505050818452600e81526040842090835f525260405f20600160ff198254161790557fb0674b169738a11731fb64a0088f28388c55ee0e0e0fdab53943bc2335c7f3848380a380f35b825182820155918401916001016124a6565b634e487b7160e01b8852604160045287fd5b634e487b7160e01b895260048990528289fd5b634e487b7160e01b8a526041600452838afd5b634e487b7160e01b895260116004528489fd5b50604051630f1bb9e760e41b81526001600160401b03851660048201526001600160a01b03919091166024820152604490fd5b8354871685529093019260019283019201612389565b82548b52998701996001928301920161233b565b8380fd5b503461012b578060031936011261012b5760206001600160401b03600f5416604051908152f35b503461012b57604036600319011261012b576001600160a01b036040612600613275565b926001600160401b03612611613606565b94168152600e6020522091165f52602052602060ff60405f2054166040519015158152f35b503461012b57604036600319011261012b576126506135f0565b6001600160401b039190602435838116810361054b5761266f91613988565b604051916020808401906020855283518092526020604086019401925b8281106126995785850386f35b835187168552938101939281019260010161268c565b503461012b57602036600319011261012b576126c9613275565b6001600160401b0380600a541691169081101561211957808252600d60205260408220335f5260205260ff60405f2054161561275c57808252600b602052600660408320018054600260ff821661271f816135e6565b03612728578380f35b60ff191660021790557f14883c8b2ec2887f4d5131ced01a22713b9040addbfd70ef20b904821671f1d48280a25f80808380f35b602490604051906388f9834f60e01b82526004820152fd5b503461012b57602036600319011261012b5760406127de916001600160401b0361279c613275565b168152600b602052206127ae81613455565b9063ffffffff600482015491600660058201549101549060ff82169060405196879660a0885260a088019061353c565b94602087015260408601526127f2816135e6565b606085015260081c1660808301520390f35b90503461054b5760031960a03682011261054b57600435906001600160401b03821161054b5760a09082600401923603011261054b576024356001600160401b03811161054b57612859903690600401613234565b6084939193359163ffffffff8316830361054b57600482116131f1575060643560443510156131855761288c36846136ec565b73__$2f54ce675f47f0f54c71c5a505d5110875$__90813b1561054b576040515f81806128c763b4d54fdb60e01b95868352600483016137e6565b0381865af4801561150557613172575b5086805b8481106130f557505050506001600160401b03600a54169361290a60405194612903866132d6565b36906136ec565b845261291582613420565b91612923604051938461335d565b80835260051b8101602083013682116130f15782905b8282106130c157505050509063ffffffff916020840152604435604084015260643560608401528460808401521660a0820152818352600d60205260408320335f5260205260405f20600160ff19825416179055818352600b60205260408320815180518051906001600160401b0382116130ad576129b8845461328b565b601f811161307d575b50602090601f8311600114613015576129f19291889183612cdd575b50508160011b915f199060031b1c19161790565b82555b600182016020820151906020825192612a0d84846138f4565b019087526020872087915b838310612f0c5750505050600282019063ffffffff6040820151169082549168ff0000000000000000608067ffffffff00000000606085015160201b16930151612a6181613437565b612a6a81613437565b60401b169268ffffffffffffffffff191617171790556020820151805190600160401b8211612ef8576003830154826003850155808310612e4f575b50602001906003830186526020862086925b828410612b75575050505060069060408301516004820155606083015160058201550190608081015190612aeb826135e6565b612af4826135e6565b60ff64ffffffff0060a0855493015160081b1692169064ffffffffff191617179055600a546001600160401b03612b2c81831661393b565b16906001600160401b03191617600a55604051604435815260643560208201527f49db07058829aa7f58f443df35f9612682dc944257eb8d87915f0017424243f360403392a380f35b805180518051906001600160401b038211612e3b57612b94855461328b565b601f8111612e0b575b50602090601f8311600114612da357612bcc92918c9183612cdd5750508160011b915f199060031b1c19161790565b83555b600183016020820151906020825192612be884846138f4565b01908b5260208b20908b905b838210612c6f57505050506020600192600392600286019063ffffffff6040820151169082549168ff0000000000000000608067ffffffff000000006060850151891b16930151612c4481613437565b612c4d81613437565b60401b169268ffffffffffffffffff1916171717905501920193019290612ab8565b80518051906001600160401b038211612d8f578e90612c8e865461328b565b601f8111612d54575b50602091601f8411600114612ce8578360019592946020948796612cce9492612cdd5750508160011b915f199060031b1c19161790565b86555b01930191019091612bf4565b015190505f806129dd565b919086835260208320925b601f1985168110612d3c575083602093600196938796938794601f19811610612d24575b505050811b018655612cd1565b01515f1960f88460031b161c191690555f8080612d17565b91926020600181928685015181550194019201612cf3565b612d7f9087845260208420601f860160051c81019160208710612d85575b601f0160051c0190613896565b5f612c97565b9091508190612d72565b634e487b7160e01b8f52604160045260248ffd5b9190858c5260208c20908c935b601f1984168510612df0576001945083601f19811610612dd8575b505050811b018355612bcf565b01515f1960f88460031b161c191690555f8080612dcb565b81810151835560209485019460019093019290910190612db0565b612e3590868d5260208d20601f850160051c81019160208610612d8557601f0160051c0190613896565b5f612b9d565b634e487b7160e01b8b52604160045260248bfd5b6003818102048103612ee4576003838102048303612ee457600384018752602087208360030281015b8260030282018110612e8b575050612aa6565b612e94816138ac565b60018101545f600183015580612eb5575b5080896002600393015501612e78565b600182015f5260205f2090815b8183018110612ed2575050612ea5565b80612ede6001926138ac565b01612ec2565b634e487b7160e01b87526011600452602487fd5b634e487b7160e01b86526041600452602486fd5b80518051906001600160401b038211612e3b57612f29845461328b565b601f8111612fe5575b506020908b601f8411600114612f79578360019592946020948796612f6a9492612cdd5750508160011b915f199060031b1c19161790565b85555b01920192019190612a18565b85905260208c2091908c5b601f1985168110612fcd575083602093600196938796938794601f19811610612fb5575b505050811b018555612f6d565b01515f1960f88460031b161c191690555f8080612fa8565b91926020600181928685015181550194019201612f84565b61300f90858d5260208d20601f850160051c81019160208610612d8557601f0160051c0190613896565b5f612f32565b9190848852602088209088935b601f1984168510613062576001945083601f1981161061304a575b505050811b0182556129f4565b01515f1960f88460031b161c191690555f808061303d565b81810151835560209485019460019093019290910190613022565b6130a79085895260208920601f850160051c81019160208610612d8557601f0160051c0190613896565b5f6129c1565b634e487b7160e01b87526041600452602487fd5b81356001600160401b0381116130ed576020916130e28392369088016136ec565b815201910190612939565b8980fd5b8780fd5b8060051b880135609e1989360301811215610832576131179036908a016136ec565b843b1561083257826131369160405180938192888352600483016137e6565b0381885af4908115613167578391613153575b50506001016128db565b61315c906132c3565b611ca557815f613149565b6040513d85823e3d90fd5b61317d9197506132c3565b5f955f6128d7565b604051632c3efebd60e01b815260206004820152602760248201527f53746172742074696d652073686f756c64206265206c657373207468616e206560448201527f6e642074696d65000000000000000000000000000000000000000000000000006064820152608490fd5b632c3efebd60e01b815260206004820152601960248201527f6d6178206d657461206f7074696f6e73206578636565646564000000000000006044820152606490fd5b9181601f8401121561054b578235916001600160401b03831161054b576020808501948460051b01011161054b57565b359063ffffffff8216820361054b57565b600435906001600160401b038216820361054b57565b90600182811c921680156132b9575b60208310146132a557565b634e487b7160e01b5f52602260045260245ffd5b91607f169161329a565b6001600160401b038111610d4457604052565b60c081019081106001600160401b03821117610d4457604052565b604081019081106001600160401b03821117610d4457604052565b60a081019081106001600160401b03821117610d4457604052565b60e081019081106001600160401b03821117610d4457604052565b606081019081106001600160401b03821117610d4457604052565b90601f801991011681019081106001600160401b03821117610d4457604052565b9060405191825f82546133908161328b565b908184526020946001916001811690815f146133fe57506001146133c0575b5050506133be9250038361335d565b565b5f90815285812095935091905b8183106133e65750506133be93508201015f80806133af565b855488840185015294850194879450918301916133cd565b925050506133be94925060ff191682840152151560051b8201015f80806133af565b6001600160401b038111610d445760051b60200190565b6002111561344157565b634e487b7160e01b5f52602160045260245ffd5b906040516134628161330c565b809261346d8161337e565b8252600180820190815461348081613420565b9261348e604051948561335d565b8184525f90815260208082208186015b8484106134e357505050505050600260809260ff926020860152015463ffffffff80821660408601528160201c16606085015260401c16916134df83613437565b0152565b858381926134f08561337e565b81520192019301929061349e565b91908251928382525f5b848110613528575050825f602080949584010152601f8019910116010190565b602081830181015184830182015201613508565b90613550825160a0835260a08301906134fe565b916020928382015193838203818501528451908183528083019281808460051b8301019701935f915b8483106135b85750505050505060808160408293015163ffffffff809116604086015260608201511660608501520151916135b383613437565b015290565b90919293949784806135d6600193601f198682030187528c516134fe565b9a01930193019194939290613579565b6003111561344157565b600435906001600160a01b038216820361054b57565b602435906001600160a01b038216820361054b57565b9190918054831015610e39575f52601860205f208360021c019260031b1690565b9081518082526020808093019301915f5b82811061365c575050505090565b83518552938101939281019260010161364e565b8054821015610e39575f5260205f209060011b01905f90565b9291926001600160401b038211610d4457604051916136b2601f8201601f19166020018461335d565b82948184528183011161054b578281602093845f960137010152565b9080601f8301121561054b578160206136e993359101613689565b90565b91909160a08184031261054b57604051906137068261330c565b81938135906001600160401b039182811161054b57816137279185016136ce565b84526020908184013583811161054b57840181601f8201121561054b57803561374f81613420565b9461375d604051968761335d565b818652848087019260051b8401019380851161054b57858401925b8584106137c157505050505050906080929184015261379960408201613264565b60408401526137aa60608201613264565b6060840152013590600282101561054b5760800152565b833583811161054b5787916137db848480948a01016136ce565b815201930192613778565b602091828252613801815160a08585015260c08401906134fe565b928082015193601f19918285830301604086015285519182815281810182808560051b8401019801945f925b8584106138685750505050505050608081604060a093015163ffffffff8091166060860152606082015116828501520151916135b383613437565b909192939495988580613885838686600196030188528d516134fe565b9b019401940192959493919061382d565b8181106138a1575050565b5f8155600101613896565b6138b6815461328b565b90816138c0575050565b81601f5f93116001146138d1575055565b9080839182526138f0601f60208420940160051c840160018501613896565b5555565b90600160401b8111610d445781549181815582821061391257505050565b5f5260205f2091820191015b818110613929575050565b806139356001926138ac565b0161391e565b9060016001600160401b038093160191821161395357565b634e487b7160e01b5f52601160045260245ffd5b805115610e395760200190565b8051821015610e395760209160051b010190565b6001600160a01b03165f526011602091601160205260409260405f20935f945f938154945b858110613a8657506139be87613420565b966139cc604051988961335d565b808852601f196139db82613420565b013660208a013715613a7d575f935f5b8681106139fd57505050505050505090565b613a07818561361c565b6001600160401b03809254600392831b1c165f526010845281875f20541682861614613a38575b50506001016139eb565b613a45838799949961361c565b9054911b1c16613a55828b613974565b5260018101809111613a6a579460015f613a2e565b87634e487b7160e01b5f5260045260245ffd5b50505050505090565b613a90818461361c565b906001600160401b03918291549060031b1c165f526010865280855f20541690831614613ac0575b6001016139ad565b9660018101809111613ad25796613ab8565b86634e487b7160e01b5f5260045260245ffd5b90613aef82613420565b613afc604051918261335d565b8281528092613b0d601f1991613420565b0190602036910137565b90600160401b8111610d4457815491818155828210613b3557505050565b5f5260205f2091820191015b818110613b4c575050565b5f8155600101613b41565b90604051918281549182825260209260208301915f5260205f20935f905b828210613b8b575050506133be9250038361335d565b855484526001958601958895509381019390910190613b75565b90600163ffffffff8093160191821161395357565b91909163ffffffff8080941691160191821161395357565b805415610e39575f5260205f20905f90565b805460011015610e39575f52600160205f2001905f90565b805460021015610e39575f52600260205f2001905f90565b8054821015610e39575f5260205f2001905f90565b6001600160401b0380600a5416911690811015612119575f526020600c60205260409060405f20805491613c5c83613420565b93613c6a604051958661335d565b83855260208501925f5260205f20905f935b858510613c8d575050505050505190565b6002846001928451613c9e816132f1565b86548152613cad858801613b57565b83820152815201930194019391613c7c565b8054821015610e39575f52600360205f20910201905f90565b81549160ff92838160081c169060049182811015613e585715613e6b57508154848160081c1682811015613e5857600114613d945750815490848260081c169080821015613d815750600214613d555750546136e99263ffffffff92613d4391831690600101613c14565b9290549160101c169160031b1c61415e565b9050613d6f63ffffffff9260016136e99584169101613c14565b9290549160101c169160031b1c6140e6565b602190634e487b7160e01b5f525260245ffd5b93613daa91925092600160209486169101613c14565b90549060031b1c908115613e44575b6064905f6001600160a01b035f8051602061435c833981519152541663ffffffff6040519788968795631927108160e01b875286015260101c166024840152600160f81b60448401525af1908115611505575f91613e15575090565b90506020813d602011613e3c575b81613e306020938361335d565b8101031261054b575190565b3d9150613e23565b90506064613e506142b4565b919050613db9565b602183634e487b7160e01b5f525260245ffd5b93613e8191925092600160209486169101613c14565b90549060031b1c908115613eec575b6064905f6001600160a01b035f8051602061435c833981519152541663ffffffff6040519788968795630d7c62eb60e31b875286015260101c166024840152600160f81b60448401525af1908115611505575f91613e15575090565b90506064613ef86142b4565b919050613e90565b5f8051602061435c8339815191525460405163025f346960e51b81526004810192909252600160fa1b6024830152602090829060449082905f906001600160a01b03165af1908115611505575f91613e15575090565b908115613fcb575b8015613fb9575b60209060646001600160a01b035f8051602061435c8339815191525416935f604051958694859363f953e42760e01b8552600485015260248401528160448401525af1908115611505575f91613e15575090565b506020613fc46142b4565b9050613f65565b9050613fd56142b4565b90613f5e565b602061402c926001600160a01b0392835f8051602061435c8339815191525416905f6040518097819582946302e817ff60e41b845260048401523360248401526080604484015260848301906134fe565b600160fa1b606483015203925af1918215611505575f926140b2575b507fed8d60e34876f751cc8b014c560745351147d9de11b9347c854e881b128ea6005416803b1561054b576040516346ce4e4960e11b815260048101839052336024820152905f908290604490829084905af18015611505576140a9575090565b6136e9906132c3565b9091506020813d6020116140de575b816140ce6020938361335d565b8101031261054b5751905f614048565b3d91506140c1565b63ffffffff91602091801561414c575b6064905f6001600160a01b035f8051602061435c8339815191525416604051968795869463052896f160e01b86526004860152166024840152600160f81b60448401525af1908115611505575f91613e15575090565b5060646141576142b4565b90506140f6565b63ffffffff9160209180156141c4575b6064905f6001600160a01b035f8051602061435c833981519152541660405196879586946334a6d7b960e11b86526004860152166024840152600160f81b60448401525af1908115611505575f91613e15575090565b5060646141cf6142b4565b905061416e565b9081518082526020808093019301915f5b8281106141f5575050505090565b8351855293810193928101926001016141e7565b5f52600460205260405f20805490600160401b821015610d44578161144091600161423694018155613c14565b9055565b6001600160a01b037fed8d60e34876f751cc8b014c560745351147d9de11b9347c854e881b128ea600541691823b1561054b57604051631974142760e21b815260048101929092526001600160a01b03166024820152905f908290604490829084905af18015611505576142ab5750565b6133be906132c3565b5f60206001600160a01b035f8051602061435c8339815191525416604460405180948193631ce2e8d760e31b8352816004840152600160fa1b60248401525af1908115611505575f91613e15575090565b5f8051602061435c83398151915254604051631ce2e8d760e31b81526004810192909252600160fa1b6024830152602090829060449082905f906001600160a01b03165af1908115611505575f91613e1557509056feed8d60e34876f751cc8b014c560745351147d9de11b9347c854e881b128ea601a164736f6c6343000818000a",
  "libraries": {
    "QuestionSpecLib": "0x0Ea37D3264b940C94D68DA1EB34C291D62Ba8Ab5"
  },
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 2102,
        "contract": "contracts/Analytic.sol:Analytic",
        "label": "paramsEBool",
        "offset": 0,
        "slot": "0",
        "type": "t_mapping(t_uint256,t_array(t_userDefinedValueType(ebool)4844)dyn_storage)"
      },
      {
        "astId": 2108,
        "contract": "contracts/Analytic.sol:Analytic",
        "label": "paramsEUint4",
        "offset": 0,
        "slot": "1",
        "type": "t_mapping(t_uint256,t_array(t_userDefinedValueType(euint4)4846)dyn_storage)"
      },
      {
        "astId": 2114,
        "contract": "contracts/Analytic.sol:Analytic",
        "label": "paramsEUint8",
        "offset": 0,
        "slot": "2",
        "type": "t_mapping(t_uint256,t_array(t_userDefinedValueType(euint8)4848)dyn_storage)"
      },
      {
        "astId": 2120,
        "contract": "contracts/Analytic.sol:Analytic",
        "label": "paramsEUint16",
        "offset": 0,
        "slot": "3",
        "type": "t_mapping(t_uint256,t_array(t_userDefinedValueType(euint16)4850)dyn_storage)"
      },
      {
        "astId": 2126,
        "contract": "contracts/Analytic.sol:Analytic",
        "label": "paramsEUint32",
        "offset": 0,
        "slot": "4",
        "type": "t_mapping(t_uint256,t_array(t_userDefinedValueType(euint32)4852)dyn_storage)"
      },
      {
        "astId": 2132,
        "contract": "contracts/Analytic.sol:Analytic",
        "label": "paramsEUint64",
        "offset": 0,
        "slot": "5",
        "type": "t_mapping(t_uint256,t_array(t_userDefinedValueType(euint64)4854)dyn_storage)"
      },
      {
        "astId": 2138,
        "contract": "contracts/Analytic.sol:Analytic",
        "label": "paramsEAddress",
        "offset": 0,
        "slot": "6",
        "type": "t_mapping(t_uint256,t_array(t_userDefinedValueType(eaddress)4860)dyn_storage)"
      },
      {
        "astId": 2143,
        "contract": "contracts/Analytic.sol:Analytic",
        "label": "paramsAddress",
        "offset": 0,
        "slot": "7",
        "type": "t_mapping(t_uint256,t_array(t_address)dyn_storage)"
      },
      {
        "astId": 2148,
        "contract": "contracts/Analytic.sol:Analytic",
        "label": "paramsUint256",
        "offset": 0,
        "slot": "8",
        "type": "t_mapping(t_uint256,t_array(t_uint256)dyn_storage)"
      },
      {
        "astId": 2153,
        "contract": "contracts/Analytic.sol:Analytic",
        "label": "requestedHandles",
        "offset": 0,
        "slot": "9",
        "type": "t_mapping(t_uint256,t_array(t_uint256)dyn_storage)"
      },
      {
        "astId": 34,
        "contract": "contracts/Analytic.sol:Analytic",
        "label": "nextQuestionId",
        "offset": 0,
        "slot": "10",
        "type": "t_uint64"
      },
      {
        "astId": 39,
        "contract": "contracts/Analytic.sol:Analytic",
        "label": "questions",
        "offset": 0,
        "slot": "11",
        "type": "t_mapping(t_uint64,t_struct(Question)1820_storage)"
      },
      {
        "astId": 45,
        "contract": "contracts/Analytic.sol:Analytic",
        "label": "questionAnswers",
        "offset": 0,
        "slot": "12",
        "type": "t_mapping(t_uint64,t_array(t_struct(Answer)1867_storage)dyn_storage)"
      },
      {
        "astId": 51,
        "contract": "contracts/Analytic.sol:Analytic",
        "label": "questionAdmins",
        "offset": 0,
        "slot": "13",
        "type": "t_mapping(t_uint64,t_mapping(t_address,t_bool))"
      },
      {
        "astId": 57,
        "contract": "contracts/Analytic.sol:Analytic",
        "label": "hasAnswered",
        "offset": 0,
        "slot": "14",
        "type": "t_mapping(t_uint64,t_mapping(t_address,t_bool))"
      },
      {
        "astId": 60,
        "contract": "contracts/Analytic.sol:Analytic",
        "label": "nextQueryRequestId",
        "offset": 0,
        "slot": "15",
        "type": "t_uint64"
      },
      {
        "astId": 65,
        "contract": "contracts/Analytic.sol:Analytic",
        "label": "queryRequests",
        "offset": 0,
        "slot": "16",
        "type": "t_mapping(t_uint64,t_struct(QueryRequest)1841_storage)"
      },
      {
        "astId": 70,
        "contract": "contracts/Analytic.sol:Analytic",
        "label": "userQueries",
        "offset": 0,
        "slot": "17",
        "type": "t_mapping(t_address,t_array(t_uint64)dyn_storage)"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_array(t_address)dyn_storage": {
        "base": "t_address",
        "encoding": "dynamic_array",
        "label": "address[]",
        "numberOfBytes": "32"
      },
      "t_array(t_string_storage)dyn_storage": {
        "base": "t_string_storage",
        "encoding": "dynamic_array",
        "label": "string[]",
        "numberOfBytes": "32"
      },
      "t_array(t_struct(Answer)1867_storage)dyn_storage": {
        "base": "t_struct(Answer)1867_storage",
        "encoding": "dynamic_array",
        "label": "struct IAnalytic.Answer[]",
        "numberOfBytes": "32"
      },
      "t_array(t_struct(Predicate)1859_storage)dyn_storage": {
        "base": "t_struct(Predicate)1859_storage",
        "encoding": "dynamic_array",
        "label": "struct IAnalytic.Predicate[]",
        "numberOfBytes": "32"
      },
      "t_array(t_struct(QuestionSpec)1732_storage)dyn_storage": {
        "base": "t_struct(QuestionSpec)1732_storage",
        "encoding": "dynamic_array",
        "label": "struct QuestionSpecLib.QuestionSpec[]",
        "numberOfBytes": "32"
      },
      "t_array(t_uint256)dyn_storage": {
        "base": "t_uint256",
        "encoding": "dynamic_array",
        "label": "uint256[]",
        "numberOfBytes": "32"
      },
      "t_array(t_uint64)dyn_storage": {
        "base": "t_uint64",
        "encoding": "dynamic_array",
        "label": "uint64[]",
        "numberOfBytes": "32"
      },
      "t_array(t_userDefinedValueType(eaddress)4860)dyn_storage": {
        "base": "t_userDefinedValueType(eaddress)4860",
        "encoding": "dynamic_array",
        "label": "eaddress[]",
        "numberOfBytes": "32"
      },
      "t_array(t_userDefinedValueType(ebool)4844)dyn_storage": {
        "base": "t_userDefinedValueType(ebool)4844",
        "encoding": "dynamic_array",
        "label": "ebool[]",
        "numberOfBytes": "32"
      },
      "t_array(t_userDefinedValueType(euint16)4850)dyn_storage": {
        "base": "t_userDefinedValueType(euint16)4850",
        "encoding": "dynamic_array",
        "label": "euint16[]",
        "numberOfBytes": "32"
      },
      "t_array(t_userDefinedValueType(euint32)4852)dyn_storage": {
        "base": "t_userDefinedValueType(euint32)4852",
        "encoding": "dynamic_array",
        "label": "euint32[]",
        "numberOfBytes": "32"
      },
      "t_array(t_userDefinedValueType(euint4)4846)dyn_storage": {
        "base": "t_userDefinedValueType(euint4)4846",
        "encoding": "dynamic_array",
        "label": "euint4[]",
        "numberOfBytes": "32"
      },
      "t_array(t_userDefinedValueType(euint64)4854)dyn_storage": {
        "base": "t_userDefinedValueType(euint64)4854",
        "encoding": "dynamic_array",
        "label": "euint64[]",
        "numberOfBytes": "32"
      },
      "t_array(t_userDefinedValueType(euint8)4848)dyn_storage": {
        "base": "t_userDefinedValueType(euint8)4848",
        "encoding": "dynamic_array",
        "label": "euint8[]",
        "numberOfBytes": "32"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_enum(PredicateOp)1796": {
        "encoding": "inplace",
        "label": "enum IAnalytic.PredicateOp",
        "numberOfBytes": "1"
      },
      "t_enum(QuestionState)1803": {
        "encoding": "inplace",
        "label": "enum IAnalytic.QuestionState",
        "numberOfBytes": "1"
      },
      "t_enum(QuestionType)1719": {
        "encoding": "inplace",
        "label": "enum QuestionSpecLib.QuestionType",
        "numberOfBytes": "1"
      },
      "t_enum(RequestState)1799": {
        "encoding": "inplace",
        "label": "enum IAnalytic.RequestState",
        "numberOfBytes": "1"
      },
      "t_mapping(t_address,t_array(t_uint64)dyn_storage)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => uint64[])",
        "numberOfBytes": "32",
        "value": "t_array(t_uint64)dyn_storage"
      },
      "t_mapping(t_address,t_bool)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => bool)",
        "numberOfBytes": "32",
        "value": "t_bool"
      },
      "t_mapping(t_uint256,t_array(t_address)dyn_storage)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => address[])",
        "numberOfBytes": "32",
        "value": "t_array(t_address)dyn_storage"
      },
      "t_mapping(t_uint256,t_array(t_uint256)dyn_storage)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => uint256[])",
        "numberOfBytes": "32",
        "value": "t_array(t_uint256)dyn_storage"
      },
      "t_mapping(t_uint256,t_array(t_userDefinedValueType(eaddress)4860)dyn_storage)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => eaddress[])",
        "numberOfBytes": "32",
        "value": "t_array(t_userDefinedValueType(eaddress)4860)dyn_storage"
      },
      "t_mapping(t_uint256,t_array(t_userDefinedValueType(ebool)4844)dyn_storage)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => ebool[])",
        "numberOfBytes": "32",
        "value": "t_array(t_userDefinedValueType(ebool)4844)dyn_storage"
      },
      "t_mapping(t_uint256,t_array(t_userDefinedValueType(euint16)4850)dyn_storage)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => euint16[])",
        "numberOfBytes": "32",
        "value": "t_array(t_userDefinedValueType(euint16)4850)dyn_storage"
      },
      "t_mapping(t_uint256,t_array(t_userDefinedValueType(euint32)4852)dyn_storage)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => euint32[])",
        "numberOfBytes": "32",
        "value": "t_array(t_userDefinedValueType(euint32)4852)dyn_storage"
      },
      "t_mapping(t_uint256,t_array(t_userDefinedValueType(euint4)4846)dyn_storage)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => euint4[])",
        "numberOfBytes": "32",
        "value": "t_array(t_userDefinedValueType(euint4)4846)dyn_storage"
      },
      "t_mapping(t_uint256,t_array(t_userDefinedValueType(euint64)4854)dyn_storage)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => euint64[])",
        "numberOfBytes": "32",
        "value": "t_array(t_userDefinedValueType(euint64)4854)dyn_storage"
      },
      "t_mapping(t_uint256,t_array(t_userDefinedValueType(euint8)4848)dyn_storage)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => euint8[])",
        "numberOfBytes": "32",
        "value": "t_array(t_userDefinedValueType(euint8)4848)dyn_storage"
      },
      "t_mapping(t_uint64,t_array(t_struct(Answer)1867_storage)dyn_storage)": {
        "encoding": "mapping",
        "key": "t_uint64",
        "label": "mapping(uint64 => struct IAnalytic.Answer[])",
        "numberOfBytes": "32",
        "value": "t_array(t_struct(Answer)1867_storage)dyn_storage"
      },
      "t_mapping(t_uint64,t_mapping(t_address,t_bool))": {
        "encoding": "mapping",
        "key": "t_uint64",
        "label": "mapping(uint64 => mapping(address => bool))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_address,t_bool)"
      },
      "t_mapping(t_uint64,t_struct(QueryRequest)1841_storage)": {
        "encoding": "mapping",
        "key": "t_uint64",
        "label": "mapping(uint64 => struct IAnalytic.QueryRequest)",
        "numberOfBytes": "32",
        "value": "t_struct(QueryRequest)1841_storage"
      },
      "t_mapping(t_uint64,t_struct(Question)1820_storage)": {
        "encoding": "mapping",
        "key": "t_uint64",
        "label": "mapping(uint64 => struct IAnalytic.Question)",
        "numberOfBytes": "32",
        "value": "t_struct(Question)1820_storage"
      },
      "t_string_storage": {
        "encoding": "bytes",
        "label": "string",
        "numberOfBytes": "32"
      },
      "t_struct(Answer)1867_storage": {
        "encoding": "inplace",
        "label": "struct IAnalytic.Answer",
        "members": [
          {
            "astId": 1862,
            "contract": "contracts/Analytic.sol:Analytic",
            "label": "val",
            "offset": 0,
            "slot": "0",
            "type": "t_userDefinedValueType(euint32)4852"
          },
          {
            "astId": 1866,
            "contract": "contracts/Analytic.sol:Analytic",
            "label": "metaVals",
            "offset": 0,
            "slot": "1",
            "type": "t_array(t_userDefinedValueType(euint32)4852)dyn_storage"
          }
        ],
        "numberOfBytes": "64"
      },
      "t_struct(Predicate)1859_storage": {
        "encoding": "inplace",
        "label": "struct IAnalytic.Predicate",
        "members": [
          {
            "astId": 1853,
            "contract": "contracts/Analytic.sol:Analytic",
            "label": "metaOpt",
            "offset": 0,
            "slot": "0",
            "type": "t_uint8"
          },
          {
            "astId": 1856,
            "contract": "contracts/Analytic.sol:Analytic",
            "label": "op",
            "offset": 1,
            "slot": "0",
            "type": "t_enum(PredicateOp)1796"
          },
          {
            "astId": 1858,
            "contract": "contracts/Analytic.sol:Analytic",
            "label": "metaVal",
            "offset": 2,
            "slot": "0",
            "type": "t_uint32"
          }
        ],
        "numberOfBytes": "32"
      },
      "t_struct(QueryRequest)1841_storage": {
        "encoding": "inplace",
        "label": "struct IAnalytic.QueryRequest",
        "members": [
          {
            "astId": 1822,
            "contract": "contracts/Analytic.sol:Analytic",
            "label": "questionId",
            "offset": 0,
            "slot": "0",
            "type": "t_uint64"
          },
          {
            "astId": 1824,
            "contract": "contracts/Analytic.sol:Analytic",
            "label": "owner",
            "offset": 8,
            "slot": "0",
            "type": "t_address"
          },
          {
            "astId": 1828,
            "contract": "contracts/Analytic.sol:Analytic",
            "label": "predicates",
            "offset": 0,
            "slot": "1",
            "type": "t_array(t_struct(Predicate)1859_storage)dyn_storage"
          },
          {
            "astId": 1832,
            "contract": "contracts/Analytic.sol:Analytic",
            "label": "acc",
            "offset": 0,
            "slot": "2",
            "type": "t_array(t_userDefinedValueType(euint32)4852)dyn_storage"
          },
          {
            "astId": 1835,
            "contract": "contracts/Analytic.sol:Analytic",
            "label": "ansCount",
            "offset": 0,
            "slot": "3",
            "type": "t_userDefinedValueType(euint32)4852"
          },
          {
            "astId": 1837,
            "contract": "contracts/Analytic.sol:Analytic",
            "label": "accSteps",
            "offset": 0,
            "slot": "4",
            "type": "t_uint32"
          },
          {
            "astId": 1840,
            "contract": "contracts/Analytic.sol:Analytic",
            "label": "state",
            "offset": 4,
            "slot": "4",
            "type": "t_enum(RequestState)1799"
          }
        ],
        "numberOfBytes": "160"
      },
      "t_struct(Question)1820_storage": {
        "encoding": "inplace",
        "label": "struct IAnalytic.Question",
        "members": [
          {
            "astId": 1806,
            "contract": "contracts/Analytic.sol:Analytic",
            "label": "main",
            "offset": 0,
            "slot": "0",
            "type": "t_struct(QuestionSpec)1732_storage"
          },
          {
            "astId": 1810,
            "contract": "contracts/Analytic.sol:Analytic",
            "label": "metas",
            "offset": 0,
            "slot": "3",
            "type": "t_array(t_struct(QuestionSpec)1732_storage)dyn_storage"
          },
          {
            "astId": 1812,
            "contract": "contracts/Analytic.sol:Analytic",
            "label": "startTime",
            "offset": 0,
            "slot": "4",
            "type": "t_uint256"
          },
          {
            "astId": 1814,
            "contract": "contracts/Analytic.sol:Analytic",
            "label": "endTime",
            "offset": 0,
            "slot": "5",
            "type": "t_uint256"
          },
          {
            "astId": 1817,
            "contract": "contracts/Analytic.sol:Analytic",
            "label": "state",
            "offset": 0,
            "slot": "6",
            "type": "t_enum(QuestionState)1803"
          },
          {
            "astId": 1819,
            "contract": "contracts/Analytic.sol:Analytic",
            "label": "queryThreshold",
            "offset": 1,
            "slot": "6",
            "type": "t_uint32"
          }
        ],
        "numberOfBytes": "224"
      },
      "t_struct(QuestionSpec)1732_storage": {
        "encoding": "inplace",
        "label": "struct QuestionSpecLib.QuestionSpec",
        "members": [
          {
            "astId": 1721,
            "contract": "contracts/Analytic.sol:Analytic",
            "label": "text",
            "offset": 0,
            "slot": "0",
            "type": "t_string_storage"
          },
          {
            "astId": 1724,
            "contract": "contracts/Analytic.sol:Analytic",
            "label": "options",
            "offset": 0,
            "slot": "1",
            "type": "t_array(t_string_storage)dyn_storage"
          },
          {
            "astId": 1726,
            "contract": "contracts/Analytic.sol:Analytic",
            "label": "min",
            "offset": 0,
            "slot": "2",
            "type": "t_uint32"
          },
          {
            "astId": 1728,
            "contract": "contracts/Analytic.sol:Analytic",
            "label": "max",
            "offset": 4,
            "slot": "2",
            "type": "t_uint32"
          },
          {
            "astId": 1731,
            "contract": "contracts/Analytic.sol:Analytic",
            "label": "t",
            "offset": 8,
            "slot": "2",
            "type": "t_enum(QuestionType)1719"
          }
        ],
        "numberOfBytes": "96"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      },
      "t_uint32": {
        "encoding": "inplace",
        "label": "uint32",
        "numberOfBytes": "4"
      },
      "t_uint64": {
        "encoding": "inplace",
        "label": "uint64",
        "numberOfBytes": "8"
      },
      "t_uint8": {
        "encoding": "inplace",
        "label": "uint8",
        "numberOfBytes": "1"
      },
      "t_userDefinedValueType(eaddress)4860": {
        "encoding": "inplace",
        "label": "eaddress",
        "numberOfBytes": "32"
      },
      "t_userDefinedValueType(ebool)4844": {
        "encoding": "inplace",
        "label": "ebool",
        "numberOfBytes": "32"
      },
      "t_userDefinedValueType(euint16)4850": {
        "encoding": "inplace",
        "label": "euint16",
        "numberOfBytes": "32"
      },
      "t_userDefinedValueType(euint32)4852": {
        "encoding": "inplace",
        "label": "euint32",
        "numberOfBytes": "32"
      },
      "t_userDefinedValueType(euint4)4846": {
        "encoding": "inplace",
        "label": "euint4",
        "numberOfBytes": "32"
      },
      "t_userDefinedValueType(euint64)4854": {
        "encoding": "inplace",
        "label": "euint64",
        "numberOfBytes": "32"
      },
      "t_userDefinedValueType(euint8)4848": {
        "encoding": "inplace",
        "label": "euint8",
        "numberOfBytes": "32"
      }
    }
  }
}