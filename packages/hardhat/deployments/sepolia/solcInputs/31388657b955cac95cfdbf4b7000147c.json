{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable2Step.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (access/Ownable2Step.sol)\n\npragma solidity ^0.8.20;\n\nimport {Ownable} from \"./Ownable.sol\";\n\n/**\n * @dev Contract module which provides access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This extension of the {Ownable} contract includes a two-step mechanism to transfer\n * ownership, where the new owner must call {acceptOwnership} in order to replace the\n * old one. This can help prevent common mistakes, such as transfers of ownership to\n * incorrect accounts, or to contracts that are unable to interact with the\n * permission system.\n *\n * The initial owner is specified at deployment time in the constructor for `Ownable`. This\n * can later be changed with {transferOwnership} and {acceptOwnership}.\n *\n * This module is used through inheritance. It will make available all functions\n * from parent (Ownable).\n */\nabstract contract Ownable2Step is Ownable {\n    address private _pendingOwner;\n\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Returns the address of the pending owner.\n     */\n    function pendingOwner() public view virtual returns (address) {\n        return _pendingOwner;\n    }\n\n    /**\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\n     * Can only be called by the current owner.\n     *\n     * Setting `newOwner` to the zero address is allowed; this can be used to cancel an initiated ownership transfer.\n     */\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\n        _pendingOwner = newOwner;\n        emit OwnershipTransferStarted(owner(), newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual override {\n        delete _pendingOwner;\n        super._transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev The new owner accepts the ownership transfer.\n     */\n    function acceptOwnership() public virtual {\n        address sender = _msgSender();\n        if (pendingOwner() != sender) {\n            revert OwnableUnauthorizedAccount(sender);\n        }\n        _transferOwnership(sender);\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC6093.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (interfaces/draft-IERC6093.sol)\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard ERC-20 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-20 tokens.\n */\ninterface IERC20Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC20InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC20InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `spender`’s `allowance`. Used in transfers.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC20InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC20InvalidSpender(address spender);\n}\n\n/**\n * @dev Standard ERC-721 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-721 tokens.\n */\ninterface IERC721Errors {\n    /**\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in ERC-20.\n     * Used in balance queries.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721InvalidOwner(address owner);\n\n    /**\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721NonexistentToken(uint256 tokenId);\n\n    /**\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param tokenId Identifier number of a token.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC721InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC721InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC721InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC721InvalidOperator(address operator);\n}\n\n/**\n * @dev Standard ERC-1155 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-1155 tokens.\n */\ninterface IERC1155Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC1155InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC1155InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC1155MissingApprovalForAll(address operator, address owner);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC1155InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC1155InvalidOperator(address operator);\n\n    /**\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\n     * Used in batch transfers.\n     * @param idsLength Length of the array of token identifiers\n     * @param valuesLength Length of the array of token amounts\n     */\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "contracts/Analytic.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause-Clear\npragma solidity ^0.8.24;\n\nimport \"fhevm/lib/TFHE.sol\";\nimport { SepoliaZamaFHEVMConfig } from \"fhevm/config/ZamaFHEVMConfig.sol\";\nimport { SepoliaZamaGatewayConfig } from \"fhevm/config/ZamaGatewayConfig.sol\";\nimport \"fhevm/gateway/GatewayCaller.sol\";\nimport { IAnalytic } from \"./interfaces/IAnalytic.sol\";\nimport { QuestionSpecLib } from \"./QuestionSpecLib.sol\";\n// import { console } from \"hardhat/console.sol\";\n\ncontract Analytic is SepoliaZamaFHEVMConfig, SepoliaZamaGatewayConfig, GatewayCaller, IAnalytic {\n    // --- library ---\n    using QuestionSpecLib for QuestionSpecLib.QuestionSpec;\n\n    // --- constant ---\n    uint16 public constant MAX_METAS = 4;\n    // has to correspond to the sie of enum StatsAnsPos\n    uint8 public constant STATS_ANS_SIZE = 3;\n\n    // --- storage ---\n    uint64 public nextQuestionId = 0;\n    mapping(uint64 => Question) public questions;\n    mapping(uint64 => Answer[]) public questionAnswers;\n    mapping(uint64 => mapping(address => bool)) public questionAdmins;\n    mapping(uint64 => mapping(address => bool)) public hasAnswered;\n\n    uint64 public nextQueryRequestId = 0;\n    mapping(uint64 => QueryRequest) public queryRequests;\n\n    // --- modifier ---\n    modifier questionValidAndOpen(uint64 qId) {\n        if (qId >= nextQuestionId) revert InvalidQuestion(qId);\n        Question storage question = questions[qId];\n\n        if (question.state == QuestionState.Closed) revert QuestionClosed(qId);\n        if (block.timestamp > question.endTime) revert QuestionClosed(qId);\n        _;\n    }\n\n    modifier isQuestionAdmin(uint64 qId, address sender) {\n        if (qId >= nextQuestionId) revert InvalidQuestion(qId);\n        if (!questionAdmins[qId][sender]) revert NotQuestionAdmin(qId);\n        _;\n    }\n\n    modifier aboveQueryThreshold(uint64 qId) {\n        Question storage question = questions[qId];\n        if (getAnsLen(qId) < question.queryThreshold) revert QueryThresholdNotReach(qId);\n        _;\n    }\n\n    modifier queryValidIsOwner(uint64 qId, address sender) {\n        if (qId >= nextQueryRequestId) revert InvalidQueryRequest(qId);\n        QueryRequest storage req = queryRequests[qId];\n        if (sender != req.owner) revert NotQueryOwner(qId);\n        _;\n    }\n\n    // --- viewer ---\n    function getQuestion(uint64 qId) public view returns (Question memory) {\n        if (qId >= nextQuestionId) revert InvalidQuestion(qId);\n        return questions[qId];\n    }\n\n    function getAnsLen(uint64 qId) public view returns (uint256) {\n        if (qId >= nextQuestionId) revert InvalidQuestion(qId);\n        Answer[] memory answers = questionAnswers[qId];\n        return answers.length;\n    }\n\n    function getQueryResult(\n        uint64 reqId\n    ) public view queryValidIsOwner(reqId, msg.sender) returns (QueryResult memory) {\n        // require the query request state to be completed\n        QueryRequest storage req = queryRequests[reqId];\n        if (req.state != RequestState.Completed) revert QueryNotCompleted(reqId);\n\n        return QueryResult({ acc: req.acc, filteredAnsCount: req.ansCount, ttlAnsCount: req.accSteps });\n    }\n\n    // --- write function ---\n    function newQuestion(\n        QuestionSpecLib.QuestionSpec calldata _main,\n        QuestionSpecLib.QuestionSpec[] calldata _metas,\n        uint256 _startTime,\n        uint256 _endTime,\n        uint32 _queryThreshold\n    ) public {\n        if (_metas.length > MAX_METAS) revert InvalidQuestionParam(\"max meta options exceeded\");\n        if (_startTime >= _endTime) revert InvalidQuestionParam(\"Start time should be less than end time\");\n\n        _main.validate();\n        for (uint256 i = 0; i < _metas.length; i++) _metas[i].validate();\n\n        uint64 qId = nextQuestionId;\n        Question memory question = Question({\n            main: _main,\n            metas: _metas,\n            startTime: _startTime,\n            endTime: _endTime,\n            state: QuestionState.Initialized,\n            queryThreshold: _queryThreshold\n        });\n        questionAdmins[qId][msg.sender] = true;\n        questions[qId] = question;\n        nextQuestionId += 1;\n\n        emit QuestionCreated(msg.sender, qId, _startTime, _endTime);\n    }\n\n    function closeQuestion(uint64 qId) public isQuestionAdmin(qId, msg.sender) {\n        Question storage question = questions[qId];\n        question.state = QuestionState.Closed;\n    }\n\n    function answer(\n        uint64 qId,\n        einput ans,\n        einput[] calldata metaAns,\n        bytes calldata inputProof\n    ) public questionValidAndOpen(qId) {\n        if (hasAnswered[qId][msg.sender]) revert AlreadyAnswered(qId, msg.sender);\n\n        Question storage question = questions[qId];\n\n        // Check the metaAns len has to be equal to question metaOpts\n        if (metaAns.length != question.metas.length)\n            revert MetaAnswerNumberNotMatch(qId, metaAns.length, question.metas.length);\n\n        // Update the question state\n        if (question.state != QuestionState.Open) question.state = QuestionState.Open;\n\n        // Check the encrypted input and put result in eValid.\n        // Later on we will decrypt this value to check the validity\n        euint32 eAns = TFHE.asEuint32(ans, inputProof);\n        ebool eValid = TFHE.and(TFHE.ge(eAns, question.main.min), TFHE.le(eAns, question.main.max));\n\n        euint32[] memory eMetaAns = new euint32[](metaAns.length);\n        for (uint256 mIdx = 0; mIdx < metaAns.length; ++mIdx) {\n            eMetaAns[mIdx] = TFHE.asEuint32(metaAns[mIdx], inputProof);\n            eValid = TFHE.and(\n                eValid,\n                TFHE.and(\n                    TFHE.ge(eMetaAns[mIdx], question.metas[mIdx].min),\n                    TFHE.le(eMetaAns[mIdx], question.metas[mIdx].max)\n                )\n            );\n        }\n\n        // We only want to decrypt the eValid to either confirm or reject the answer\n        uint256[] memory cts = new uint256[](1);\n        cts[0] = Gateway.toUint256(eValid);\n        uint256 reqId = Gateway.requestDecryption(\n            cts,\n            this.confirmOrRejectAnswer.selector,\n            0,\n            block.timestamp + 100,\n            false\n        );\n\n        // Additional parameters to reconstruct back the Answer object\n        addParamsUint256(reqId, uint256(qId));\n        addParamsAddress(reqId, msg.sender);\n        addParamsEUint32(reqId, eAns);\n        TFHE.allowThis(eAns);\n\n        for (uint256 mIdx = 0; mIdx < eMetaAns.length; ++mIdx) {\n            addParamsEUint32(reqId, eMetaAns[mIdx]);\n            TFHE.allowThis(eMetaAns[mIdx]);\n        }\n    }\n\n    function confirmOrRejectAnswer(uint256 reqId, bool decValid) external onlyGateway {\n        uint64 qId = uint64(getParamsUint256(reqId)[0]);\n        address sender = getParamsAddress(reqId)[0];\n\n        if (!decValid) revert RejectAnswer(qId, sender);\n\n        // valid Answer\n        euint32[] memory params = getParamsEUint32(reqId);\n        euint32[] memory metaVals = new euint32[](params.length - 1);\n        for (uint256 i = 0; i < params.length - 1; i++) {\n            metaVals[i] = params[i + 1];\n        }\n\n        Answer memory ans = Answer({ val: params[0], metaVals: metaVals });\n\n        questionAnswers[qId].push(ans);\n        hasAnswered[qId][sender] = true;\n        emit ConfirmAnswer(qId, sender);\n    }\n\n    function requestQuery(\n        uint64 qId,\n        Predicate[] calldata predicates\n    ) public isQuestionAdmin(qId, msg.sender) aboveQueryThreshold(qId) returns (uint64 reqId) {\n        reqId = nextQueryRequestId;\n        Question storage question = questions[qId];\n\n        euint32 eZero = TFHE.asEuint32(0);\n        euint32[] memory acc;\n\n        if (question.main.t == QuestionSpecLib.QuestionType.Option) {\n            acc = new euint32[](question.main.max + 1);\n            for (uint64 i = 0; i <= question.main.max; i++) {\n                acc[i] = eZero;\n            }\n        } else {\n            acc = new euint32[](STATS_ANS_SIZE);\n            acc[uint256(StatsAnsPos.Min)] = TFHE.asEuint32(question.main.max);\n            acc[uint256(StatsAnsPos.Sum)] = eZero;\n            acc[uint256(StatsAnsPos.Max)] = TFHE.asEuint32(question.main.min);\n        }\n\n        // create the queryRequest\n        QueryRequest memory queryReq = QueryRequest({\n            questionId: qId,\n            owner: msg.sender,\n            predicates: predicates,\n            acc: acc,\n            accSteps: 0,\n            ansCount: eZero,\n            state: RequestState.Initialized\n        });\n\n        queryRequests[reqId] = queryReq;\n        nextQueryRequestId += 1;\n\n        // granting access\n        for (uint256 i = 0; i < queryReq.acc.length; i++) {\n            TFHE.allowThis(queryReq.acc[i]);\n            TFHE.allow(queryReq.acc[i], msg.sender);\n        }\n\n        TFHE.allowThis(queryReq.ansCount);\n        TFHE.allow(queryReq.ansCount, msg.sender);\n\n        emit QueryRequestCreated(reqId, msg.sender);\n    }\n\n    function deleteQuery(uint64 reqId) public queryValidIsOwner(reqId, msg.sender) {\n        // Can only be deleted by the owner\n        QueryRequest storage req = queryRequests[reqId];\n        if (req.owner != msg.sender) revert NotQueryOwner(reqId);\n        delete queryRequests[reqId];\n        emit QueryRequestDeleted(reqId);\n    }\n\n    function executeQuery(uint64 reqId, uint32 steps) public queryValidIsOwner(reqId, msg.sender) {\n        QueryRequest storage req = queryRequests[reqId];\n        if (req.state == RequestState.Completed) revert QueryHasCompleted(reqId);\n\n        Question storage question = questions[req.questionId];\n        Answer[] storage answers = questionAnswers[req.questionId];\n\n        uint32 actualSteps = steps;\n        uint32 stepsToEnd = uint32(answers.length) - req.accSteps;\n        if (stepsToEnd < steps) actualSteps = stepsToEnd;\n\n        // --- This is where the query execution happens ---\n        ebool eTrue = TFHE.asEbool(true);\n        euint32[] storage acc = req.acc;\n\n        for (uint32 ai = req.accSteps; ai < req.accSteps + actualSteps; ai += 1) {\n            Answer storage ans = answers[ai];\n            ebool accepted = eTrue;\n\n            // connect predicate together with \"AND\" operator\n            for (uint256 pi = 0; pi < req.predicates.length; pi += 1) {\n                accepted = TFHE.and(_checkPredicate(ans, req.predicates[pi]), accepted);\n            }\n            req.ansCount = TFHE.add(req.ansCount, TFHE.asEuint32(accepted));\n\n            if (question.main.t == QuestionSpecLib.QuestionType.Option) {\n                _aggregateCountAns(acc, req.questionId, accepted, ans);\n            } else {\n                _aggregateStatsAns(acc, accepted, ans);\n            }\n        }\n\n        // --- Writing back to the storage\n        req.accSteps += actualSteps;\n\n        // granting read access to the req owner of the result\n        TFHE.allowThis(req.ansCount);\n        TFHE.allow(req.ansCount, req.owner);\n        for (uint256 ai = 0; ai < req.acc.length; ai++) {\n            TFHE.allowThis(req.acc[ai]);\n            TFHE.allow(req.acc[ai], req.owner);\n        }\n\n        if (req.accSteps == answers.length) {\n            req.state = RequestState.Completed;\n            emit QueryExecutionCompleted(reqId);\n        } else {\n            emit QueryExecutionRunning(reqId, req.accSteps, uint64(answers.length));\n        }\n    }\n\n    // --- Internal Helper methods ---\n    function _aggregateStatsAns(euint32[] storage acc, ebool accepted, Answer storage ans) internal {\n        // min\n        uint256 minPos = uint256(StatsAnsPos.Min);\n        acc[minPos] = TFHE.select(accepted, TFHE.min(acc[minPos], ans.val), acc[minPos]);\n\n        // avg - basically summation - avg is computed at client side\n        uint256 avgPos = uint256(StatsAnsPos.Sum);\n        acc[avgPos] = TFHE.select(accepted, TFHE.add(acc[avgPos], ans.val), acc[avgPos]);\n\n        // max\n        uint256 maxPos = uint256(StatsAnsPos.Max);\n        acc[maxPos] = TFHE.select(accepted, TFHE.max(acc[maxPos], ans.val), acc[maxPos]);\n    }\n\n    function _aggregateCountAns(euint32[] storage acc, uint64 qId, ebool accepted, Answer storage ans) internal {\n        Question storage question = questions[qId];\n        // Add count\n        for (uint32 accIdx = 0; accIdx <= question.main.max; accIdx++) {\n            // cnt is either a 0 or 1\n            // prettier-ignore\n            euint32 cnt = TFHE.asEuint32(TFHE.and(\n                accepted,\n                TFHE.eq(ans.val, TFHE.asEuint32(accIdx))\n            ));\n\n            acc[accIdx] = TFHE.add(acc[accIdx], cnt);\n        }\n    }\n\n    function _checkPredicate(Answer storage ans, Predicate storage predicate) internal returns (ebool) {\n        if (predicate.op == PredicateOp.EQ) return TFHE.eq(ans.metaVals[predicate.metaOpt], predicate.metaVal);\n        if (predicate.op == PredicateOp.NE) return TFHE.ne(ans.metaVals[predicate.metaOpt], predicate.metaVal);\n        if (predicate.op == PredicateOp.GT) return TFHE.gt(ans.metaVals[predicate.metaOpt], predicate.metaVal);\n        return TFHE.lt(ans.metaVals[predicate.metaOpt], predicate.metaVal);\n    }\n}\n"
    },
    "contracts/interfaces/IAnalytic.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause-Clear\npragma solidity ^0.8.24;\n\nimport \"fhevm/lib/TFHE.sol\";\nimport \"../QuestionSpecLib.sol\";\n\ninterface IAnalytic {\n    enum StatsAnsPos {\n        Min,\n        Sum,\n        Max\n    }\n\n    enum PredicateOp {\n        EQ,\n        NE,\n        GT,\n        LT\n    }\n\n    enum RequestState {\n        Initialized,\n        Completed\n    }\n\n    enum QuestionState {\n        Initialized,\n        Open,\n        Closed\n    }\n\n    struct Question {\n        QuestionSpecLib.QuestionSpec main;\n        QuestionSpecLib.QuestionSpec[] metas;\n        uint256 startTime;\n        uint256 endTime;\n        QuestionState state;\n        uint32 queryThreshold;\n    }\n\n    struct QueryRequest {\n        uint64 questionId;\n        address owner;\n        Predicate[] predicates;\n        euint32[] acc;\n        euint32 ansCount;\n        uint32 accSteps;\n        RequestState state;\n    }\n\n    struct QueryResult {\n        euint32[] acc;\n        euint32 filteredAnsCount;\n        uint32 ttlAnsCount;\n    }\n\n    struct Predicate {\n        uint8 metaOpt;\n        PredicateOp op;\n        uint32 metaVal;\n    }\n\n    struct Answer {\n        euint32 val;\n        euint32[] metaVals;\n    }\n\n    // All errors\n    error InvalidQuestionParam(string reason);\n    error InvalidQuestionMetaParam(string reason);\n    error InvalidQuestion(uint64 qId);\n    error QuestionClosed(uint64 qId);\n    error AlreadyAnswered(uint64 qId, address sender);\n    error MetaAnswerNumberNotMatch(uint64 qId, uint256 metaAnsLen, uint256 metaOptLen);\n    error RejectAnswer(uint64 qId, address sender);\n    error NotQuestionAdmin(uint64 qId);\n    error QueryThresholdNotReach(uint64 qId);\n\n    error InvalidQueryRequest(uint64 queryReqId);\n    error NotQueryOwner(uint64 queryReqId);\n    error QueryHasCompleted(uint64 queryReqId);\n    error QueryNotCompleted(uint64 queryReqId);\n\n    // All the events\n    event QuestionCreated(address indexed sender, uint64 indexed qId, uint256 startTime, uint256 endTime);\n    event ConfirmAnswer(uint64 indexed qId, address indexed sender);\n    event QueryRequestCreated(uint64 reqId, address owner);\n    event QueryRequestDeleted(uint64 reqId);\n\n    event QueryExecutionCompleted(uint64 reqId);\n    event QueryExecutionRunning(uint64 reqId, uint64 accSteps, uint64 ttl);\n}\n"
    },
    "contracts/MyConfidentialERC20.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause-Clear\n\npragma solidity ^0.8.24;\n\nimport \"fhevm/lib/TFHE.sol\";\nimport \"fhevm/config/ZamaFHEVMConfig.sol\";\nimport \"fhevm-contracts/contracts/token/ERC20/extensions/ConfidentialERC20Mintable.sol\";\n\n/// @notice This contract implements an encrypted ERC20-like token with confidential balances using Zama's FHE library.\n/// @dev It supports typical ERC20 functionality such as transferring tokens, minting, and setting allowances,\n/// @dev but uses encrypted data types.\ncontract MyConfidentialERC20 is SepoliaZamaFHEVMConfig, ConfidentialERC20Mintable {\n    /// @notice Constructor to initialize the token's name and symbol, and set up the owner\n    /// @param name_ The name of the token\n    /// @param symbol_ The symbol of the token\n    constructor(string memory name_, string memory symbol_) ConfidentialERC20Mintable(name_, symbol_, msg.sender) {}\n}\n"
    },
    "contracts/QuestionSpecLib.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause-Clear\npragma solidity ^0.8.24;\n\nuint16 constant TXT_MAX_LEN = 512;\n\nlibrary QuestionSpecLib {\n    enum QuestionType {\n        Option, // For example 1 - count on the options pollers choose\n        Value // For example 2 - perform min,max,avg on the numeric ans people give\n    }\n\n    struct QuestionSpec {\n        string text;\n        string[] options;\n        uint32 min;\n        uint32 max;\n        QuestionType t;\n    }\n\n    error InvalidQuestionSpecParam(string reason);\n\n    function validate(QuestionSpec memory self) public pure {\n        if (bytes(self.text).length > TXT_MAX_LEN) revert InvalidQuestionSpecParam(\"questionText max length exceeded\");\n        if (self.t == QuestionType.Option && self.options.length < 2)\n            revert InvalidQuestionSpecParam(\"Options should be greater than 1\");\n        if (self.min >= self.max) revert InvalidQuestionSpecParam(\"min should be less than max\");\n    }\n}\n"
    },
    "contracts/TestAsyncDecrypt.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause-Clear\n\npragma solidity ^0.8.24;\n\nimport \"fhevm/lib/TFHE.sol\";\nimport \"fhevm/config/ZamaFHEVMConfig.sol\";\nimport \"fhevm/config/ZamaGatewayConfig.sol\";\nimport \"fhevm/gateway/GatewayCaller.sol\";\n\n/// @notice Contract for testing asynchronous decryption using the Gateway\n/* solhint-disable max-states-count*/\n/* solhint-disable var-name-mixedcase*/\ncontract TestAsyncDecrypt is SepoliaZamaFHEVMConfig, SepoliaZamaGatewayConfig, GatewayCaller {\n    /// @dev Encrypted state variables\n    ebool xBool;\n    euint4 xUint4;\n    euint8 xUint8;\n    euint16 xUint16;\n    euint32 xUint32;\n    euint64 xUint64;\n    euint64 xUint64_2;\n    euint64 xUint64_3;\n    euint128 xUint128;\n    eaddress xAddress;\n    eaddress xAddress2;\n    euint256 xUint256;\n\n    /// @dev Decrypted state variables\n    bool public yBool;\n    uint8 public yUint4;\n    uint8 public yUint8;\n    uint16 public yUint16;\n    uint32 public yUint32;\n    uint64 public yUint64;\n    uint64 public yUint64_2;\n    uint64 public yUint64_3;\n    uint128 public yUint128;\n    address public yAddress;\n    address public yAddress2;\n    uint256 public yUint256;\n    bytes public yBytes64;\n    bytes public yBytes128;\n    bytes public yBytes256;\n\n    /// @dev Tracks the latest decryption request ID\n    uint256 public latestRequestID;\n\n    /// @notice Constructor to initialize the contract and set up encrypted values\n    constructor() {\n        /// @dev Initialize encrypted variables with sample values\n        xBool = TFHE.asEbool(true);\n        TFHE.allowThis(xBool);\n        xUint4 = TFHE.asEuint4(4);\n        TFHE.allowThis(xUint4);\n        xUint8 = TFHE.asEuint8(42);\n        TFHE.allowThis(xUint8);\n        xUint16 = TFHE.asEuint16(16);\n        TFHE.allowThis(xUint16);\n        xUint32 = TFHE.asEuint32(32);\n        TFHE.allowThis(xUint32);\n        xUint64 = TFHE.asEuint64(18446744073709551600);\n        TFHE.allowThis(xUint64);\n        xUint64_2 = TFHE.asEuint64(76575465786);\n        TFHE.allowThis(xUint64_2);\n        xUint64_3 = TFHE.asEuint64(6400);\n        TFHE.allowThis(xUint64_3);\n        xUint128 = TFHE.asEuint128(1267650600228229401496703205443);\n        TFHE.allowThis(xUint128);\n        xUint256 = TFHE.asEuint256(27606985387162255149739023449108101809804435888681546220650096895197251);\n        TFHE.allowThis(xUint256);\n        xAddress = TFHE.asEaddress(0x8ba1f109551bD432803012645Ac136ddd64DBA72);\n        TFHE.allowThis(xAddress);\n        xAddress2 = TFHE.asEaddress(0xf48b8840387ba3809DAE990c930F3b4766A86ca3);\n        TFHE.allowThis(xAddress2);\n    }\n\n    /// @notice Function to request decryption with an excessive delay (should revert)\n    function requestBoolAboveDelay() public {\n        /// @dev This should revert due to the excessive delay\n        uint256[] memory cts = new uint256[](1);\n        cts[0] = Gateway.toUint256(xBool);\n        Gateway.requestDecryption(cts, this.callbackBool.selector, 0, block.timestamp + 2 days, false);\n    }\n\n    /// @notice Request decryption of a boolean value\n    function requestBool() public {\n        uint256[] memory cts = new uint256[](1);\n        cts[0] = Gateway.toUint256(xBool);\n        /// @dev Request decryption with a 100-second deadline and non-trustless mode\n        Gateway.requestDecryption(cts, this.callbackBool.selector, 0, block.timestamp + 100, false);\n    }\n\n    /// @notice Request decryption of a boolean value in trustless mode\n    function requestBoolTrustless() public {\n        uint256[] memory cts = new uint256[](1);\n        cts[0] = Gateway.toUint256(xBool);\n        /// @dev Request decryption with a 100-second deadline and trustless mode (true)\n        uint256 requestID = Gateway.requestDecryption(\n            cts,\n            this.callbackBoolTrustless.selector,\n            0,\n            block.timestamp + 100,\n            true\n        );\n        latestRequestID = requestID;\n        /// @dev Save the requested handles for later verification\n        saveRequestedHandles(requestID, cts);\n    }\n\n    /// @notice Callback function for non-trustless boolean decryption\n    function callbackBool(uint256, bool decryptedInput) public onlyGateway returns (bool) {\n        yBool = decryptedInput;\n        return yBool;\n    }\n\n    /// @notice Callback function for trustless boolean decryption\n    function callbackBoolTrustless(\n        uint256 requestID,\n        bool decryptedInput,\n        bytes[] memory signatures\n    ) public onlyGateway returns (bool) {\n        /// @dev Verify that the requestID matches the latest request\n        require(latestRequestID == requestID, \"wrong requestID passed by Gateway\");\n        /// @dev Load the previously saved handles for verification\n        uint256[] memory requestedHandles = loadRequestedHandles(latestRequestID);\n        /// @dev Verify the signatures provided by the KMS (Key Management Service)\n        bool isKMSVerified = Gateway.verifySignatures(requestedHandles, signatures);\n        require(isKMSVerified, \"KMS did not verify this decryption result\");\n        /// @dev If verification passes, store the decrypted value\n        yBool = decryptedInput;\n        return yBool;\n    }\n\n    /// @notice Request decryption of a 4-bit unsigned integer\n    function requestUint4() public {\n        uint256[] memory cts = new uint256[](1);\n        cts[0] = Gateway.toUint256(xUint4);\n        Gateway.requestDecryption(cts, this.callbackUint4.selector, 0, block.timestamp + 100, false);\n    }\n\n    /// @notice Callback function for 4-bit unsigned integer decryption\n    /// @param decryptedInput The decrypted 4-bit unsigned integer\n    /// @return The decrypted value\n    function callbackUint4(uint256, uint8 decryptedInput) public onlyGateway returns (uint8) {\n        yUint4 = decryptedInput;\n        return decryptedInput;\n    }\n\n    /// @notice Request decryption of an 8-bit unsigned integer\n    function requestUint8() public {\n        uint256[] memory cts = new uint256[](1);\n        cts[0] = Gateway.toUint256(xUint8);\n        Gateway.requestDecryption(cts, this.callbackUint8.selector, 0, block.timestamp + 100, false);\n    }\n\n    /// @notice Callback function for 8-bit unsigned integer decryption\n    /// @param decryptedInput The decrypted 8-bit unsigned integer\n    /// @return The decrypted value\n    function callbackUint8(uint256, uint8 decryptedInput) public onlyGateway returns (uint8) {\n        yUint8 = decryptedInput;\n        return decryptedInput;\n    }\n\n    /// @notice Request decryption of a 16-bit unsigned integer\n    function requestUint16() public {\n        uint256[] memory cts = new uint256[](1);\n        cts[0] = Gateway.toUint256(xUint16);\n        Gateway.requestDecryption(cts, this.callbackUint16.selector, 0, block.timestamp + 100, false);\n    }\n\n    /// @notice Callback function for 16-bit unsigned integer decryption\n    /// @param decryptedInput The decrypted 16-bit unsigned integer\n    /// @return The decrypted value\n    function callbackUint16(uint256, uint16 decryptedInput) public onlyGateway returns (uint16) {\n        yUint16 = decryptedInput;\n        return decryptedInput;\n    }\n\n    /// @notice Request decryption of a 32-bit unsigned integer with additional inputs\n    /// @param input1 First additional input\n    /// @param input2 Second additional input\n    function requestUint32(uint32 input1, uint32 input2) public {\n        uint256[] memory cts = new uint256[](1);\n        cts[0] = Gateway.toUint256(xUint32);\n        uint256 requestID = Gateway.requestDecryption(\n            cts,\n            this.callbackUint32.selector,\n            0,\n            block.timestamp + 100,\n            false\n        );\n        addParamsUint256(requestID, input1);\n        addParamsUint256(requestID, input2);\n    }\n\n    /// @notice Callback function for 32-bit unsigned integer decryption\n    /// @param requestID The ID of the decryption request\n    /// @param decryptedInput The decrypted 32-bit unsigned integer\n    /// @return The result of the computation\n    function callbackUint32(uint256 requestID, uint32 decryptedInput) public onlyGateway returns (uint32) {\n        uint256[] memory params = getParamsUint256(requestID);\n        unchecked {\n            uint32 result = uint32(params[0]) + uint32(params[1]) + decryptedInput;\n            yUint32 = result;\n            return result;\n        }\n    }\n\n    /// @notice Request decryption of a 64-bit unsigned integer\n    function requestUint64() public {\n        uint256[] memory cts = new uint256[](1);\n        cts[0] = Gateway.toUint256(xUint64);\n        Gateway.requestDecryption(cts, this.callbackUint64.selector, 0, block.timestamp + 100, false);\n    }\n\n    /// @notice Request decryption of a non-trivial 64-bit unsigned integer\n    /// @param inputHandle The input handle for the encrypted value\n    /// @param inputProof The input proof for the encrypted value\n    function requestUint64NonTrivial(einput inputHandle, bytes calldata inputProof) public {\n        euint64 inputNonTrivial = TFHE.asEuint64(inputHandle, inputProof);\n        uint256[] memory cts = new uint256[](1);\n        cts[0] = Gateway.toUint256(inputNonTrivial);\n        Gateway.requestDecryption(cts, this.callbackUint64.selector, 0, block.timestamp + 100, false);\n    }\n\n    /// @notice Callback function for 64-bit unsigned integer decryption\n    /// @param decryptedInput The decrypted 64-bit unsigned integer\n    /// @return The decrypted value\n    function callbackUint64(uint256, uint64 decryptedInput) public onlyGateway returns (uint64) {\n        yUint64 = decryptedInput;\n        return decryptedInput;\n    }\n\n    function requestUint128() public {\n        uint256[] memory cts = new uint256[](1);\n        cts[0] = Gateway.toUint256(xUint128);\n        Gateway.requestDecryption(cts, this.callbackUint128.selector, 0, block.timestamp + 100, false);\n    }\n\n    function requestUint128NonTrivial(einput inputHandle, bytes calldata inputProof) public {\n        euint128 inputNonTrivial = TFHE.asEuint128(inputHandle, inputProof);\n        uint256[] memory cts = new uint256[](1);\n        cts[0] = Gateway.toUint256(inputNonTrivial);\n        Gateway.requestDecryption(cts, this.callbackUint128.selector, 0, block.timestamp + 100, false);\n    }\n\n    function callbackUint128(uint256, uint128 decryptedInput) public onlyGateway returns (uint128) {\n        yUint128 = decryptedInput;\n        return decryptedInput;\n    }\n\n    function requestUint256() public {\n        uint256[] memory cts = new uint256[](1);\n        cts[0] = Gateway.toUint256(xUint256);\n        Gateway.requestDecryption(cts, this.callbackUint256.selector, 0, block.timestamp + 100, false);\n    }\n\n    function requestUint256NonTrivial(einput inputHandle, bytes calldata inputProof) public {\n        euint256 inputNonTrivial = TFHE.asEuint256(inputHandle, inputProof);\n        uint256[] memory cts = new uint256[](1);\n        cts[0] = Gateway.toUint256(inputNonTrivial);\n        Gateway.requestDecryption(cts, this.callbackUint256.selector, 0, block.timestamp + 100, false);\n    }\n\n    function callbackUint256(uint256, uint256 decryptedInput) public onlyGateway returns (uint256) {\n        yUint256 = decryptedInput;\n        return decryptedInput;\n    }\n\n    function requestEbytes64NonTrivial(einput inputHandle, bytes calldata inputProof) public {\n        ebytes64 inputNonTrivial = TFHE.asEbytes64(inputHandle, inputProof);\n        uint256[] memory cts = new uint256[](1);\n        cts[0] = Gateway.toUint256(inputNonTrivial);\n        Gateway.requestDecryption(cts, this.callbackBytes64.selector, 0, block.timestamp + 100, false);\n    }\n\n    function requestEbytes64Trivial(bytes calldata value) public {\n        ebytes64 inputTrivial = TFHE.asEbytes64(TFHE.padToBytes64(value));\n        uint256[] memory cts = new uint256[](1);\n        cts[0] = Gateway.toUint256(inputTrivial);\n        Gateway.requestDecryption(cts, this.callbackBytes64.selector, 0, block.timestamp + 100, false);\n    }\n\n    function callbackBytes64(uint256, bytes calldata decryptedInput) public onlyGateway returns (bytes memory) {\n        yBytes64 = decryptedInput;\n        return decryptedInput;\n    }\n\n    function requestEbytes128NonTrivial(einput inputHandle, bytes calldata inputProof) public {\n        ebytes128 inputNonTrivial = TFHE.asEbytes128(inputHandle, inputProof);\n        uint256[] memory cts = new uint256[](1);\n        cts[0] = Gateway.toUint256(inputNonTrivial);\n        Gateway.requestDecryption(cts, this.callbackBytes128.selector, 0, block.timestamp + 100, false);\n    }\n\n    function requestEbytes128Trivial(bytes calldata value) public {\n        ebytes128 inputTrivial = TFHE.asEbytes128(TFHE.padToBytes128(value));\n        uint256[] memory cts = new uint256[](1);\n        cts[0] = Gateway.toUint256(inputTrivial);\n        Gateway.requestDecryption(cts, this.callbackBytes128.selector, 0, block.timestamp + 100, false);\n    }\n\n    function callbackBytes128(uint256, bytes calldata decryptedInput) public onlyGateway returns (bytes memory) {\n        yBytes128 = decryptedInput;\n        return decryptedInput;\n    }\n\n    function requestEbytes256Trivial(bytes calldata value) public {\n        ebytes256 inputTrivial = TFHE.asEbytes256(TFHE.padToBytes256(value));\n        uint256[] memory cts = new uint256[](1);\n        cts[0] = Gateway.toUint256(inputTrivial);\n        Gateway.requestDecryption(cts, this.callbackBytes256.selector, 0, block.timestamp + 100, false);\n    }\n\n    function requestEbytes256NonTrivial(einput inputHandle, bytes calldata inputProof) public {\n        ebytes256 inputNonTrivial = TFHE.asEbytes256(inputHandle, inputProof);\n        uint256[] memory cts = new uint256[](1);\n        cts[0] = Gateway.toUint256(inputNonTrivial);\n        Gateway.requestDecryption(cts, this.callbackBytes256.selector, 0, block.timestamp + 100, false);\n    }\n\n    /// @notice Callback function for 256-bit encrypted bytes decryption\n    /// @param decryptedInput The decrypted 256-bit bytes\n    /// @return The decrypted value\n    function callbackBytes256(uint256, bytes calldata decryptedInput) public onlyGateway returns (bytes memory) {\n        yBytes256 = decryptedInput;\n        return decryptedInput;\n    }\n\n    /// @notice Request decryption of an encrypted address\n    function requestAddress() public {\n        uint256[] memory cts = new uint256[](1);\n        cts[0] = Gateway.toUint256(xAddress);\n        Gateway.requestDecryption(cts, this.callbackAddress.selector, 0, block.timestamp + 100, false);\n    }\n\n    /// @notice Request decryption of multiple encrypted addresses\n    function requestSeveralAddresses() public {\n        uint256[] memory cts = new uint256[](2);\n        cts[0] = Gateway.toUint256(xAddress);\n        cts[1] = Gateway.toUint256(xAddress2);\n        Gateway.requestDecryption(cts, this.callbackAddresses.selector, 0, block.timestamp + 100, false);\n    }\n\n    /// @notice Callback function for multiple address decryption\n    /// @param decryptedInput1 The first decrypted address\n    /// @param decryptedInput2 The second decrypted address\n    /// @return The first decrypted address\n    function callbackAddresses(\n        uint256 /*requestID*/,\n        address decryptedInput1,\n        address decryptedInput2\n    ) public onlyGateway returns (address) {\n        yAddress = decryptedInput1;\n        yAddress2 = decryptedInput2;\n        return decryptedInput1;\n    }\n\n    /// @notice Callback function for address decryption\n    /// @param decryptedInput The decrypted address\n    /// @return The decrypted address\n    function callbackAddress(uint256, address decryptedInput) public onlyGateway returns (address) {\n        yAddress = decryptedInput;\n        return decryptedInput;\n    }\n\n    /// @notice Request decryption of multiple encrypted data types\n    /// @dev This function demonstrates how to request decryption for various encrypted data types in a single call\n    /// @param input1 First additional input parameter for the callback function\n    /// @param input2 Second additional input parameter for the callback function\n    function requestMixed(uint32 input1, uint32 input2) public {\n        uint256[] memory cts = new uint256[](10);\n        cts[0] = Gateway.toUint256(xBool);\n        cts[1] = Gateway.toUint256(xBool);\n        cts[2] = Gateway.toUint256(xUint4);\n        cts[3] = Gateway.toUint256(xUint8);\n        cts[4] = Gateway.toUint256(xUint16);\n        cts[5] = Gateway.toUint256(xUint32);\n        cts[6] = Gateway.toUint256(xUint64);\n        cts[7] = Gateway.toUint256(xUint64);\n        cts[8] = Gateway.toUint256(xUint64);\n        cts[9] = Gateway.toUint256(xAddress);\n        uint256 requestID = Gateway.requestDecryption(\n            cts,\n            this.callbackMixed.selector,\n            0,\n            block.timestamp + 100,\n            false\n        );\n        addParamsUint256(requestID, input1);\n        addParamsUint256(requestID, input2);\n    }\n\n    /// @notice Callback function for mixed data type decryption\n    /// @dev Processes the decrypted values and performs some basic checks\n    /// @param requestID The ID of the decryption request\n    /// @param decBool_1 First decrypted boolean\n    /// @param decBool_2 Second decrypted boolean\n    /// @param decUint4 Decrypted 4-bit unsigned integer\n    /// @param decUint8 Decrypted 8-bit unsigned integer\n    /// @param decUint16 Decrypted 16-bit unsigned integer\n    /// @param decUint32 Decrypted 32-bit unsigned integer\n    /// @param decUint64_1 First decrypted 64-bit unsigned integer\n    /// @param decUint64_2 Second decrypted 64-bit unsigned integer\n    /// @param decUint64_3 Third decrypted 64-bit unsigned integer\n    /// @param decAddress Decrypted address\n    /// @return The decrypted 4-bit unsigned integer\n    function callbackMixed(\n        uint256 requestID,\n        bool decBool_1,\n        bool decBool_2,\n        uint8 decUint4,\n        uint8 decUint8,\n        uint16 decUint16,\n        uint32 decUint32,\n        uint64 decUint64_1,\n        uint64 decUint64_2,\n        uint64 decUint64_3,\n        address decAddress\n    ) public onlyGateway returns (uint8) {\n        yBool = decBool_1;\n        require(decBool_1 == decBool_2, \"Wrong decryption\");\n        yUint4 = decUint4;\n        yUint8 = decUint8;\n        yUint16 = decUint16;\n        uint256[] memory params = getParamsUint256(requestID);\n        unchecked {\n            uint32 result = uint32(params[0]) + uint32(params[1]) + decUint32;\n            yUint32 = result;\n        }\n        yUint64 = decUint64_1;\n        require(decUint64_1 == decUint64_2 && decUint64_2 == decUint64_3, \"Wrong decryption\");\n        yAddress = decAddress;\n        return yUint4;\n    }\n\n    /// @notice Request decryption of mixed data types including 256-bit encrypted bytes\n    /// @dev Demonstrates how to include encrypted bytes256 in a mixed decryption request\n    /// @param inputHandle The encrypted input handle for the bytes256\n    /// @param inputProof The proof for the encrypted bytes256\n    function requestMixedBytes256(einput inputHandle, bytes calldata inputProof) public {\n        ebytes256 xBytes256 = TFHE.asEbytes256(inputHandle, inputProof);\n        uint256[] memory cts = new uint256[](4);\n        cts[0] = Gateway.toUint256(xBool);\n        cts[1] = Gateway.toUint256(xAddress);\n        cts[2] = Gateway.toUint256(xBytes256);\n        ebytes64 input64Bytes = TFHE.asEbytes64(TFHE.padToBytes64(hex\"aaff42\"));\n        cts[3] = Gateway.toUint256(input64Bytes);\n        Gateway.requestDecryption(cts, this.callbackMixedBytes256.selector, 0, block.timestamp + 100, false);\n    }\n\n    /// @notice Callback function for mixed data type decryption including 256-bit encrypted bytes\n    /// @dev Processes and stores the decrypted values\n    /// @param decBool Decrypted boolean\n    /// @param decAddress Decrypted address\n    /// @param bytesRes Decrypted 256-bit bytes\n    function callbackMixedBytes256(\n        uint256,\n        bool decBool,\n        address decAddress,\n        bytes memory bytesRes,\n        bytes memory bytesRes2\n    ) public onlyGateway {\n        yBool = decBool;\n        yAddress = decAddress;\n        yBytes256 = bytesRes;\n        yBytes64 = bytesRes2;\n    }\n\n    /// @notice Request trustless decryption of non-trivial 256-bit encrypted bytes\n    /// @dev Demonstrates how to request trustless decryption for complex encrypted bytes256\n    /// @param inputHandle The encrypted input handle for the bytes256\n    /// @param inputProof The proof for the encrypted bytes256\n    function requestEbytes256NonTrivialTrustless(einput inputHandle, bytes calldata inputProof) public {\n        ebytes256 inputNonTrivial = TFHE.asEbytes256(inputHandle, inputProof);\n        uint256[] memory cts = new uint256[](1);\n        cts[0] = Gateway.toUint256(inputNonTrivial);\n        uint256 requestID = Gateway.requestDecryption(\n            cts,\n            this.callbackBytes256Trustless.selector,\n            0,\n            block.timestamp + 100,\n            true\n        );\n        latestRequestID = requestID;\n        saveRequestedHandles(requestID, cts);\n    }\n\n    /// @notice Callback function for trustless decryption of 256-bit encrypted bytes\n    /// @dev Verifies the decryption result using KMS signatures\n    /// @param requestID The ID of the decryption request\n    /// @param decryptedInput The decrypted bytes256 value\n    /// @param signatures The signatures from the KMS for verification\n    /// @return The decrypted bytes256 value\n    function callbackBytes256Trustless(\n        uint256 requestID,\n        bytes calldata decryptedInput,\n        bytes[] memory signatures\n    ) public onlyGateway returns (bytes memory) {\n        require(latestRequestID == requestID, \"wrong requestID passed by Gateway\");\n        uint256[] memory requestedHandles = loadRequestedHandles(latestRequestID);\n        bool isKMSVerified = Gateway.verifySignatures(requestedHandles, signatures);\n        require(isKMSVerified, \"KMS did not verify this decryption result\");\n        yBytes256 = decryptedInput;\n        return decryptedInput;\n    }\n\n    /// @notice Request trustless decryption of mixed data types including 256-bit encrypted bytes\n    /// @dev Demonstrates how to request trustless decryption for multiple data types\n    /// @param inputHandle The encrypted input handle for the bytes256\n    /// @param inputProof The proof for the encrypted bytes256\n    function requestMixedBytes256Trustless(einput inputHandle, bytes calldata inputProof) public {\n        ebytes256 xBytes256 = TFHE.asEbytes256(inputHandle, inputProof);\n        uint256[] memory cts = new uint256[](3);\n        cts[0] = Gateway.toUint256(xBool);\n        cts[1] = Gateway.toUint256(xBytes256);\n        cts[2] = Gateway.toUint256(xAddress);\n        uint256 requestID = Gateway.requestDecryption(\n            cts,\n            this.callbackMixedBytes256Trustless.selector,\n            0,\n            block.timestamp + 100,\n            true\n        );\n        latestRequestID = requestID;\n        saveRequestedHandles(requestID, cts);\n    }\n\n    /// @notice Callback function for trustless decryption of mixed data types including 256-bit encrypted bytes\n    /// @dev Verifies and processes the decrypted values\n    /// @param requestID The ID of the decryption request\n    /// @param decBool Decrypted boolean\n    /// @param bytesRes Decrypted 256-bit bytes\n    /// @param decAddress Decrypted address\n    /// @param signatures The signatures from the KMS for verification\n    function callbackMixedBytes256Trustless(\n        uint256 requestID,\n        bool decBool,\n        bytes memory bytesRes,\n        address decAddress,\n        bytes[] memory signatures\n    ) public onlyGateway {\n        require(latestRequestID == requestID, \"wrong requestID passed by Gateway\");\n        uint256[] memory requestedHandles = loadRequestedHandles(latestRequestID);\n        bool isKMSVerified = Gateway.verifySignatures(requestedHandles, signatures);\n        require(isKMSVerified, \"KMS did not verify this decryption result\");\n        yBool = decBool;\n        yAddress = decAddress;\n        yBytes256 = bytesRes;\n    }\n}\n"
    },
    "fhevm-contracts/contracts/token/ERC20/ConfidentialERC20.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause-Clear\npragma solidity ^0.8.24;\n\nimport \"fhevm/lib/TFHE.sol\";\n\nimport { IERC20Errors } from \"@openzeppelin/contracts/interfaces/draft-IERC6093.sol\";\nimport { IConfidentialERC20 } from \"./IConfidentialERC20.sol\";\nimport { TFHEErrors } from \"../../utils/TFHEErrors.sol\";\n\n/**\n * @title       ConfidentialERC20\n * @notice      This contract implements an encrypted ERC20-like token with confidential balances using\n *              Zama's FHE (Fully Homomorphic Encryption) library.\n * @dev         It supports standard ERC20 functions such as transferring tokens, minting,\n *              and setting allowances, but uses encrypted data types.\n *              The total supply is not encrypted.\n */\nabstract contract ConfidentialERC20 is IConfidentialERC20, IERC20Errors, TFHEErrors {\n    /// @notice Used as a placeholder in `Approval` & `Transfer` events to comply with the official EIP20.\n    uint256 internal constant _PLACEHOLDER = type(uint256).max;\n    /// @notice Total supply.\n    uint64 internal _totalSupply;\n\n    /// @notice Name.\n    string internal _name;\n\n    /// @notice Symbol.\n    string internal _symbol;\n\n    /// @notice A mapping from `account` address to an encrypted `balance`.\n    mapping(address account => euint64 balance) internal _balances;\n\n    /// @notice A mapping of the form mapping(account => mapping(spender => allowance)).\n    mapping(address account => mapping(address spender => euint64 allowance)) internal _allowances;\n\n    /**\n     * @param name_     Name of the token.\n     * @param symbol_   Symbol.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @notice See {IConfidentialERC20-approve}.\n     */\n    function approve(address spender, einput encryptedAmount, bytes calldata inputProof) public virtual returns (bool) {\n        approve(spender, TFHE.asEuint64(encryptedAmount, inputProof));\n        return true;\n    }\n\n    /**\n     * @notice See {IConfidentialERC20-approve}.\n     */\n    function approve(address spender, euint64 amount) public virtual returns (bool) {\n        _isSenderAllowedForAmount(amount);\n        address owner = msg.sender;\n        _approve(owner, spender, amount);\n        emit Approval(owner, spender, _PLACEHOLDER);\n        return true;\n    }\n\n    /**\n     * @notice See {IConfidentialERC20-transfer}.\n     */\n    function transfer(address to, einput encryptedAmount, bytes calldata inputProof) public virtual returns (bool) {\n        transfer(to, TFHE.asEuint64(encryptedAmount, inputProof));\n        return true;\n    }\n\n    /**\n     * @notice See {IConfidentialERC20-transfer}.\n     */\n    function transfer(address to, euint64 amount) public virtual returns (bool) {\n        _isSenderAllowedForAmount(amount);\n\n        /// @dev Make sure the owner has enough tokens.\n        ebool canTransfer = TFHE.le(amount, _balances[msg.sender]);\n        _transfer(msg.sender, to, amount, canTransfer);\n        return true;\n    }\n\n    /**\n     * @notice See {IConfidentialERC20-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        einput encryptedAmount,\n        bytes calldata inputProof\n    ) public virtual returns (bool) {\n        transferFrom(from, to, TFHE.asEuint64(encryptedAmount, inputProof));\n        return true;\n    }\n\n    /**\n     * @notice See {IConfidentialERC20-transferFrom}.\n     */\n    function transferFrom(address from, address to, euint64 amount) public virtual returns (bool) {\n        _isSenderAllowedForAmount(amount);\n        address spender = msg.sender;\n        ebool isTransferable = _updateAllowance(from, spender, amount);\n        _transfer(from, to, amount, isTransferable);\n        return true;\n    }\n\n    /**\n     * @notice See {IConfidentialERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual returns (euint64) {\n        return _allowance(owner, spender);\n    }\n\n    /**\n     * @notice See {IConfidentialERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual returns (euint64) {\n        return _balances[account];\n    }\n\n    /**\n     * @notice See {IConfidentialERC20-decimals}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return 6;\n    }\n\n    /**\n     * @notice See {IConfidentialERC20-name}.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @notice See {IConfidentialERC20-symbol}.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @notice See {IConfidentialERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual returns (uint64) {\n        return _totalSupply;\n    }\n\n    function _approve(address owner, address spender, euint64 amount) internal virtual {\n        if (owner == address(0)) {\n            revert ERC20InvalidApprover(owner);\n        }\n\n        if (spender == address(0)) {\n            revert ERC20InvalidSpender(spender);\n        }\n\n        _allowances[owner][spender] = amount;\n        TFHE.allowThis(amount);\n        TFHE.allow(amount, owner);\n        TFHE.allow(amount, spender);\n    }\n\n    /**\n     * @dev It does not incorporate any overflow check. It must be implemented\n     *      by the function calling it.\n     */\n    function _unsafeMint(address account, uint64 amount) internal virtual {\n        _unsafeMintNoEvent(account, amount);\n        emit Transfer(address(0), account, _PLACEHOLDER);\n    }\n\n    /**\n     * @dev It does not incorporate any overflow check. It must be implemented\n     *      by the function calling it.\n     */\n    function _unsafeMintNoEvent(address account, uint64 amount) internal virtual {\n        euint64 newBalanceAccount = TFHE.add(_balances[account], amount);\n        _balances[account] = newBalanceAccount;\n        TFHE.allowThis(newBalanceAccount);\n        TFHE.allow(newBalanceAccount, account);\n    }\n\n    function _transfer(address from, address to, euint64 amount, ebool isTransferable) internal virtual {\n        _transferNoEvent(from, to, amount, isTransferable);\n        emit Transfer(from, to, _PLACEHOLDER);\n    }\n\n    function _transferNoEvent(address from, address to, euint64 amount, ebool isTransferable) internal virtual {\n        if (from == address(0)) {\n            revert ERC20InvalidSender(from);\n        }\n\n        if (to == address(0)) {\n            revert ERC20InvalidReceiver(to);\n        }\n\n        /// @dev Add to the balance of `to` and subtract from the balance of `from`.\n        euint64 transferValue = TFHE.select(isTransferable, amount, TFHE.asEuint64(0));\n        euint64 newBalanceTo = TFHE.add(_balances[to], transferValue);\n        _balances[to] = newBalanceTo;\n        TFHE.allowThis(newBalanceTo);\n        TFHE.allow(newBalanceTo, to);\n        euint64 newBalanceFrom = TFHE.sub(_balances[from], transferValue);\n        _balances[from] = newBalanceFrom;\n        TFHE.allowThis(newBalanceFrom);\n        TFHE.allow(newBalanceFrom, from);\n    }\n\n    function _updateAllowance(address owner, address spender, euint64 amount) internal virtual returns (ebool) {\n        euint64 currentAllowance = _allowance(owner, spender);\n        /// @dev Make sure sure the allowance suffices.\n        ebool allowedTransfer = TFHE.le(amount, currentAllowance);\n        /// @dev Make sure the owner has enough tokens.\n        ebool canTransfer = TFHE.le(amount, _balances[owner]);\n        ebool isTransferable = TFHE.and(canTransfer, allowedTransfer);\n        _approve(owner, spender, TFHE.select(isTransferable, TFHE.sub(currentAllowance, amount), currentAllowance));\n        return isTransferable;\n    }\n\n    function _allowance(address owner, address spender) internal view virtual returns (euint64) {\n        return _allowances[owner][spender];\n    }\n\n    function _isSenderAllowedForAmount(euint64 amount) internal view virtual {\n        if (!TFHE.isSenderAllowed(amount)) {\n            revert TFHESenderNotAllowed();\n        }\n    }\n}\n"
    },
    "fhevm-contracts/contracts/token/ERC20/extensions/ConfidentialERC20Mintable.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause-Clear\npragma solidity ^0.8.24;\n\nimport \"fhevm/lib/TFHE.sol\";\nimport { Ownable2Step, Ownable } from \"@openzeppelin/contracts/access/Ownable2Step.sol\";\n\nimport { ConfidentialERC20 } from \"../ConfidentialERC20.sol\";\n\n/**\n * @title       ConfidentialERC20Mintable\n * @notice      This contract inherits ConfidentialERC20.\n * @dev         It allows an owner to mint tokens. Mint amounts are public.\n */\nabstract contract ConfidentialERC20Mintable is Ownable2Step, ConfidentialERC20 {\n    /**\n     * @notice Emitted when `amount` tokens are minted to one account (`to`).\n     */\n    event Mint(address indexed to, uint64 amount);\n\n    /**\n     * @param name_     Name of the token.\n     * @param symbol_   Symbol.\n     * @param owner_    Owner address.\n     */\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        address owner_\n    ) Ownable(owner_) ConfidentialERC20(name_, symbol_) {}\n\n    /**\n     * @notice          Mint tokens.\n     * @param to        Address to mint tokens to.\n     * @param amount    Amount of tokens to mint.\n     */\n    function mint(address to, uint64 amount) public virtual onlyOwner {\n        _unsafeMint(to, amount);\n        /// @dev Since _totalSupply is not encrypted and we ensure there is no underflow/overflow of encrypted balances\n        /// during transfers, making _totalSupply invariant during transfers, we know _totalSupply is greater than\n        /// all individual balances. Hence, the next line forbids any overflow to happen in the _unsafeMint above.\n        _totalSupply = _totalSupply + amount;\n        emit Mint(to, amount);\n    }\n}\n"
    },
    "fhevm-contracts/contracts/token/ERC20/IConfidentialERC20.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause-Clear\npragma solidity ^0.8.24;\n\nimport \"fhevm/lib/TFHE.sol\";\n\n/**\n * @title       IConfidentialERC20\n * @notice      Interface that defines ERC20-like tokens with encrypted balances.\n */\ninterface IConfidentialERC20 {\n    /**\n     * @notice Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 placeholder);\n\n    /**\n     * @notice Emitted when tokens are moved from one account (`from`) to\n     * another (`to`).\n     * Last argument is either a default placeholder, typically equal to max(uint256), in case of\n     * a ConfidentialERC20 without error handling, or an errorId in case of encrypted error handling.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 errorId);\n\n    /**\n     * @notice Sets the `encryptedAmount` as the allowance of `spender` over the caller's tokens.\n     */\n    function approve(address spender, einput encryptedAmount, bytes calldata inputProof) external returns (bool);\n\n    /**\n     * @notice Sets the `amount` as the allowance of `spender` over the caller's tokens.\n     */\n    function approve(address spender, euint64 amount) external returns (bool);\n\n    /**\n     * @notice Transfers an encrypted amount from the message sender address to the `to` address.\n     */\n    function transfer(address to, einput encryptedAmount, bytes calldata inputProof) external returns (bool);\n\n    /**\n     * @notice Transfers an amount from the message sender address to the `to` address.\n     */\n    function transfer(address to, euint64 amount) external returns (bool);\n\n    /**\n     * @notice Transfers `amount` tokens using the caller's allowance.\n     */\n    function transferFrom(address from, address to, euint64 amount) external returns (bool);\n\n    /**\n     * @notice Transfers `encryptedAmount` tokens using the caller's allowance.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        einput encryptedAmount,\n        bytes calldata inputProof\n    ) external returns (bool);\n\n    /**\n     * @notice Returns the remaining number of tokens that `spender` is allowed to spend\n               on behalf of the caller.\n     */\n    function allowance(address owner, address spender) external view returns (euint64);\n\n    /**\n     * @notice Returns the balance handle of the caller.\n     */\n    function balanceOf(address wallet) external view returns (euint64);\n\n    /**\n     * @notice Returns the number of decimals.\n     */\n    function decimals() external view returns (uint8);\n\n    /**\n     * @notice Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @notice Returns the symbol of the token, usually a shorter version of the name.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @notice Returns the total supply of the token.\n     */\n    function totalSupply() external view returns (uint64);\n}\n"
    },
    "fhevm-contracts/contracts/utils/TFHEErrors.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause-Clear\npragma solidity ^0.8.24;\n\ninterface TFHEErrors {\n    /**\n     * @notice Returned when the `sender` is not allowed to access a value.\n     */\n    error TFHESenderNotAllowed();\n}\n"
    },
    "fhevm/config/ZamaFHEVMConfig.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause-Clear\npragma solidity ^0.8.24;\n\nimport {TFHE} from \"../lib/TFHE.sol\";\nimport {FHEVMConfigStruct} from \"../lib/Impl.sol\";\n\n/**\n * @title   ZamaFHEVMConfig.\n * @notice  This library returns the TFHE config for different networks\n *          with the contract addresses for\n *          (1) ACL, (2) TFHEExecutor, (3) FHEPayment, (4) KMSVerifier,\n *          which are deployed & maintained by Zama.\n */\nlibrary ZamaFHEVMConfig {\n    function getSepoliaConfig() internal pure returns (FHEVMConfigStruct memory) {\n        return\n            FHEVMConfigStruct({\n                ACLAddress: 0xFee8407e2f5e3Ee68ad77cAE98c434e637f516e5,\n                TFHEExecutorAddress: 0x687408aB54661ba0b4aeF3a44156c616c6955E07,\n                FHEPaymentAddress: 0xFb03BE574d14C256D56F09a198B586bdfc0A9de2,\n                KMSVerifierAddress: 0x9D6891A6240D6130c54ae243d8005063D05fE14b\n            });\n    }\n\n    function getEthereumConfig() internal pure returns (FHEVMConfigStruct memory) {\n        /// TODO\n    }\n}\n\n/**\n * @title   SepoliaZamaFHEVMConfig.\n * @dev     This contract can be inherited by a contract wishing to use the FHEVM contracts provided by Zama\n *          on the Sepolia network (chainId = 11155111).\n *          Other providers may offer similar contracts deployed at different addresses.\n *          If you wish to use them, you should rely on the instructions from these providers.\n */\ncontract SepoliaZamaFHEVMConfig {\n    constructor() {\n        TFHE.setFHEVM(ZamaFHEVMConfig.getSepoliaConfig());\n    }\n}\n\n/**\n * @title   EthereumZamaFHEVMConfig.\n * @dev     This contract can be inherited by a contract wishing to use the FHEVM contracts provided by Zama\n *          on the Ethereum (mainnet) network (chainId = 1).\n *          Other providers may offer similar contracts deployed at different addresses.\n *          If you wish to use them, you should rely on the instructions from these providers.\n */\ncontract EthereumZamaFHEVMConfig {\n    constructor() {\n        TFHE.setFHEVM(ZamaFHEVMConfig.getEthereumConfig());\n    }\n}\n"
    },
    "fhevm/config/ZamaGatewayConfig.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause-Clear\npragma solidity ^0.8.24;\n\nimport {Gateway} from \"../gateway/lib/Gateway.sol\";\n\n/**\n * @title   ZamaGatewayConfig.\n * @notice  This library returns the Gateway config for different networks\n *          with the address of the Gateway contract, which is\n *          deployed & maintained by Zama.\n */\nlibrary ZamaGatewayConfig {\n    function getSepoliaConfig() internal pure returns (address) {\n        return 0x33347831500F1e73f0ccCBb95c9f86B94d7b1123;\n    }\n\n    function getEthereumConfig() internal pure returns (address) {\n        /// TODO\n    }\n}\n\n/**\n * @title   SepoliaZamaGatewayConfig\n * @dev     This contract can be inherited by a contract wishing to use the Gateway service\n *          provided by Zama on the Sepolia network (chainId = 11155111).\n *          Other providers may offer other Gateways that are deployed at different addresses.\n *          If you wish to use them, you should rely on the instructions from these providers.\n */\ncontract SepoliaZamaGatewayConfig {\n    constructor() {\n        Gateway.setGateway(ZamaGatewayConfig.getSepoliaConfig());\n    }\n}\n\n/**\n * @title   EthereumZamaGatewayConfig\n * @dev     This contract can be inherited by a contract wishing to use the Gateway service\n *          provided by Zama on the Ethereum (mainnet) network (chainId = 1).\n *          Other providers may offer other Gateways that are deployed at different addresses.\n *          If you wish to use them, you should rely on the instructions from these providers.\n */\ncontract EthereumZamaGatewayConfig {\n    constructor() {\n        Gateway.setGateway(ZamaGatewayConfig.getEthereumConfig());\n    }\n}\n"
    },
    "fhevm/gateway/GatewayCaller.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause-Clear\n\npragma solidity ^0.8.24;\n\nimport \"../lib/TFHE.sol\";\nimport \"./lib/Gateway.sol\";\n\nabstract contract GatewayCaller {\n    modifier onlyGateway() {\n        require(msg.sender == Gateway.gatewayContractAddress());\n        _;\n    }\n    mapping(uint256 => ebool[]) private paramsEBool;\n    mapping(uint256 => euint4[]) private paramsEUint4;\n    mapping(uint256 => euint8[]) private paramsEUint8;\n    mapping(uint256 => euint16[]) private paramsEUint16;\n    mapping(uint256 => euint32[]) private paramsEUint32;\n    mapping(uint256 => euint64[]) private paramsEUint64;\n    mapping(uint256 => eaddress[]) private paramsEAddress;\n    mapping(uint256 => address[]) private paramsAddress;\n    mapping(uint256 => uint256[]) private paramsUint256;\n    mapping(uint256 => uint256[]) private requestedHandles;\n\n    constructor() {}\n\n    function addParamsEBool(uint256 requestID, ebool _ebool) internal {\n        paramsEBool[requestID].push(_ebool);\n    }\n\n    function addParamsEUint4(uint256 requestID, euint4 _euint4) internal {\n        paramsEUint4[requestID].push(_euint4);\n    }\n\n    function addParamsEUint8(uint256 requestID, euint8 _euint8) internal {\n        paramsEUint8[requestID].push(_euint8);\n    }\n\n    function addParamsEUint16(uint256 requestID, euint16 _euint16) internal {\n        paramsEUint16[requestID].push(_euint16);\n    }\n\n    function addParamsEUint32(uint256 requestID, euint32 _euint32) internal {\n        paramsEUint32[requestID].push(_euint32);\n    }\n\n    function addParamsEUint64(uint256 requestID, euint64 _euint64) internal {\n        paramsEUint64[requestID].push(_euint64);\n    }\n\n    function addParamsEAddress(uint256 requestID, eaddress _eaddress) internal {\n        paramsEAddress[requestID].push(_eaddress);\n    }\n\n    function addParamsAddress(uint256 requestID, address _address) internal {\n        paramsAddress[requestID].push(_address);\n    }\n\n    function addParamsUint256(uint256 requestID, uint256 _uint) internal {\n        paramsUint256[requestID].push(_uint);\n    }\n\n    function saveRequestedHandles(uint256 requestID, uint256[] memory handlesList) internal {\n        require(requestedHandles[requestID].length == 0, \"requested handles already saved\");\n        requestedHandles[requestID] = handlesList;\n    }\n\n    function loadRequestedHandles(uint256 requestID) internal view returns (uint256[] memory) {\n        require(requestedHandles[requestID].length != 0, \"requested handles were not saved for this requestID\");\n        return requestedHandles[requestID];\n    }\n\n    function getParamsEBool(uint256 requestID) internal view returns (ebool[] memory) {\n        return paramsEBool[requestID];\n    }\n\n    function getParamsEUint4(uint256 requestID) internal view returns (euint4[] memory) {\n        return paramsEUint4[requestID];\n    }\n\n    function getParamsEUint8(uint256 requestID) internal view returns (euint8[] memory) {\n        return paramsEUint8[requestID];\n    }\n\n    function getParamsEUint16(uint256 requestID) internal view returns (euint16[] memory) {\n        return paramsEUint16[requestID];\n    }\n\n    function getParamsEUint32(uint256 requestID) internal view returns (euint32[] memory) {\n        return paramsEUint32[requestID];\n    }\n\n    function getParamsEUint64(uint256 requestID) internal view returns (euint64[] memory) {\n        return paramsEUint64[requestID];\n    }\n\n    function getParamsEAddress(uint256 requestID) internal view returns (eaddress[] memory) {\n        return paramsEAddress[requestID];\n    }\n\n    function getParamsAddress(uint256 requestID) internal view returns (address[] memory) {\n        return paramsAddress[requestID];\n    }\n\n    function getParamsUint256(uint256 requestID) internal view returns (uint256[] memory) {\n        return paramsUint256[requestID];\n    }\n}\n"
    },
    "fhevm/gateway/lib/Gateway.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause-Clear\n\npragma solidity ^0.8.24;\n\nimport \"../../lib/Impl.sol\";\n\ninterface IKMSVerifier {\n    function verifyDecryptionEIP712KMSSignatures(\n        address aclAddress,\n        uint256[] memory handlesList,\n        bytes memory decryptedResult,\n        bytes[] memory signatures\n    ) external returns (bool);\n}\n\ninterface IGatewayContract {\n    function requestDecryption(\n        uint256[] calldata ctsHandles,\n        bytes4 callbackSelector,\n        uint256 msgValue,\n        uint256 maxTimestamp,\n        bool passSignaturesToCaller\n    ) external returns (uint256);\n}\n\nstruct GatewayConfigStruct {\n    address GatewayContractAddress;\n}\n\nlibrary Gateway {\n    // keccak256(abi.encode(uint256(keccak256(\"fhevm.storage.GatewayConfig\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant GatewayLocation = 0x93ab6e17f2c461cce6ea5d4ec117e51dda77a64affc2b2c05f8cd440def0e700;\n\n    function getGetwayConfig() internal pure returns (GatewayConfigStruct storage $) {\n        assembly {\n            $.slot := GatewayLocation\n        }\n    }\n\n    function setGateway(address gatewayAddress) internal {\n        GatewayConfigStruct storage $ = getGetwayConfig();\n        $.GatewayContractAddress = gatewayAddress;\n    }\n\n    function gatewayContractAddress() internal view returns (address) {\n        GatewayConfigStruct storage $ = getGetwayConfig();\n        return $.GatewayContractAddress;\n    }\n\n    function toUint256(ebool newCT) internal pure returns (uint256 ct) {\n        ct = ebool.unwrap(newCT);\n    }\n\n    function toUint256(euint4 newCT) internal pure returns (uint256 ct) {\n        ct = euint4.unwrap(newCT);\n    }\n\n    function toUint256(euint8 newCT) internal pure returns (uint256 ct) {\n        ct = euint8.unwrap(newCT);\n    }\n\n    function toUint256(euint16 newCT) internal pure returns (uint256 ct) {\n        ct = euint16.unwrap(newCT);\n    }\n\n    function toUint256(euint32 newCT) internal pure returns (uint256 ct) {\n        ct = euint32.unwrap(newCT);\n    }\n\n    function toUint256(euint64 newCT) internal pure returns (uint256 ct) {\n        ct = euint64.unwrap(newCT);\n    }\n\n    function toUint256(euint128 newCT) internal pure returns (uint256 ct) {\n        ct = euint128.unwrap(newCT);\n    }\n\n    function toUint256(eaddress newCT) internal pure returns (uint256 ct) {\n        ct = eaddress.unwrap(newCT);\n    }\n\n    function toUint256(euint256 newCT) internal pure returns (uint256 ct) {\n        ct = euint256.unwrap(newCT);\n    }\n\n    function toUint256(ebytes64 newCT) internal pure returns (uint256 ct) {\n        ct = ebytes64.unwrap(newCT);\n    }\n\n    function toUint256(ebytes128 newCT) internal pure returns (uint256 ct) {\n        ct = ebytes128.unwrap(newCT);\n    }\n\n    function toUint256(ebytes256 newCT) internal pure returns (uint256 ct) {\n        ct = ebytes256.unwrap(newCT);\n    }\n\n    function requestDecryption(\n        uint256[] memory ctsHandles,\n        bytes4 callbackSelector,\n        uint256 msgValue,\n        uint256 maxTimestamp,\n        bool passSignaturesToCaller\n    ) internal returns (uint256 requestID) {\n        FHEVMConfigStruct storage $ = Impl.getFHEVMConfig();\n        IACL($.ACLAddress).allowForDecryption(ctsHandles);\n        GatewayConfigStruct storage $$ = getGetwayConfig();\n        requestID = IGatewayContract($$.GatewayContractAddress).requestDecryption(\n            ctsHandles,\n            callbackSelector,\n            msgValue,\n            maxTimestamp,\n            passSignaturesToCaller\n        );\n    }\n\n    /// @dev this function is supposed to be called inside the callback function if the dev wants the dApp contract to verify the signatures\n    /// @dev this is useful to give dev the choice not to rely on trusting the GatewayContract.\n    /// @notice this could be used only when signatures are made available to the callback, i.e when `passSignaturesToCaller` is set to true during request\n    function verifySignatures(uint256[] memory handlesList, bytes[] memory signatures) internal returns (bool) {\n        uint256 start = 4 + 32; // start position after skipping the selector (4 bytes) and the first argument (index, 32 bytes)\n        uint256 length = getSignedDataLength(handlesList);\n        bytes memory decryptedResult = new bytes(length);\n        assembly {\n            calldatacopy(add(decryptedResult, 0x20), start, length) // Copy the relevant part of calldata to decryptedResult memory\n        }\n        decryptedResult = shiftOffsets(decryptedResult, handlesList);\n        FHEVMConfigStruct storage $ = Impl.getFHEVMConfig();\n        return\n            IKMSVerifier($.KMSVerifierAddress).verifyDecryptionEIP712KMSSignatures(\n                $.ACLAddress,\n                handlesList,\n                decryptedResult,\n                signatures\n            );\n    }\n\n    function getSignedDataLength(uint256[] memory handlesList) private pure returns (uint256) {\n        uint256 handlesListlen = handlesList.length;\n        uint256 signedDataLength;\n        for (uint256 i = 0; i < handlesListlen; i++) {\n            uint8 typeCt = uint8(handlesList[i] >> 8);\n            if (typeCt < 9) {\n                signedDataLength += 32;\n            } else if (typeCt == 9) {\n                //ebytes64\n                signedDataLength += 128;\n            } else if (typeCt == 10) {\n                //ebytes128\n                signedDataLength += 192;\n            } else if (typeCt == 11) {\n                //ebytes256\n                signedDataLength += 320;\n            } else {\n                revert(\"Unsupported handle type\");\n            }\n        }\n        signedDataLength += 32; // add offset of signatures\n        return signedDataLength;\n    }\n\n    function shiftOffsets(bytes memory input, uint256[] memory handlesList) private pure returns (bytes memory) {\n        uint256 numArgs = handlesList.length;\n        for (uint256 i = 0; i < numArgs; i++) {\n            uint8 typeCt = uint8(handlesList[i] >> 8);\n            if (typeCt >= 9) {\n                input = subToBytes32Slice(input, 32 * i); // because we append the signatures, all bytes offsets are shifted by 0x20\n            }\n        }\n        input = remove32Slice(input, 32 * numArgs);\n        return input;\n    }\n\n    function subToBytes32Slice(bytes memory data, uint256 offset) private pure returns (bytes memory) {\n        // @note: data is assumed to be more than 32+offset bytes long\n        assembly {\n            let ptr := add(add(data, 0x20), offset)\n            let val := mload(ptr)\n            val := sub(val, 0x20)\n            mstore(ptr, val)\n        }\n        return data;\n    }\n\n    function remove32Slice(bytes memory input, uint256 start) private pure returns (bytes memory) {\n        // @note we assume start+32 is less than input.length\n        bytes memory result = new bytes(input.length - 32);\n\n        for (uint256 i = 0; i < start; i++) {\n            result[i] = input[i];\n        }\n\n        for (uint256 i = start + 32; i < input.length; i++) {\n            result[i - 32] = input[i];\n        }\n\n        return result;\n    }\n}\n"
    },
    "fhevm/lib/Impl.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause-Clear\npragma solidity ^0.8.24;\n\nimport \"./TFHE.sol\";\n\n/**\n * @title   FHEVMConfigStruct\n * @notice  This struct contains all addresses of core contrats which are needed in a typical dApp.\n */\nstruct FHEVMConfigStruct {\n    address ACLAddress;\n    address TFHEExecutorAddress;\n    address FHEPaymentAddress;\n    address KMSVerifierAddress;\n}\n\n/**\n * @title   ITFHEExecutor\n * @notice  This interface contains all functions to conduct FHE operations.\n */\ninterface ITFHEExecutor {\n    function fheAdd(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\n    function fheSub(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\n    function fheMul(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\n    function fheDiv(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\n    function fheRem(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\n    function fheBitAnd(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\n    function fheBitOr(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\n    function fheBitXor(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\n    function fheShl(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\n    function fheShr(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\n    function fheRotl(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\n    function fheRotr(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\n    function fheEq(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\n    function fheNe(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\n    function fheGe(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\n    function fheGt(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\n    function fheLe(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\n    function fheLt(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\n    function fheMin(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\n    function fheMax(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\n    function fheNeg(uint256 ct) external returns (uint256 result);\n    function fheNot(uint256 ct) external returns (uint256 result);\n    function verifyCiphertext(\n        bytes32 inputHandle,\n        address callerAddress,\n        bytes memory inputProof,\n        bytes1 inputType\n    ) external returns (uint256 result);\n    function cast(uint256 ct, bytes1 toType) external returns (uint256 result);\n    function trivialEncrypt(uint256 ct, bytes1 toType) external returns (uint256 result);\n    function trivialEncrypt(bytes memory ct, bytes1 toType) external returns (uint256 result);\n    function fheEq(uint256 lhs, bytes memory rhs, bytes1 scalarByte) external returns (uint256 result);\n    function fheNe(uint256 lhs, bytes memory rhs, bytes1 scalarByte) external returns (uint256 result);\n    function fheIfThenElse(uint256 control, uint256 ifTrue, uint256 ifFalse) external returns (uint256 result);\n    function fheRand(bytes1 randType) external returns (uint256 result);\n    function fheRandBounded(uint256 upperBound, bytes1 randType) external returns (uint256 result);\n}\n\n/**\n * @title   IACL\n * @notice  This interface contains all functions that are used to conduct operations\n *          with the ACL contract.\n */\ninterface IACL {\n    function allowTransient(uint256 ciphertext, address account) external;\n    function allow(uint256 handle, address account) external;\n    function cleanTransientStorage() external;\n    function isAllowed(uint256 handle, address account) external view returns (bool);\n    function allowForDecryption(uint256[] memory handlesList) external;\n}\n\n/**\n * @title   Impl\n * @notice  This library is the core implementation for computing FHE operations (e.g. add, sub, xor).\n */\nlibrary Impl {\n    /// @dev keccak256(abi.encode(uint256(keccak256(\"fhevm.storage.FHEVMConfig\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant FHEVMConfigLocation = 0xed8d60e34876f751cc8b014c560745351147d9de11b9347c854e881b128ea600;\n\n    function getFHEVMConfig() internal pure returns (FHEVMConfigStruct storage $) {\n        assembly {\n            $.slot := FHEVMConfigLocation\n        }\n    }\n\n    function setFHEVM(FHEVMConfigStruct memory fhevmConfig) internal {\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\n        $.ACLAddress = fhevmConfig.ACLAddress;\n        $.TFHEExecutorAddress = fhevmConfig.TFHEExecutorAddress;\n        $.FHEPaymentAddress = fhevmConfig.FHEPaymentAddress;\n        $.KMSVerifierAddress = fhevmConfig.KMSVerifierAddress;\n    }\n\n    function add(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheAdd(lhs, rhs, scalarByte);\n    }\n\n    function sub(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheSub(lhs, rhs, scalarByte);\n    }\n\n    function mul(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheMul(lhs, rhs, scalarByte);\n    }\n\n    function div(uint256 lhs, uint256 rhs) internal returns (uint256 result) {\n        bytes1 scalarByte = 0x01;\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheDiv(lhs, rhs, scalarByte);\n    }\n\n    function rem(uint256 lhs, uint256 rhs) internal returns (uint256 result) {\n        bytes1 scalarByte = 0x01;\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheRem(lhs, rhs, scalarByte);\n    }\n\n    function and(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheBitAnd(lhs, rhs, scalarByte);\n    }\n\n    function or(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheBitOr(lhs, rhs, scalarByte);\n    }\n\n    function xor(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheBitXor(lhs, rhs, scalarByte);\n    }\n\n    function shl(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheShl(lhs, rhs, scalarByte);\n    }\n\n    function shr(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheShr(lhs, rhs, scalarByte);\n    }\n\n    function rotl(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheRotl(lhs, rhs, scalarByte);\n    }\n\n    function rotr(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheRotr(lhs, rhs, scalarByte);\n    }\n\n    function eq(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheEq(lhs, rhs, scalarByte);\n    }\n\n    function ne(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheNe(lhs, rhs, scalarByte);\n    }\n\n    function ge(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheGe(lhs, rhs, scalarByte);\n    }\n\n    function gt(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheGt(lhs, rhs, scalarByte);\n    }\n\n    function le(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheLe(lhs, rhs, scalarByte);\n    }\n\n    function lt(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheLt(lhs, rhs, scalarByte);\n    }\n\n    function min(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheMin(lhs, rhs, scalarByte);\n    }\n\n    function max(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheMax(lhs, rhs, scalarByte);\n    }\n\n    function neg(uint256 ct) internal returns (uint256 result) {\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheNeg(ct);\n    }\n\n    function not(uint256 ct) internal returns (uint256 result) {\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheNot(ct);\n    }\n\n    // If 'control's value is 'true', the result has the same value as 'ifTrue'.\n    // If 'control's value is 'false', the result has the same value as 'ifFalse'.\n    function select(uint256 control, uint256 ifTrue, uint256 ifFalse) internal returns (uint256 result) {\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheIfThenElse(control, ifTrue, ifFalse);\n    }\n\n    function verify(bytes32 inputHandle, bytes memory inputProof, uint8 toType) internal returns (uint256 result) {\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\n        result = ITFHEExecutor($.TFHEExecutorAddress).verifyCiphertext(\n            inputHandle,\n            msg.sender,\n            inputProof,\n            bytes1(toType)\n        );\n        IACL($.ACLAddress).allowTransient(result, msg.sender);\n    }\n\n    function cast(uint256 ciphertext, uint8 toType) internal returns (uint256 result) {\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\n        result = ITFHEExecutor($.TFHEExecutorAddress).cast(ciphertext, bytes1(toType));\n    }\n\n    function trivialEncrypt(uint256 value, uint8 toType) internal returns (uint256 result) {\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\n        result = ITFHEExecutor($.TFHEExecutorAddress).trivialEncrypt(value, bytes1(toType));\n    }\n\n    function trivialEncrypt(bytes memory value, uint8 toType) internal returns (uint256 result) {\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\n        result = ITFHEExecutor($.TFHEExecutorAddress).trivialEncrypt(value, bytes1(toType));\n    }\n\n    function eq(uint256 lhs, bytes memory rhs, bool scalar) internal returns (uint256 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheEq(lhs, rhs, scalarByte);\n    }\n\n    function ne(uint256 lhs, bytes memory rhs, bool scalar) internal returns (uint256 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheNe(lhs, rhs, scalarByte);\n    }\n\n    function rand(uint8 randType) internal returns (uint256 result) {\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheRand(bytes1(randType));\n    }\n\n    function randBounded(uint256 upperBound, uint8 randType) internal returns (uint256 result) {\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheRandBounded(upperBound, bytes1(randType));\n    }\n\n    function allowTransient(uint256 handle, address account) internal {\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\n        IACL($.ACLAddress).allowTransient(handle, account);\n    }\n\n    function allow(uint256 handle, address account) internal {\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\n        IACL($.ACLAddress).allow(handle, account);\n    }\n\n    function cleanTransientStorage() internal {\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\n        IACL($.ACLAddress).cleanTransientStorage();\n    }\n\n    function isAllowed(uint256 handle, address account) internal view returns (bool) {\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\n        return IACL($.ACLAddress).isAllowed(handle, account);\n    }\n}\n"
    },
    "fhevm/lib/TFHE.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause-Clear\npragma solidity ^0.8.24;\n\nimport \"./Impl.sol\";\n\ntype ebool is uint256;\ntype euint4 is uint256;\ntype euint8 is uint256;\ntype euint16 is uint256;\ntype euint32 is uint256;\ntype euint64 is uint256;\ntype euint128 is uint256;\ntype euint256 is uint256;\ntype eaddress is uint256;\ntype ebytes64 is uint256;\ntype ebytes128 is uint256;\ntype ebytes256 is uint256;\ntype einput is bytes32;\n\n/**\n * @title   Common\n * @notice  This library contains all the values used to communicate types to the run time.\n */\nlibrary Common {\n    uint8 internal constant ebool_t = 0;\n    uint8 internal constant euint4_t = 1;\n    uint8 internal constant euint8_t = 2;\n    uint8 internal constant euint16_t = 3;\n    uint8 internal constant euint32_t = 4;\n    uint8 internal constant euint64_t = 5;\n    uint8 internal constant euint128_t = 6;\n    uint8 internal constant euint160_t = 7;\n    uint8 internal constant euint256_t = 8;\n    uint8 internal constant ebytes64_t = 9;\n    uint8 internal constant ebytes128_t = 10;\n    uint8 internal constant ebytes256_t = 11;\n}\n\n/**\n * @title   TFHE\n * @notice  This library is the interaction point for all smart contract developers\n *          that interact with TFHE.\n */\nlibrary TFHE {\n    function setFHEVM(FHEVMConfigStruct memory fhevmConfig) internal {\n        Impl.setFHEVM(fhevmConfig);\n    }\n\n    // Return true if the enrypted bool is initialized and false otherwise.\n    function isInitialized(ebool v) internal pure returns (bool) {\n        return ebool.unwrap(v) != 0;\n    }\n\n    // Return true if the enrypted integer is initialized and false otherwise.\n    function isInitialized(euint4 v) internal pure returns (bool) {\n        return euint4.unwrap(v) != 0;\n    }\n\n    // Return true if the enrypted integer is initialized and false otherwise.\n    function isInitialized(euint8 v) internal pure returns (bool) {\n        return euint8.unwrap(v) != 0;\n    }\n\n    // Return true if the enrypted integer is initialized and false otherwise.\n    function isInitialized(euint16 v) internal pure returns (bool) {\n        return euint16.unwrap(v) != 0;\n    }\n\n    // Return true if the enrypted integer is initialized and false otherwise.\n    function isInitialized(euint32 v) internal pure returns (bool) {\n        return euint32.unwrap(v) != 0;\n    }\n\n    // Return true if the enrypted integer is initialized and false otherwise.\n    function isInitialized(euint64 v) internal pure returns (bool) {\n        return euint64.unwrap(v) != 0;\n    }\n\n    // Return true if the enrypted integer is initialized and false otherwise.\n    function isInitialized(euint128 v) internal pure returns (bool) {\n        return euint128.unwrap(v) != 0;\n    }\n\n    // Return true if the enrypted integer is initialized and false otherwise.\n    function isInitialized(euint256 v) internal pure returns (bool) {\n        return euint256.unwrap(v) != 0;\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint4 a, euint4 b) internal returns (euint4) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint4.wrap(Impl.add(euint4.unwrap(a), euint4.unwrap(b), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint4 a, euint4 b) internal returns (euint4) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint4.wrap(Impl.sub(euint4.unwrap(a), euint4.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint4 a, euint4 b) internal returns (euint4) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint4.wrap(Impl.mul(euint4.unwrap(a), euint4.unwrap(b), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint4 a, euint4 b) internal returns (euint4) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint4.wrap(Impl.and(euint4.unwrap(a), euint4.unwrap(b), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint4 a, euint4 b) internal returns (euint4) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint4.wrap(Impl.or(euint4.unwrap(a), euint4.unwrap(b), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint4 a, euint4 b) internal returns (euint4) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint4.wrap(Impl.xor(euint4.unwrap(a), euint4.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint4 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.eq(euint4.unwrap(a), euint4.unwrap(b), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint4 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.ne(euint4.unwrap(a), euint4.unwrap(b), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint4 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.ge(euint4.unwrap(a), euint4.unwrap(b), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint4 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.gt(euint4.unwrap(a), euint4.unwrap(b), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint4 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.le(euint4.unwrap(a), euint4.unwrap(b), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint4 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.lt(euint4.unwrap(a), euint4.unwrap(b), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint4 a, euint4 b) internal returns (euint4) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint4.wrap(Impl.min(euint4.unwrap(a), euint4.unwrap(b), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint4 a, euint4 b) internal returns (euint4) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint4.wrap(Impl.max(euint4.unwrap(a), euint4.unwrap(b), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint4 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.add(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint4 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.sub(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint4 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.mul(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint4 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.and(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint4 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.or(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint4 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.xor(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint4 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.eq(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint4 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.ne(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint4 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.ge(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint4 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.gt(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint4 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.le(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint4 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.lt(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint4 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.min(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint4 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.max(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint4 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.add(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint4 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.sub(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint4 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.mul(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint4 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.and(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint4 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.or(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint4 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.xor(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint4 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.eq(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint4 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.ne(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint4 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.ge(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint4 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.gt(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint4 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.le(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint4 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.lt(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint4 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.min(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint4 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.max(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint4 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.add(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint4 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.sub(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint4 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.mul(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint4 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.and(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint4 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.or(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint4 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.xor(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint4 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.eq(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint4 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.ne(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint4 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.ge(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint4 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.gt(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint4 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.le(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint4 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.lt(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint4 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.min(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint4 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.max(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint4 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.add(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint4 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.sub(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint4 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.mul(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint4 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.and(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint4 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.or(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint4 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.xor(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint4 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.eq(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint4 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.ne(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint4 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.ge(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint4 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.gt(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint4 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.le(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint4 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.lt(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint4 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.min(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint4 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.max(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint4 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.add(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint4 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.sub(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint4 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.mul(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint4 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.and(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint4 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.or(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint4 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.xor(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint4 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.eq(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint4 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.ne(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint4 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.ge(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint4 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.gt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint4 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.le(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint4 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.lt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint4 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.min(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint4 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.max(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint4 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.add(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint4 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.sub(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint4 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.mul(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint4 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.and(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint4 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.or(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint4 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.xor(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint4 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.eq(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint4 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.ne(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint4 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.ge(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint4 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.gt(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint4 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.le(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint4 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.lt(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint4 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.min(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint4 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.max(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint4 a, uint8 b) internal returns (euint4) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        return euint4.wrap(Impl.add(euint4.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(uint8 a, euint4 b) internal returns (euint4) {\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint4.wrap(Impl.add(euint4.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint4 a, uint8 b) internal returns (euint4) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        return euint4.wrap(Impl.sub(euint4.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(uint8 a, euint4 b) internal returns (euint4) {\n        euint4 aEnc = asEuint4(a);\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint4.wrap(Impl.sub(euint4.unwrap(aEnc), euint4.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint4 a, uint8 b) internal returns (euint4) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        return euint4.wrap(Impl.mul(euint4.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(uint8 a, euint4 b) internal returns (euint4) {\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint4.wrap(Impl.mul(euint4.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate div(a, b) and return the result.\n    function div(euint4 a, uint8 b) internal returns (euint4) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        return euint4.wrap(Impl.div(euint4.unwrap(a), uint256(b)));\n    }\n\n    // Evaluate rem(a, b) and return the result.\n    function rem(euint4 a, uint8 b) internal returns (euint4) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        return euint4.wrap(Impl.rem(euint4.unwrap(a), uint256(b)));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint4 a, uint8 b) internal returns (euint4) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        return euint4.wrap(Impl.and(euint4.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(uint8 a, euint4 b) internal returns (euint4) {\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint4.wrap(Impl.and(euint4.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint4 a, uint8 b) internal returns (euint4) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        return euint4.wrap(Impl.or(euint4.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(uint8 a, euint4 b) internal returns (euint4) {\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint4.wrap(Impl.or(euint4.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint4 a, uint8 b) internal returns (euint4) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        return euint4.wrap(Impl.xor(euint4.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(uint8 a, euint4 b) internal returns (euint4) {\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint4.wrap(Impl.xor(euint4.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint4 a, uint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        return ebool.wrap(Impl.eq(euint4.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(uint8 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.eq(euint4.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint4 a, uint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        return ebool.wrap(Impl.ne(euint4.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(uint8 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.ne(euint4.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint4 a, uint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        return ebool.wrap(Impl.ge(euint4.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(uint8 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.le(euint4.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint4 a, uint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        return ebool.wrap(Impl.gt(euint4.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(uint8 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.lt(euint4.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint4 a, uint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        return ebool.wrap(Impl.le(euint4.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(uint8 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.ge(euint4.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint4 a, uint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        return ebool.wrap(Impl.lt(euint4.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(uint8 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.gt(euint4.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint4 a, uint8 b) internal returns (euint4) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        return euint4.wrap(Impl.min(euint4.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(uint8 a, euint4 b) internal returns (euint4) {\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint4.wrap(Impl.min(euint4.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint4 a, uint8 b) internal returns (euint4) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        return euint4.wrap(Impl.max(euint4.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(uint8 a, euint4 b) internal returns (euint4) {\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint4.wrap(Impl.max(euint4.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint8 a, euint4 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint8.wrap(Impl.add(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint8 a, euint4 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint8.wrap(Impl.sub(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint8 a, euint4 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint8.wrap(Impl.mul(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint8 a, euint4 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint8.wrap(Impl.and(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint8 a, euint4 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint8.wrap(Impl.or(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint8 a, euint4 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint8.wrap(Impl.xor(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint8 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.eq(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint8 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.ne(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint8 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.ge(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint8 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.gt(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint8 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.le(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint8 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.lt(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint8 a, euint4 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint8.wrap(Impl.min(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint8 a, euint4 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint8.wrap(Impl.max(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint8 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.add(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint8 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.sub(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint8 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.mul(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint8 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.and(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint8 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.or(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint8 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.xor(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint8 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.eq(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint8 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.ne(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint8 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.ge(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint8 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.gt(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint8 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.le(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint8 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.lt(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint8 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.min(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint8 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.max(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint8 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.add(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint8 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.sub(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint8 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.mul(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint8 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.and(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint8 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.or(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint8 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.xor(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint8 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.eq(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint8 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.ne(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint8 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.ge(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint8 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.gt(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint8 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.le(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint8 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.lt(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint8 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.min(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint8 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.max(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint8 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.add(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint8 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.sub(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint8 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.mul(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint8 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.and(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint8 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.or(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint8 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.xor(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint8 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.eq(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint8 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.ne(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint8 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.ge(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint8 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.gt(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint8 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.le(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint8 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.lt(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint8 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.min(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint8 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.max(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint8 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.add(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint8 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.sub(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint8 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.mul(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint8 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.and(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint8 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.or(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint8 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.xor(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint8 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.eq(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint8 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.ne(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint8 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.ge(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint8 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.gt(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint8 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.le(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint8 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.lt(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint8 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.min(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint8 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.max(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint8 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.add(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint8 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.sub(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint8 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.mul(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint8 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.and(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint8 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.or(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint8 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.xor(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint8 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.eq(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint8 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.ne(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint8 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.ge(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint8 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.gt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint8 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.le(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint8 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.lt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint8 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.min(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint8 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.max(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint8 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.add(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint8 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.sub(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint8 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.mul(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint8 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.and(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint8 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.or(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint8 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.xor(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint8 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.eq(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint8 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.ne(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint8 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.ge(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint8 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.gt(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint8 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.le(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint8 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.lt(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint8 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.min(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint8 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.max(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint8 a, uint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return euint8.wrap(Impl.add(euint8.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(uint8 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.add(euint8.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint8 a, uint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return euint8.wrap(Impl.sub(euint8.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(uint8 a, euint8 b) internal returns (euint8) {\n        euint8 aEnc = asEuint8(a);\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.sub(euint8.unwrap(aEnc), euint8.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint8 a, uint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return euint8.wrap(Impl.mul(euint8.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(uint8 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.mul(euint8.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate div(a, b) and return the result.\n    function div(euint8 a, uint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return euint8.wrap(Impl.div(euint8.unwrap(a), uint256(b)));\n    }\n\n    // Evaluate rem(a, b) and return the result.\n    function rem(euint8 a, uint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return euint8.wrap(Impl.rem(euint8.unwrap(a), uint256(b)));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint8 a, uint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return euint8.wrap(Impl.and(euint8.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(uint8 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.and(euint8.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint8 a, uint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return euint8.wrap(Impl.or(euint8.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(uint8 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.or(euint8.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint8 a, uint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return euint8.wrap(Impl.xor(euint8.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(uint8 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.xor(euint8.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint8 a, uint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return ebool.wrap(Impl.eq(euint8.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(uint8 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.eq(euint8.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint8 a, uint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return ebool.wrap(Impl.ne(euint8.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(uint8 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.ne(euint8.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint8 a, uint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return ebool.wrap(Impl.ge(euint8.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(uint8 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.le(euint8.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint8 a, uint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return ebool.wrap(Impl.gt(euint8.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(uint8 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.lt(euint8.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint8 a, uint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return ebool.wrap(Impl.le(euint8.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(uint8 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.ge(euint8.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint8 a, uint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return ebool.wrap(Impl.lt(euint8.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(uint8 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.gt(euint8.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint8 a, uint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return euint8.wrap(Impl.min(euint8.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(uint8 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.min(euint8.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint8 a, uint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return euint8.wrap(Impl.max(euint8.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(uint8 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.max(euint8.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint16 a, euint4 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint16.wrap(Impl.add(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint16 a, euint4 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint16.wrap(Impl.sub(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint16 a, euint4 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint16.wrap(Impl.mul(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint16 a, euint4 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint16.wrap(Impl.and(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint16 a, euint4 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint16.wrap(Impl.or(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint16 a, euint4 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint16.wrap(Impl.xor(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint16 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.eq(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint16 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.ne(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint16 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.ge(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint16 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.gt(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint16 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.le(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint16 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.lt(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint16 a, euint4 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint16.wrap(Impl.min(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint16 a, euint4 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint16.wrap(Impl.max(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint16 a, euint8 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint16.wrap(Impl.add(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint16 a, euint8 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint16.wrap(Impl.sub(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint16 a, euint8 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint16.wrap(Impl.mul(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint16 a, euint8 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint16.wrap(Impl.and(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint16 a, euint8 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint16.wrap(Impl.or(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint16 a, euint8 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint16.wrap(Impl.xor(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint16 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.eq(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint16 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.ne(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint16 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.ge(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint16 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.gt(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint16 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.le(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint16 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.lt(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint16 a, euint8 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint16.wrap(Impl.min(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint16 a, euint8 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint16.wrap(Impl.max(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint16 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.add(euint16.unwrap(a), euint16.unwrap(b), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint16 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.sub(euint16.unwrap(a), euint16.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint16 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.mul(euint16.unwrap(a), euint16.unwrap(b), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint16 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.and(euint16.unwrap(a), euint16.unwrap(b), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint16 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.or(euint16.unwrap(a), euint16.unwrap(b), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint16 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.xor(euint16.unwrap(a), euint16.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint16 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.eq(euint16.unwrap(a), euint16.unwrap(b), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint16 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.ne(euint16.unwrap(a), euint16.unwrap(b), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint16 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.ge(euint16.unwrap(a), euint16.unwrap(b), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint16 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.gt(euint16.unwrap(a), euint16.unwrap(b), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint16 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.le(euint16.unwrap(a), euint16.unwrap(b), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint16 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.lt(euint16.unwrap(a), euint16.unwrap(b), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint16 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.min(euint16.unwrap(a), euint16.unwrap(b), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint16 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.max(euint16.unwrap(a), euint16.unwrap(b), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint16 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.add(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint16 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.sub(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint16 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.mul(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint16 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.and(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint16 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.or(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint16 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.xor(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint16 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.eq(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint16 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.ne(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint16 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.ge(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint16 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.gt(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint16 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.le(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint16 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.lt(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint16 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.min(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint16 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.max(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint16 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.add(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint16 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.sub(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint16 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.mul(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint16 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.and(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint16 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.or(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint16 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.xor(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint16 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.eq(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint16 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.ne(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint16 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.ge(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint16 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.gt(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint16 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.le(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint16 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.lt(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint16 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.min(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint16 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.max(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint16 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.add(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint16 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.sub(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint16 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.mul(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint16 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.and(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint16 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.or(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint16 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.xor(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint16 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.eq(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint16 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.ne(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint16 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.ge(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint16 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.gt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint16 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.le(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint16 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.lt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint16 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.min(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint16 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.max(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint16 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.add(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint16 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.sub(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint16 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.mul(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint16 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.and(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint16 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.or(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint16 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.xor(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint16 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.eq(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint16 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.ne(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint16 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.ge(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint16 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.gt(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint16 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.le(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint16 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.lt(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint16 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.min(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint16 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.max(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint16 a, uint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return euint16.wrap(Impl.add(euint16.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(uint16 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.add(euint16.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint16 a, uint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return euint16.wrap(Impl.sub(euint16.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(uint16 a, euint16 b) internal returns (euint16) {\n        euint16 aEnc = asEuint16(a);\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.sub(euint16.unwrap(aEnc), euint16.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint16 a, uint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return euint16.wrap(Impl.mul(euint16.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(uint16 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.mul(euint16.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate div(a, b) and return the result.\n    function div(euint16 a, uint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return euint16.wrap(Impl.div(euint16.unwrap(a), uint256(b)));\n    }\n\n    // Evaluate rem(a, b) and return the result.\n    function rem(euint16 a, uint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return euint16.wrap(Impl.rem(euint16.unwrap(a), uint256(b)));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint16 a, uint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return euint16.wrap(Impl.and(euint16.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(uint16 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.and(euint16.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint16 a, uint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return euint16.wrap(Impl.or(euint16.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(uint16 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.or(euint16.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint16 a, uint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return euint16.wrap(Impl.xor(euint16.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(uint16 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.xor(euint16.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint16 a, uint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return ebool.wrap(Impl.eq(euint16.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(uint16 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.eq(euint16.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint16 a, uint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return ebool.wrap(Impl.ne(euint16.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(uint16 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.ne(euint16.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint16 a, uint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return ebool.wrap(Impl.ge(euint16.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(uint16 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.le(euint16.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint16 a, uint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return ebool.wrap(Impl.gt(euint16.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(uint16 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.lt(euint16.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint16 a, uint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return ebool.wrap(Impl.le(euint16.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(uint16 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.ge(euint16.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint16 a, uint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return ebool.wrap(Impl.lt(euint16.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(uint16 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.gt(euint16.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint16 a, uint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return euint16.wrap(Impl.min(euint16.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(uint16 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.min(euint16.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint16 a, uint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return euint16.wrap(Impl.max(euint16.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(uint16 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.max(euint16.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint32 a, euint4 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint32.wrap(Impl.add(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint32 a, euint4 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint32.wrap(Impl.sub(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint32 a, euint4 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint32.wrap(Impl.mul(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint32 a, euint4 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint32.wrap(Impl.and(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint32 a, euint4 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint32.wrap(Impl.or(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint32 a, euint4 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint32.wrap(Impl.xor(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint32 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.eq(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint32 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.ne(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint32 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.ge(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint32 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.gt(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint32 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.le(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint32 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.lt(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint32 a, euint4 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint32.wrap(Impl.min(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint32 a, euint4 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint32.wrap(Impl.max(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint32 a, euint8 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint32.wrap(Impl.add(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint32 a, euint8 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint32.wrap(Impl.sub(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint32 a, euint8 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint32.wrap(Impl.mul(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint32 a, euint8 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint32.wrap(Impl.and(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint32 a, euint8 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint32.wrap(Impl.or(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint32 a, euint8 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint32.wrap(Impl.xor(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint32 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.eq(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint32 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.ne(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint32 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.ge(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint32 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.gt(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint32 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.le(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint32 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.lt(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint32 a, euint8 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint32.wrap(Impl.min(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint32 a, euint8 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint32.wrap(Impl.max(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint32 a, euint16 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint32.wrap(Impl.add(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint32 a, euint16 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint32.wrap(Impl.sub(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint32 a, euint16 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint32.wrap(Impl.mul(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint32 a, euint16 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint32.wrap(Impl.and(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint32 a, euint16 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint32.wrap(Impl.or(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint32 a, euint16 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint32.wrap(Impl.xor(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint32 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.eq(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint32 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.ne(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint32 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.ge(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint32 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.gt(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint32 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.le(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint32 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.lt(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint32 a, euint16 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint32.wrap(Impl.min(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint32 a, euint16 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint32.wrap(Impl.max(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint32 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.add(euint32.unwrap(a), euint32.unwrap(b), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint32 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.sub(euint32.unwrap(a), euint32.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint32 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.mul(euint32.unwrap(a), euint32.unwrap(b), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint32 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.and(euint32.unwrap(a), euint32.unwrap(b), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint32 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.or(euint32.unwrap(a), euint32.unwrap(b), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint32 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.xor(euint32.unwrap(a), euint32.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint32 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.eq(euint32.unwrap(a), euint32.unwrap(b), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint32 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.ne(euint32.unwrap(a), euint32.unwrap(b), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint32 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.ge(euint32.unwrap(a), euint32.unwrap(b), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint32 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.gt(euint32.unwrap(a), euint32.unwrap(b), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint32 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.le(euint32.unwrap(a), euint32.unwrap(b), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint32 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.lt(euint32.unwrap(a), euint32.unwrap(b), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint32 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.min(euint32.unwrap(a), euint32.unwrap(b), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint32 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.max(euint32.unwrap(a), euint32.unwrap(b), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint32 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.add(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint32 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.sub(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint32 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.mul(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint32 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.and(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint32 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.or(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint32 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.xor(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint32 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.eq(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint32 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.ne(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint32 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.ge(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint32 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.gt(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint32 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.le(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint32 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.lt(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint32 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.min(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint32 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.max(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint32 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.add(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint32 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.sub(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint32 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.mul(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint32 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.and(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint32 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.or(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint32 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.xor(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint32 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.eq(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint32 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.ne(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint32 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.ge(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint32 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.gt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint32 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.le(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint32 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.lt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint32 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.min(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint32 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.max(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint32 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.add(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint32 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.sub(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint32 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.mul(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint32 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.and(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint32 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.or(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint32 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.xor(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint32 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.eq(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint32 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.ne(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint32 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.ge(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint32 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.gt(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint32 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.le(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint32 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.lt(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint32 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.min(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint32 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.max(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint32 a, uint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return euint32.wrap(Impl.add(euint32.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(uint32 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.add(euint32.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint32 a, uint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return euint32.wrap(Impl.sub(euint32.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(uint32 a, euint32 b) internal returns (euint32) {\n        euint32 aEnc = asEuint32(a);\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.sub(euint32.unwrap(aEnc), euint32.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint32 a, uint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return euint32.wrap(Impl.mul(euint32.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(uint32 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.mul(euint32.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate div(a, b) and return the result.\n    function div(euint32 a, uint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return euint32.wrap(Impl.div(euint32.unwrap(a), uint256(b)));\n    }\n\n    // Evaluate rem(a, b) and return the result.\n    function rem(euint32 a, uint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return euint32.wrap(Impl.rem(euint32.unwrap(a), uint256(b)));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint32 a, uint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return euint32.wrap(Impl.and(euint32.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(uint32 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.and(euint32.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint32 a, uint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return euint32.wrap(Impl.or(euint32.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(uint32 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.or(euint32.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint32 a, uint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return euint32.wrap(Impl.xor(euint32.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(uint32 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.xor(euint32.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint32 a, uint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return ebool.wrap(Impl.eq(euint32.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(uint32 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.eq(euint32.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint32 a, uint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return ebool.wrap(Impl.ne(euint32.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(uint32 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.ne(euint32.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint32 a, uint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return ebool.wrap(Impl.ge(euint32.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(uint32 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.le(euint32.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint32 a, uint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return ebool.wrap(Impl.gt(euint32.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(uint32 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.lt(euint32.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint32 a, uint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return ebool.wrap(Impl.le(euint32.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(uint32 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.ge(euint32.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint32 a, uint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return ebool.wrap(Impl.lt(euint32.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(uint32 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.gt(euint32.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint32 a, uint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return euint32.wrap(Impl.min(euint32.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(uint32 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.min(euint32.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint32 a, uint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return euint32.wrap(Impl.max(euint32.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(uint32 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.max(euint32.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint64 a, euint4 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint64.wrap(Impl.add(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint64 a, euint4 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint64.wrap(Impl.sub(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint64 a, euint4 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint64.wrap(Impl.mul(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint64 a, euint4 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint64.wrap(Impl.and(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint64 a, euint4 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint64.wrap(Impl.or(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint64 a, euint4 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint64.wrap(Impl.xor(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint64 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.eq(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint64 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.ne(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint64 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.ge(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint64 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.gt(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint64 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.le(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint64 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.lt(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint64 a, euint4 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint64.wrap(Impl.min(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint64 a, euint4 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint64.wrap(Impl.max(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint64 a, euint8 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint64.wrap(Impl.add(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint64 a, euint8 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint64.wrap(Impl.sub(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint64 a, euint8 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint64.wrap(Impl.mul(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint64 a, euint8 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint64.wrap(Impl.and(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint64 a, euint8 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint64.wrap(Impl.or(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint64 a, euint8 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint64.wrap(Impl.xor(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint64 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.eq(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint64 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.ne(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint64 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.ge(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint64 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.gt(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint64 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.le(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint64 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.lt(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint64 a, euint8 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint64.wrap(Impl.min(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint64 a, euint8 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint64.wrap(Impl.max(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint64 a, euint16 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint64.wrap(Impl.add(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint64 a, euint16 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint64.wrap(Impl.sub(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint64 a, euint16 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint64.wrap(Impl.mul(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint64 a, euint16 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint64.wrap(Impl.and(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint64 a, euint16 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint64.wrap(Impl.or(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint64 a, euint16 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint64.wrap(Impl.xor(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint64 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.eq(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint64 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.ne(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint64 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.ge(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint64 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.gt(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint64 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.le(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint64 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.lt(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint64 a, euint16 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint64.wrap(Impl.min(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint64 a, euint16 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint64.wrap(Impl.max(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint64 a, euint32 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint64.wrap(Impl.add(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint64 a, euint32 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint64.wrap(Impl.sub(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint64 a, euint32 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint64.wrap(Impl.mul(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint64 a, euint32 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint64.wrap(Impl.and(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint64 a, euint32 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint64.wrap(Impl.or(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint64 a, euint32 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint64.wrap(Impl.xor(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint64 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.eq(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint64 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.ne(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint64 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.ge(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint64 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.gt(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint64 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.le(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint64 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.lt(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint64 a, euint32 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint64.wrap(Impl.min(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint64 a, euint32 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint64.wrap(Impl.max(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint64 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.add(euint64.unwrap(a), euint64.unwrap(b), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint64 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.sub(euint64.unwrap(a), euint64.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint64 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.mul(euint64.unwrap(a), euint64.unwrap(b), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint64 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.and(euint64.unwrap(a), euint64.unwrap(b), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint64 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.or(euint64.unwrap(a), euint64.unwrap(b), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint64 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.xor(euint64.unwrap(a), euint64.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint64 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.eq(euint64.unwrap(a), euint64.unwrap(b), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint64 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.ne(euint64.unwrap(a), euint64.unwrap(b), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint64 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.ge(euint64.unwrap(a), euint64.unwrap(b), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint64 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.gt(euint64.unwrap(a), euint64.unwrap(b), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint64 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.le(euint64.unwrap(a), euint64.unwrap(b), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint64 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.lt(euint64.unwrap(a), euint64.unwrap(b), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint64 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.min(euint64.unwrap(a), euint64.unwrap(b), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint64 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.max(euint64.unwrap(a), euint64.unwrap(b), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint64 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.add(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint64 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.sub(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint64 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.mul(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint64 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.and(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint64 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.or(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint64 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.xor(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint64 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.eq(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint64 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.ne(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint64 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.ge(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint64 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.gt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint64 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.le(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint64 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.lt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint64 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.min(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint64 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.max(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint64 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.add(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint64 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.sub(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint64 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.mul(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint64 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.and(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint64 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.or(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint64 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.xor(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint64 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.eq(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint64 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.ne(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint64 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.ge(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint64 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.gt(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint64 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.le(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint64 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.lt(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint64 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.min(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint64 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.max(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint64 a, uint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        return euint64.wrap(Impl.add(euint64.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(uint64 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.add(euint64.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint64 a, uint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        return euint64.wrap(Impl.sub(euint64.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(uint64 a, euint64 b) internal returns (euint64) {\n        euint64 aEnc = asEuint64(a);\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.sub(euint64.unwrap(aEnc), euint64.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint64 a, uint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        return euint64.wrap(Impl.mul(euint64.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(uint64 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.mul(euint64.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate div(a, b) and return the result.\n    function div(euint64 a, uint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        return euint64.wrap(Impl.div(euint64.unwrap(a), uint256(b)));\n    }\n\n    // Evaluate rem(a, b) and return the result.\n    function rem(euint64 a, uint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        return euint64.wrap(Impl.rem(euint64.unwrap(a), uint256(b)));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint64 a, uint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        return euint64.wrap(Impl.and(euint64.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(uint64 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.and(euint64.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint64 a, uint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        return euint64.wrap(Impl.or(euint64.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(uint64 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.or(euint64.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint64 a, uint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        return euint64.wrap(Impl.xor(euint64.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(uint64 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.xor(euint64.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint64 a, uint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        return ebool.wrap(Impl.eq(euint64.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(uint64 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.eq(euint64.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint64 a, uint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        return ebool.wrap(Impl.ne(euint64.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(uint64 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.ne(euint64.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint64 a, uint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        return ebool.wrap(Impl.ge(euint64.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(uint64 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.le(euint64.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint64 a, uint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        return ebool.wrap(Impl.gt(euint64.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(uint64 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.lt(euint64.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint64 a, uint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        return ebool.wrap(Impl.le(euint64.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(uint64 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.ge(euint64.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint64 a, uint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        return ebool.wrap(Impl.lt(euint64.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(uint64 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.gt(euint64.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint64 a, uint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        return euint64.wrap(Impl.min(euint64.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(uint64 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.min(euint64.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint64 a, uint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        return euint64.wrap(Impl.max(euint64.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(uint64 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.max(euint64.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint128 a, euint4 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint128.wrap(Impl.add(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint128 a, euint4 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint128.wrap(Impl.sub(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint128 a, euint4 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint128.wrap(Impl.mul(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint128 a, euint4 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint128.wrap(Impl.and(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint128 a, euint4 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint128.wrap(Impl.or(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint128 a, euint4 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint128.wrap(Impl.xor(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint128 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.eq(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint128 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.ne(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint128 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.ge(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint128 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.gt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint128 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.le(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint128 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.lt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint128 a, euint4 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint128.wrap(Impl.min(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint128 a, euint4 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint128.wrap(Impl.max(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint128 a, euint8 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint128.wrap(Impl.add(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint128 a, euint8 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint128.wrap(Impl.sub(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint128 a, euint8 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint128.wrap(Impl.mul(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint128 a, euint8 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint128.wrap(Impl.and(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint128 a, euint8 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint128.wrap(Impl.or(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint128 a, euint8 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint128.wrap(Impl.xor(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint128 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.eq(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint128 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.ne(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint128 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.ge(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint128 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.gt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint128 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.le(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint128 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.lt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint128 a, euint8 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint128.wrap(Impl.min(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint128 a, euint8 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint128.wrap(Impl.max(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint128 a, euint16 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint128.wrap(Impl.add(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint128 a, euint16 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint128.wrap(Impl.sub(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint128 a, euint16 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint128.wrap(Impl.mul(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint128 a, euint16 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint128.wrap(Impl.and(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint128 a, euint16 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint128.wrap(Impl.or(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint128 a, euint16 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint128.wrap(Impl.xor(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint128 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.eq(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint128 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.ne(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint128 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.ge(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint128 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.gt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint128 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.le(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint128 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.lt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint128 a, euint16 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint128.wrap(Impl.min(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint128 a, euint16 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint128.wrap(Impl.max(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint128 a, euint32 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint128.wrap(Impl.add(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint128 a, euint32 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint128.wrap(Impl.sub(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint128 a, euint32 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint128.wrap(Impl.mul(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint128 a, euint32 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint128.wrap(Impl.and(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint128 a, euint32 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint128.wrap(Impl.or(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint128 a, euint32 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint128.wrap(Impl.xor(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint128 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.eq(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint128 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.ne(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint128 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.ge(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint128 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.gt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint128 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.le(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint128 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.lt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint128 a, euint32 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint128.wrap(Impl.min(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint128 a, euint32 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint128.wrap(Impl.max(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint128 a, euint64 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint128.wrap(Impl.add(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint128 a, euint64 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint128.wrap(Impl.sub(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint128 a, euint64 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint128.wrap(Impl.mul(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint128 a, euint64 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint128.wrap(Impl.and(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint128 a, euint64 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint128.wrap(Impl.or(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint128 a, euint64 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint128.wrap(Impl.xor(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint128 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.eq(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint128 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.ne(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint128 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.ge(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint128 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.gt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint128 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.le(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint128 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.lt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint128 a, euint64 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint128.wrap(Impl.min(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint128 a, euint64 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint128.wrap(Impl.max(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint128 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.add(euint128.unwrap(a), euint128.unwrap(b), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint128 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.sub(euint128.unwrap(a), euint128.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint128 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.mul(euint128.unwrap(a), euint128.unwrap(b), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint128 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.and(euint128.unwrap(a), euint128.unwrap(b), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint128 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.or(euint128.unwrap(a), euint128.unwrap(b), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint128 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.xor(euint128.unwrap(a), euint128.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint128 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.eq(euint128.unwrap(a), euint128.unwrap(b), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint128 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.ne(euint128.unwrap(a), euint128.unwrap(b), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint128 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.ge(euint128.unwrap(a), euint128.unwrap(b), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint128 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.gt(euint128.unwrap(a), euint128.unwrap(b), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint128 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.le(euint128.unwrap(a), euint128.unwrap(b), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint128 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.lt(euint128.unwrap(a), euint128.unwrap(b), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint128 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.min(euint128.unwrap(a), euint128.unwrap(b), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint128 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.max(euint128.unwrap(a), euint128.unwrap(b), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint128 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.add(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint128 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.sub(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint128 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.mul(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint128 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.and(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint128 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.or(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint128 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.xor(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint128 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.eq(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint128 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.ne(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint128 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.ge(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint128 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.gt(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint128 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.le(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint128 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.lt(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint128 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.min(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint128 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.max(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint128 a, uint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        return euint128.wrap(Impl.add(euint128.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(uint128 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.add(euint128.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint128 a, uint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        return euint128.wrap(Impl.sub(euint128.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(uint128 a, euint128 b) internal returns (euint128) {\n        euint128 aEnc = asEuint128(a);\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.sub(euint128.unwrap(aEnc), euint128.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint128 a, uint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        return euint128.wrap(Impl.mul(euint128.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(uint128 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.mul(euint128.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate div(a, b) and return the result.\n    function div(euint128 a, uint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        return euint128.wrap(Impl.div(euint128.unwrap(a), uint256(b)));\n    }\n\n    // Evaluate rem(a, b) and return the result.\n    function rem(euint128 a, uint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        return euint128.wrap(Impl.rem(euint128.unwrap(a), uint256(b)));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint128 a, uint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        return euint128.wrap(Impl.and(euint128.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(uint128 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.and(euint128.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint128 a, uint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        return euint128.wrap(Impl.or(euint128.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(uint128 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.or(euint128.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint128 a, uint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        return euint128.wrap(Impl.xor(euint128.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(uint128 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.xor(euint128.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint128 a, uint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        return ebool.wrap(Impl.eq(euint128.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(uint128 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.eq(euint128.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint128 a, uint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        return ebool.wrap(Impl.ne(euint128.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(uint128 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.ne(euint128.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint128 a, uint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        return ebool.wrap(Impl.ge(euint128.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(uint128 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.le(euint128.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint128 a, uint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        return ebool.wrap(Impl.gt(euint128.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(uint128 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.lt(euint128.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint128 a, uint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        return ebool.wrap(Impl.le(euint128.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(uint128 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.ge(euint128.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint128 a, uint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        return ebool.wrap(Impl.lt(euint128.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(uint128 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.gt(euint128.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint128 a, uint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        return euint128.wrap(Impl.min(euint128.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(uint128 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.min(euint128.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint128 a, uint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        return euint128.wrap(Impl.max(euint128.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(uint128 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.max(euint128.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint256 a, euint4 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint256.wrap(Impl.add(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint256 a, euint4 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint256.wrap(Impl.sub(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint256 a, euint4 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint256.wrap(Impl.mul(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint256 a, euint4 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint256.wrap(Impl.and(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint256 a, euint4 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint256.wrap(Impl.or(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint256 a, euint4 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint256 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint256 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint256 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.ge(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint256 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.gt(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint256 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.le(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint256 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.lt(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint256 a, euint4 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint256.wrap(Impl.min(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint256 a, euint4 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint256.wrap(Impl.max(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint256 a, euint8 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint256.wrap(Impl.add(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint256 a, euint8 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint256.wrap(Impl.sub(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint256 a, euint8 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint256.wrap(Impl.mul(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint256 a, euint8 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint256.wrap(Impl.and(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint256 a, euint8 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint256.wrap(Impl.or(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint256 a, euint8 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint256 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint256 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint256 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.ge(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint256 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.gt(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint256 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.le(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint256 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.lt(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint256 a, euint8 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint256.wrap(Impl.min(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint256 a, euint8 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint256.wrap(Impl.max(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint256 a, euint16 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint256.wrap(Impl.add(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint256 a, euint16 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint256.wrap(Impl.sub(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint256 a, euint16 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint256.wrap(Impl.mul(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint256 a, euint16 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint256.wrap(Impl.and(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint256 a, euint16 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint256.wrap(Impl.or(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint256 a, euint16 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint256 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint256 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint256 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.ge(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint256 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.gt(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint256 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.le(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint256 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.lt(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint256 a, euint16 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint256.wrap(Impl.min(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint256 a, euint16 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint256.wrap(Impl.max(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint256 a, euint32 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint256.wrap(Impl.add(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint256 a, euint32 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint256.wrap(Impl.sub(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint256 a, euint32 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint256.wrap(Impl.mul(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint256 a, euint32 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint256.wrap(Impl.and(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint256 a, euint32 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint256.wrap(Impl.or(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint256 a, euint32 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint256 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint256 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint256 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.ge(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint256 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.gt(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint256 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.le(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint256 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.lt(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint256 a, euint32 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint256.wrap(Impl.min(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint256 a, euint32 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint256.wrap(Impl.max(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint256 a, euint64 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint256.wrap(Impl.add(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint256 a, euint64 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint256.wrap(Impl.sub(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint256 a, euint64 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint256.wrap(Impl.mul(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint256 a, euint64 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint256.wrap(Impl.and(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint256 a, euint64 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint256.wrap(Impl.or(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint256 a, euint64 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint256 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint256 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint256 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.ge(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint256 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.gt(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint256 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.le(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint256 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.lt(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint256 a, euint64 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint256.wrap(Impl.min(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint256 a, euint64 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint256.wrap(Impl.max(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint256 a, euint128 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint256.wrap(Impl.add(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint256 a, euint128 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint256.wrap(Impl.sub(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint256 a, euint128 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint256.wrap(Impl.mul(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint256 a, euint128 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint256.wrap(Impl.and(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint256 a, euint128 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint256.wrap(Impl.or(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint256 a, euint128 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint256 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint256 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint256 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.ge(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint256 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.gt(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint256 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.le(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint256 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.lt(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint256 a, euint128 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint256.wrap(Impl.min(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint256 a, euint128 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint256.wrap(Impl.max(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint256 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.add(euint256.unwrap(a), euint256.unwrap(b), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint256 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.sub(euint256.unwrap(a), euint256.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint256 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.mul(euint256.unwrap(a), euint256.unwrap(b), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint256 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.and(euint256.unwrap(a), euint256.unwrap(b), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint256 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.or(euint256.unwrap(a), euint256.unwrap(b), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint256 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), euint256.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint256 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), euint256.unwrap(b), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint256 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), euint256.unwrap(b), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint256 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.ge(euint256.unwrap(a), euint256.unwrap(b), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint256 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.gt(euint256.unwrap(a), euint256.unwrap(b), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint256 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.le(euint256.unwrap(a), euint256.unwrap(b), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint256 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.lt(euint256.unwrap(a), euint256.unwrap(b), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint256 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.min(euint256.unwrap(a), euint256.unwrap(b), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint256 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.max(euint256.unwrap(a), euint256.unwrap(b), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint256 a, uint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        return euint256.wrap(Impl.add(euint256.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(uint256 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.add(euint256.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint256 a, uint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        return euint256.wrap(Impl.sub(euint256.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(uint256 a, euint256 b) internal returns (euint256) {\n        euint256 aEnc = asEuint256(a);\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.sub(euint256.unwrap(aEnc), euint256.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint256 a, uint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        return euint256.wrap(Impl.mul(euint256.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(uint256 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.mul(euint256.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate div(a, b) and return the result.\n    function div(euint256 a, uint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        return euint256.wrap(Impl.div(euint256.unwrap(a), uint256(b)));\n    }\n\n    // Evaluate rem(a, b) and return the result.\n    function rem(euint256 a, uint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        return euint256.wrap(Impl.rem(euint256.unwrap(a), uint256(b)));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint256 a, uint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        return euint256.wrap(Impl.and(euint256.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(uint256 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.and(euint256.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint256 a, uint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        return euint256.wrap(Impl.or(euint256.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(uint256 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.or(euint256.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint256 a, uint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(uint256 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.xor(euint256.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint256 a, uint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(uint256 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.eq(euint256.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint256 a, uint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(uint256 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.ne(euint256.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint256 a, uint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        return ebool.wrap(Impl.ge(euint256.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(uint256 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.le(euint256.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint256 a, uint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        return ebool.wrap(Impl.gt(euint256.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(uint256 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.lt(euint256.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint256 a, uint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        return ebool.wrap(Impl.le(euint256.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(uint256 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.ge(euint256.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint256 a, uint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        return ebool.wrap(Impl.lt(euint256.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(uint256 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.gt(euint256.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint256 a, uint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        return euint256.wrap(Impl.min(euint256.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(uint256 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.min(euint256.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint256 a, uint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        return euint256.wrap(Impl.max(euint256.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(uint256 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.max(euint256.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate shl(a, b) and return the result.\n    function shl(euint4 a, uint8 b) internal returns (euint4) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        return euint4.wrap(Impl.shl(euint4.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate shr(a, b) and return the result.\n    function shr(euint4 a, uint8 b) internal returns (euint4) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        return euint4.wrap(Impl.shr(euint4.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate rotl(a, b) and return the result.\n    function rotl(euint4 a, uint8 b) internal returns (euint4) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        return euint4.wrap(Impl.rotl(euint4.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate rotr(a, b) and return the result.\n    function rotr(euint4 a, uint8 b) internal returns (euint4) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        return euint4.wrap(Impl.rotr(euint4.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate shl(a, b) and return the result.\n    function shl(euint8 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.shl(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    // Evaluate shl(a, b) and return the result.\n    function shl(euint8 a, uint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return euint8.wrap(Impl.shl(euint8.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate shr(a, b) and return the result.\n    function shr(euint8 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.shr(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    // Evaluate shr(a, b) and return the result.\n    function shr(euint8 a, uint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return euint8.wrap(Impl.shr(euint8.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate rotl(a, b) and return the result.\n    function rotl(euint8 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.rotl(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    // Evaluate rotl(a, b) and return the result.\n    function rotl(euint8 a, uint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return euint8.wrap(Impl.rotl(euint8.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate rotr(a, b) and return the result.\n    function rotr(euint8 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.rotr(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    // Evaluate rotr(a, b) and return the result.\n    function rotr(euint8 a, uint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return euint8.wrap(Impl.rotr(euint8.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate shl(a, b) and return the result.\n    function shl(euint16 a, euint8 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint16.wrap(Impl.shl(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate shl(a, b) and return the result.\n    function shl(euint16 a, uint8 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return euint16.wrap(Impl.shl(euint16.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate shr(a, b) and return the result.\n    function shr(euint16 a, euint8 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint16.wrap(Impl.shr(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate shr(a, b) and return the result.\n    function shr(euint16 a, uint8 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return euint16.wrap(Impl.shr(euint16.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate rotl(a, b) and return the result.\n    function rotl(euint16 a, euint8 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint16.wrap(Impl.rotl(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate rotl(a, b) and return the result.\n    function rotl(euint16 a, uint8 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return euint16.wrap(Impl.rotl(euint16.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate rotr(a, b) and return the result.\n    function rotr(euint16 a, euint8 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint16.wrap(Impl.rotr(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate rotr(a, b) and return the result.\n    function rotr(euint16 a, uint8 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return euint16.wrap(Impl.rotr(euint16.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate shl(a, b) and return the result.\n    function shl(euint32 a, euint8 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint32.wrap(Impl.shl(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate shl(a, b) and return the result.\n    function shl(euint32 a, uint8 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return euint32.wrap(Impl.shl(euint32.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate shr(a, b) and return the result.\n    function shr(euint32 a, euint8 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint32.wrap(Impl.shr(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate shr(a, b) and return the result.\n    function shr(euint32 a, uint8 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return euint32.wrap(Impl.shr(euint32.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate rotl(a, b) and return the result.\n    function rotl(euint32 a, euint8 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint32.wrap(Impl.rotl(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate rotl(a, b) and return the result.\n    function rotl(euint32 a, uint8 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return euint32.wrap(Impl.rotl(euint32.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate rotr(a, b) and return the result.\n    function rotr(euint32 a, euint8 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint32.wrap(Impl.rotr(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate rotr(a, b) and return the result.\n    function rotr(euint32 a, uint8 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return euint32.wrap(Impl.rotr(euint32.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate shl(a, b) and return the result.\n    function shl(euint64 a, euint8 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint64.wrap(Impl.shl(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate shl(a, b) and return the result.\n    function shl(euint64 a, uint8 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        return euint64.wrap(Impl.shl(euint64.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate shr(a, b) and return the result.\n    function shr(euint64 a, euint8 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint64.wrap(Impl.shr(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate shr(a, b) and return the result.\n    function shr(euint64 a, uint8 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        return euint64.wrap(Impl.shr(euint64.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate rotl(a, b) and return the result.\n    function rotl(euint64 a, euint8 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint64.wrap(Impl.rotl(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate rotl(a, b) and return the result.\n    function rotl(euint64 a, uint8 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        return euint64.wrap(Impl.rotl(euint64.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate rotr(a, b) and return the result.\n    function rotr(euint64 a, euint8 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint64.wrap(Impl.rotr(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate rotr(a, b) and return the result.\n    function rotr(euint64 a, uint8 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        return euint64.wrap(Impl.rotr(euint64.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate shl(a, b) and return the result.\n    function shl(euint128 a, euint8 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint128.wrap(Impl.shl(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate shl(a, b) and return the result.\n    function shl(euint128 a, uint8 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        return euint128.wrap(Impl.shl(euint128.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate shr(a, b) and return the result.\n    function shr(euint128 a, euint8 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint128.wrap(Impl.shr(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate shr(a, b) and return the result.\n    function shr(euint128 a, uint8 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        return euint128.wrap(Impl.shr(euint128.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate rotl(a, b) and return the result.\n    function rotl(euint128 a, euint8 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint128.wrap(Impl.rotl(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate rotl(a, b) and return the result.\n    function rotl(euint128 a, uint8 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        return euint128.wrap(Impl.rotl(euint128.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate rotr(a, b) and return the result.\n    function rotr(euint128 a, euint8 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint128.wrap(Impl.rotr(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate rotr(a, b) and return the result.\n    function rotr(euint128 a, uint8 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        return euint128.wrap(Impl.rotr(euint128.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate shl(a, b) and return the result.\n    function shl(euint256 a, euint8 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint256.wrap(Impl.shl(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate shl(a, b) and return the result.\n    function shl(euint256 a, uint8 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        return euint256.wrap(Impl.shl(euint256.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate shr(a, b) and return the result.\n    function shr(euint256 a, euint8 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint256.wrap(Impl.shr(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate shr(a, b) and return the result.\n    function shr(euint256 a, uint8 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        return euint256.wrap(Impl.shr(euint256.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate rotl(a, b) and return the result.\n    function rotl(euint256 a, euint8 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint256.wrap(Impl.rotl(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate rotl(a, b) and return the result.\n    function rotl(euint256 a, uint8 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        return euint256.wrap(Impl.rotl(euint256.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate rotr(a, b) and return the result.\n    function rotr(euint256 a, euint8 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint256.wrap(Impl.rotr(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate rotr(a, b) and return the result.\n    function rotr(euint256 a, uint8 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        return euint256.wrap(Impl.rotr(euint256.unwrap(a), uint256(b), true));\n    }\n\n    // If 'control''s value is 'true', the result has the same value as 'a'.\n    // If 'control''s value is 'false', the result has the same value as 'b'.\n    function select(ebool control, euint4 a, euint4 b) internal returns (euint4) {\n        return euint4.wrap(Impl.select(ebool.unwrap(control), euint4.unwrap(a), euint4.unwrap(b)));\n    }\n    // If 'control''s value is 'true', the result has the same value as 'a'.\n    // If 'control''s value is 'false', the result has the same value as 'b'.\n    function select(ebool control, euint8 a, euint8 b) internal returns (euint8) {\n        return euint8.wrap(Impl.select(ebool.unwrap(control), euint8.unwrap(a), euint8.unwrap(b)));\n    }\n    // If 'control''s value is 'true', the result has the same value as 'a'.\n    // If 'control''s value is 'false', the result has the same value as 'b'.\n    function select(ebool control, euint16 a, euint16 b) internal returns (euint16) {\n        return euint16.wrap(Impl.select(ebool.unwrap(control), euint16.unwrap(a), euint16.unwrap(b)));\n    }\n    // If 'control''s value is 'true', the result has the same value as 'a'.\n    // If 'control''s value is 'false', the result has the same value as 'b'.\n    function select(ebool control, euint32 a, euint32 b) internal returns (euint32) {\n        return euint32.wrap(Impl.select(ebool.unwrap(control), euint32.unwrap(a), euint32.unwrap(b)));\n    }\n    // If 'control''s value is 'true', the result has the same value as 'a'.\n    // If 'control''s value is 'false', the result has the same value as 'b'.\n    function select(ebool control, euint64 a, euint64 b) internal returns (euint64) {\n        return euint64.wrap(Impl.select(ebool.unwrap(control), euint64.unwrap(a), euint64.unwrap(b)));\n    }\n    // If 'control''s value is 'true', the result has the same value as 'a'.\n    // If 'control''s value is 'false', the result has the same value as 'b'.\n    function select(ebool control, euint128 a, euint128 b) internal returns (euint128) {\n        return euint128.wrap(Impl.select(ebool.unwrap(control), euint128.unwrap(a), euint128.unwrap(b)));\n    }\n    // If 'control''s value is 'true', the result has the same value as 'a'.\n    // If 'control''s value is 'false', the result has the same value as 'b'.\n    function select(ebool control, euint256 a, euint256 b) internal returns (euint256) {\n        return euint256.wrap(Impl.select(ebool.unwrap(control), euint256.unwrap(a), euint256.unwrap(b)));\n    }\n    // Cast an encrypted integer from euint8 to euint4.\n    function asEuint4(euint8 value) internal returns (euint4) {\n        return euint4.wrap(Impl.cast(euint8.unwrap(value), Common.euint4_t));\n    }\n\n    // Cast an encrypted integer from euint16 to euint4.\n    function asEuint4(euint16 value) internal returns (euint4) {\n        return euint4.wrap(Impl.cast(euint16.unwrap(value), Common.euint4_t));\n    }\n\n    // Cast an encrypted integer from euint32 to euint4.\n    function asEuint4(euint32 value) internal returns (euint4) {\n        return euint4.wrap(Impl.cast(euint32.unwrap(value), Common.euint4_t));\n    }\n\n    // Cast an encrypted integer from euint64 to euint4.\n    function asEuint4(euint64 value) internal returns (euint4) {\n        return euint4.wrap(Impl.cast(euint64.unwrap(value), Common.euint4_t));\n    }\n\n    // Cast an encrypted integer from euint128 to euint4.\n    function asEuint4(euint128 value) internal returns (euint4) {\n        return euint4.wrap(Impl.cast(euint128.unwrap(value), Common.euint4_t));\n    }\n\n    // Cast an encrypted integer from euint256 to euint4.\n    function asEuint4(euint256 value) internal returns (euint4) {\n        return euint4.wrap(Impl.cast(euint256.unwrap(value), Common.euint4_t));\n    }\n\n    // Cast an encrypted integer from euint4 to ebool.\n    function asEbool(euint4 value) internal returns (ebool) {\n        return ne(value, 0);\n    }\n\n    // Converts an 'ebool' to an 'euint4'.\n    function asEuint4(ebool b) internal returns (euint4) {\n        return euint4.wrap(Impl.cast(ebool.unwrap(b), Common.euint4_t));\n    }\n\n    // Cast an encrypted integer from euint4 to euint8.\n    function asEuint8(euint4 value) internal returns (euint8) {\n        return euint8.wrap(Impl.cast(euint4.unwrap(value), Common.euint8_t));\n    }\n\n    // Cast an encrypted integer from euint16 to euint8.\n    function asEuint8(euint16 value) internal returns (euint8) {\n        return euint8.wrap(Impl.cast(euint16.unwrap(value), Common.euint8_t));\n    }\n\n    // Cast an encrypted integer from euint32 to euint8.\n    function asEuint8(euint32 value) internal returns (euint8) {\n        return euint8.wrap(Impl.cast(euint32.unwrap(value), Common.euint8_t));\n    }\n\n    // Cast an encrypted integer from euint64 to euint8.\n    function asEuint8(euint64 value) internal returns (euint8) {\n        return euint8.wrap(Impl.cast(euint64.unwrap(value), Common.euint8_t));\n    }\n\n    // Cast an encrypted integer from euint128 to euint8.\n    function asEuint8(euint128 value) internal returns (euint8) {\n        return euint8.wrap(Impl.cast(euint128.unwrap(value), Common.euint8_t));\n    }\n\n    // Cast an encrypted integer from euint256 to euint8.\n    function asEuint8(euint256 value) internal returns (euint8) {\n        return euint8.wrap(Impl.cast(euint256.unwrap(value), Common.euint8_t));\n    }\n\n    // Cast an encrypted integer from euint8 to ebool.\n    function asEbool(euint8 value) internal returns (ebool) {\n        return ne(value, 0);\n    }\n\n    // Convert an inputHandle with corresponding inputProof to an encrypted boolean.\n    function asEbool(einput inputHandle, bytes memory inputProof) internal returns (ebool) {\n        return ebool.wrap(Impl.verify(einput.unwrap(inputHandle), inputProof, Common.ebool_t));\n    }\n\n    // Convert a plaintext value to an encrypted boolean.\n    function asEbool(uint256 value) internal returns (ebool) {\n        return ebool.wrap(Impl.trivialEncrypt(value, Common.ebool_t));\n    }\n\n    // Convert a plaintext boolean to an encrypted boolean.\n    function asEbool(bool value) internal returns (ebool) {\n        if (value) {\n            return asEbool(1);\n        } else {\n            return asEbool(0);\n        }\n    }\n\n    // Converts an 'ebool' to an 'euint8'.\n    function asEuint8(ebool value) internal returns (euint8) {\n        return euint8.wrap(Impl.cast(ebool.unwrap(value), Common.euint8_t));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(ebool a, ebool b) internal returns (ebool) {\n        return ebool.wrap(Impl.and(ebool.unwrap(a), ebool.unwrap(b), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(ebool a, bool b) internal returns (ebool) {\n        return ebool.wrap(Impl.and(ebool.unwrap(a), b ? 1 : 0, true));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(bool a, ebool b) internal returns (ebool) {\n        return ebool.wrap(Impl.and(ebool.unwrap(b), a ? 1 : 0, true));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(ebool a, ebool b) internal returns (ebool) {\n        return ebool.wrap(Impl.or(ebool.unwrap(a), ebool.unwrap(b), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(ebool a, bool b) internal returns (ebool) {\n        return ebool.wrap(Impl.or(ebool.unwrap(a), b ? 1 : 0, true));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(bool a, ebool b) internal returns (ebool) {\n        return ebool.wrap(Impl.or(ebool.unwrap(b), a ? 1 : 0, true));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(ebool a, ebool b) internal returns (ebool) {\n        return ebool.wrap(Impl.xor(ebool.unwrap(a), ebool.unwrap(b), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(ebool a, bool b) internal returns (ebool) {\n        return ebool.wrap(Impl.xor(ebool.unwrap(a), b ? 1 : 0, true));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(bool a, ebool b) internal returns (ebool) {\n        return ebool.wrap(Impl.xor(ebool.unwrap(b), a ? 1 : 0, true));\n    }\n\n    function not(ebool a) internal returns (ebool) {\n        return ebool.wrap(Impl.not(ebool.unwrap(a)));\n    }\n\n    // Cast an encrypted integer from euint4 to euint16.\n    function asEuint16(euint4 value) internal returns (euint16) {\n        return euint16.wrap(Impl.cast(euint4.unwrap(value), Common.euint16_t));\n    }\n\n    // Cast an encrypted integer from euint8 to euint16.\n    function asEuint16(euint8 value) internal returns (euint16) {\n        return euint16.wrap(Impl.cast(euint8.unwrap(value), Common.euint16_t));\n    }\n\n    // Cast an encrypted integer from euint32 to euint16.\n    function asEuint16(euint32 value) internal returns (euint16) {\n        return euint16.wrap(Impl.cast(euint32.unwrap(value), Common.euint16_t));\n    }\n\n    // Cast an encrypted integer from euint64 to euint16.\n    function asEuint16(euint64 value) internal returns (euint16) {\n        return euint16.wrap(Impl.cast(euint64.unwrap(value), Common.euint16_t));\n    }\n\n    // Cast an encrypted integer from euint128 to euint16.\n    function asEuint16(euint128 value) internal returns (euint16) {\n        return euint16.wrap(Impl.cast(euint128.unwrap(value), Common.euint16_t));\n    }\n\n    // Cast an encrypted integer from euint256 to euint16.\n    function asEuint16(euint256 value) internal returns (euint16) {\n        return euint16.wrap(Impl.cast(euint256.unwrap(value), Common.euint16_t));\n    }\n\n    // Cast an encrypted integer from euint16 to ebool.\n    function asEbool(euint16 value) internal returns (ebool) {\n        return ne(value, 0);\n    }\n\n    // Converts an 'ebool' to an 'euint16'.\n    function asEuint16(ebool b) internal returns (euint16) {\n        return euint16.wrap(Impl.cast(ebool.unwrap(b), Common.euint16_t));\n    }\n\n    // Cast an encrypted integer from euint4 to euint32.\n    function asEuint32(euint4 value) internal returns (euint32) {\n        return euint32.wrap(Impl.cast(euint4.unwrap(value), Common.euint32_t));\n    }\n\n    // Cast an encrypted integer from euint8 to euint32.\n    function asEuint32(euint8 value) internal returns (euint32) {\n        return euint32.wrap(Impl.cast(euint8.unwrap(value), Common.euint32_t));\n    }\n\n    // Cast an encrypted integer from euint16 to euint32.\n    function asEuint32(euint16 value) internal returns (euint32) {\n        return euint32.wrap(Impl.cast(euint16.unwrap(value), Common.euint32_t));\n    }\n\n    // Cast an encrypted integer from euint64 to euint32.\n    function asEuint32(euint64 value) internal returns (euint32) {\n        return euint32.wrap(Impl.cast(euint64.unwrap(value), Common.euint32_t));\n    }\n\n    // Cast an encrypted integer from euint128 to euint32.\n    function asEuint32(euint128 value) internal returns (euint32) {\n        return euint32.wrap(Impl.cast(euint128.unwrap(value), Common.euint32_t));\n    }\n\n    // Cast an encrypted integer from euint256 to euint32.\n    function asEuint32(euint256 value) internal returns (euint32) {\n        return euint32.wrap(Impl.cast(euint256.unwrap(value), Common.euint32_t));\n    }\n\n    // Cast an encrypted integer from euint32 to ebool.\n    function asEbool(euint32 value) internal returns (ebool) {\n        return ne(value, 0);\n    }\n\n    // Converts an 'ebool' to an 'euint32'.\n    function asEuint32(ebool b) internal returns (euint32) {\n        return euint32.wrap(Impl.cast(ebool.unwrap(b), Common.euint32_t));\n    }\n\n    // Cast an encrypted integer from euint4 to euint64.\n    function asEuint64(euint4 value) internal returns (euint64) {\n        return euint64.wrap(Impl.cast(euint4.unwrap(value), Common.euint64_t));\n    }\n\n    // Cast an encrypted integer from euint8 to euint64.\n    function asEuint64(euint8 value) internal returns (euint64) {\n        return euint64.wrap(Impl.cast(euint8.unwrap(value), Common.euint64_t));\n    }\n\n    // Cast an encrypted integer from euint16 to euint64.\n    function asEuint64(euint16 value) internal returns (euint64) {\n        return euint64.wrap(Impl.cast(euint16.unwrap(value), Common.euint64_t));\n    }\n\n    // Cast an encrypted integer from euint32 to euint64.\n    function asEuint64(euint32 value) internal returns (euint64) {\n        return euint64.wrap(Impl.cast(euint32.unwrap(value), Common.euint64_t));\n    }\n\n    // Cast an encrypted integer from euint128 to euint64.\n    function asEuint64(euint128 value) internal returns (euint64) {\n        return euint64.wrap(Impl.cast(euint128.unwrap(value), Common.euint64_t));\n    }\n\n    // Cast an encrypted integer from euint256 to euint64.\n    function asEuint64(euint256 value) internal returns (euint64) {\n        return euint64.wrap(Impl.cast(euint256.unwrap(value), Common.euint64_t));\n    }\n\n    // Cast an encrypted integer from euint64 to ebool.\n    function asEbool(euint64 value) internal returns (ebool) {\n        return ne(value, 0);\n    }\n\n    // Converts an 'ebool' to an 'euint64'.\n    function asEuint64(ebool b) internal returns (euint64) {\n        return euint64.wrap(Impl.cast(ebool.unwrap(b), Common.euint64_t));\n    }\n\n    // Cast an encrypted integer from euint4 to euint128.\n    function asEuint128(euint4 value) internal returns (euint128) {\n        return euint128.wrap(Impl.cast(euint4.unwrap(value), Common.euint128_t));\n    }\n\n    // Cast an encrypted integer from euint8 to euint128.\n    function asEuint128(euint8 value) internal returns (euint128) {\n        return euint128.wrap(Impl.cast(euint8.unwrap(value), Common.euint128_t));\n    }\n\n    // Cast an encrypted integer from euint16 to euint128.\n    function asEuint128(euint16 value) internal returns (euint128) {\n        return euint128.wrap(Impl.cast(euint16.unwrap(value), Common.euint128_t));\n    }\n\n    // Cast an encrypted integer from euint32 to euint128.\n    function asEuint128(euint32 value) internal returns (euint128) {\n        return euint128.wrap(Impl.cast(euint32.unwrap(value), Common.euint128_t));\n    }\n\n    // Cast an encrypted integer from euint64 to euint128.\n    function asEuint128(euint64 value) internal returns (euint128) {\n        return euint128.wrap(Impl.cast(euint64.unwrap(value), Common.euint128_t));\n    }\n\n    // Cast an encrypted integer from euint256 to euint128.\n    function asEuint128(euint256 value) internal returns (euint128) {\n        return euint128.wrap(Impl.cast(euint256.unwrap(value), Common.euint128_t));\n    }\n\n    // Cast an encrypted integer from euint128 to ebool.\n    function asEbool(euint128 value) internal returns (ebool) {\n        return ne(value, 0);\n    }\n\n    // Converts an 'ebool' to an 'euint128'.\n    function asEuint128(ebool b) internal returns (euint128) {\n        return euint128.wrap(Impl.cast(ebool.unwrap(b), Common.euint128_t));\n    }\n\n    // Cast an encrypted integer from euint4 to euint256.\n    function asEuint256(euint4 value) internal returns (euint256) {\n        return euint256.wrap(Impl.cast(euint4.unwrap(value), Common.euint256_t));\n    }\n\n    // Cast an encrypted integer from euint8 to euint256.\n    function asEuint256(euint8 value) internal returns (euint256) {\n        return euint256.wrap(Impl.cast(euint8.unwrap(value), Common.euint256_t));\n    }\n\n    // Cast an encrypted integer from euint16 to euint256.\n    function asEuint256(euint16 value) internal returns (euint256) {\n        return euint256.wrap(Impl.cast(euint16.unwrap(value), Common.euint256_t));\n    }\n\n    // Cast an encrypted integer from euint32 to euint256.\n    function asEuint256(euint32 value) internal returns (euint256) {\n        return euint256.wrap(Impl.cast(euint32.unwrap(value), Common.euint256_t));\n    }\n\n    // Cast an encrypted integer from euint64 to euint256.\n    function asEuint256(euint64 value) internal returns (euint256) {\n        return euint256.wrap(Impl.cast(euint64.unwrap(value), Common.euint256_t));\n    }\n\n    // Cast an encrypted integer from euint128 to euint256.\n    function asEuint256(euint128 value) internal returns (euint256) {\n        return euint256.wrap(Impl.cast(euint128.unwrap(value), Common.euint256_t));\n    }\n\n    // Cast an encrypted integer from euint256 to ebool.\n    function asEbool(euint256 value) internal returns (ebool) {\n        return ne(value, 0);\n    }\n\n    // Converts an 'ebool' to an 'euint256'.\n    function asEuint256(ebool b) internal returns (euint256) {\n        return euint256.wrap(Impl.cast(ebool.unwrap(b), Common.euint256_t));\n    }\n\n    function neg(euint4 value) internal returns (euint4) {\n        return euint4.wrap(Impl.neg(euint4.unwrap(value)));\n    }\n\n    function not(euint4 value) internal returns (euint4) {\n        return euint4.wrap(Impl.not(euint4.unwrap(value)));\n    }\n\n    function neg(euint8 value) internal returns (euint8) {\n        return euint8.wrap(Impl.neg(euint8.unwrap(value)));\n    }\n\n    function not(euint8 value) internal returns (euint8) {\n        return euint8.wrap(Impl.not(euint8.unwrap(value)));\n    }\n\n    function neg(euint16 value) internal returns (euint16) {\n        return euint16.wrap(Impl.neg(euint16.unwrap(value)));\n    }\n\n    function not(euint16 value) internal returns (euint16) {\n        return euint16.wrap(Impl.not(euint16.unwrap(value)));\n    }\n\n    function neg(euint32 value) internal returns (euint32) {\n        return euint32.wrap(Impl.neg(euint32.unwrap(value)));\n    }\n\n    function not(euint32 value) internal returns (euint32) {\n        return euint32.wrap(Impl.not(euint32.unwrap(value)));\n    }\n\n    function neg(euint64 value) internal returns (euint64) {\n        return euint64.wrap(Impl.neg(euint64.unwrap(value)));\n    }\n\n    function not(euint64 value) internal returns (euint64) {\n        return euint64.wrap(Impl.not(euint64.unwrap(value)));\n    }\n\n    function neg(euint128 value) internal returns (euint128) {\n        return euint128.wrap(Impl.neg(euint128.unwrap(value)));\n    }\n\n    function not(euint128 value) internal returns (euint128) {\n        return euint128.wrap(Impl.not(euint128.unwrap(value)));\n    }\n\n    function neg(euint256 value) internal returns (euint256) {\n        return euint256.wrap(Impl.neg(euint256.unwrap(value)));\n    }\n\n    function not(euint256 value) internal returns (euint256) {\n        return euint256.wrap(Impl.not(euint256.unwrap(value)));\n    }\n\n    // Convert an inputHandle with corresponding inputProof to an encrypted euint4 integer.\n    function asEuint4(einput inputHandle, bytes memory inputProof) internal returns (euint4) {\n        return euint4.wrap(Impl.verify(einput.unwrap(inputHandle), inputProof, Common.euint4_t));\n    }\n\n    // Convert a plaintext value to an encrypted euint4 integer.\n    function asEuint4(uint256 value) internal returns (euint4) {\n        return euint4.wrap(Impl.trivialEncrypt(value, Common.euint4_t));\n    }\n\n    // Convert an inputHandle with corresponding inputProof to an encrypted euint8 integer.\n    function asEuint8(einput inputHandle, bytes memory inputProof) internal returns (euint8) {\n        return euint8.wrap(Impl.verify(einput.unwrap(inputHandle), inputProof, Common.euint8_t));\n    }\n\n    // Convert a plaintext value to an encrypted euint8 integer.\n    function asEuint8(uint256 value) internal returns (euint8) {\n        return euint8.wrap(Impl.trivialEncrypt(value, Common.euint8_t));\n    }\n\n    // Convert an inputHandle with corresponding inputProof to an encrypted euint16 integer.\n    function asEuint16(einput inputHandle, bytes memory inputProof) internal returns (euint16) {\n        return euint16.wrap(Impl.verify(einput.unwrap(inputHandle), inputProof, Common.euint16_t));\n    }\n\n    // Convert a plaintext value to an encrypted euint16 integer.\n    function asEuint16(uint256 value) internal returns (euint16) {\n        return euint16.wrap(Impl.trivialEncrypt(value, Common.euint16_t));\n    }\n\n    // Convert an inputHandle with corresponding inputProof to an encrypted euint32 integer.\n    function asEuint32(einput inputHandle, bytes memory inputProof) internal returns (euint32) {\n        return euint32.wrap(Impl.verify(einput.unwrap(inputHandle), inputProof, Common.euint32_t));\n    }\n\n    // Convert a plaintext value to an encrypted euint32 integer.\n    function asEuint32(uint256 value) internal returns (euint32) {\n        return euint32.wrap(Impl.trivialEncrypt(value, Common.euint32_t));\n    }\n\n    // Convert an inputHandle with corresponding inputProof to an encrypted euint64 integer.\n    function asEuint64(einput inputHandle, bytes memory inputProof) internal returns (euint64) {\n        return euint64.wrap(Impl.verify(einput.unwrap(inputHandle), inputProof, Common.euint64_t));\n    }\n\n    // Convert a plaintext value to an encrypted euint64 integer.\n    function asEuint64(uint256 value) internal returns (euint64) {\n        return euint64.wrap(Impl.trivialEncrypt(value, Common.euint64_t));\n    }\n\n    // Convert an inputHandle with corresponding inputProof to an encrypted euint128 integer.\n    function asEuint128(einput inputHandle, bytes memory inputProof) internal returns (euint128) {\n        return euint128.wrap(Impl.verify(einput.unwrap(inputHandle), inputProof, Common.euint128_t));\n    }\n\n    // Convert a plaintext value to an encrypted euint128 integer.\n    function asEuint128(uint256 value) internal returns (euint128) {\n        return euint128.wrap(Impl.trivialEncrypt(value, Common.euint128_t));\n    }\n\n    // Convert an inputHandle with corresponding inputProof to an encrypted euint256 integer.\n    function asEuint256(einput inputHandle, bytes memory inputProof) internal returns (euint256) {\n        return euint256.wrap(Impl.verify(einput.unwrap(inputHandle), inputProof, Common.euint256_t));\n    }\n\n    // Convert a plaintext value to an encrypted euint256 integer.\n    function asEuint256(uint256 value) internal returns (euint256) {\n        return euint256.wrap(Impl.trivialEncrypt(value, Common.euint256_t));\n    }\n\n    // Generates a random encrypted boolean.\n    function randEbool() internal returns (ebool) {\n        return ebool.wrap(Impl.rand(Common.ebool_t));\n    }\n\n    // Generates a random encrypted 4-bit unsigned integer.\n    function randEuint4() internal returns (euint4) {\n        return euint4.wrap(Impl.rand(Common.euint4_t));\n    }\n\n    // Generates a random encrypted 4-bit unsigned integer in the [0, upperBound) range.\n    // The upperBound must be a power of 2.\n    function randEuint4(uint8 upperBound) internal returns (euint4) {\n        return euint4.wrap(Impl.randBounded(upperBound, Common.euint4_t));\n    }\n\n    // Generates a random encrypted 8-bit unsigned integer.\n    function randEuint8() internal returns (euint8) {\n        return euint8.wrap(Impl.rand(Common.euint8_t));\n    }\n\n    // Generates a random encrypted 8-bit unsigned integer in the [0, upperBound) range.\n    // The upperBound must be a power of 2.\n    function randEuint8(uint8 upperBound) internal returns (euint8) {\n        return euint8.wrap(Impl.randBounded(upperBound, Common.euint8_t));\n    }\n\n    // Generates a random encrypted 16-bit unsigned integer.\n    function randEuint16() internal returns (euint16) {\n        return euint16.wrap(Impl.rand(Common.euint16_t));\n    }\n\n    // Generates a random encrypted 16-bit unsigned integer in the [0, upperBound) range.\n    // The upperBound must be a power of 2.\n    function randEuint16(uint16 upperBound) internal returns (euint16) {\n        return euint16.wrap(Impl.randBounded(upperBound, Common.euint16_t));\n    }\n\n    // Generates a random encrypted 32-bit unsigned integer.\n    function randEuint32() internal returns (euint32) {\n        return euint32.wrap(Impl.rand(Common.euint32_t));\n    }\n\n    // Generates a random encrypted 32-bit unsigned integer in the [0, upperBound) range.\n    // The upperBound must be a power of 2.\n    function randEuint32(uint32 upperBound) internal returns (euint32) {\n        return euint32.wrap(Impl.randBounded(upperBound, Common.euint32_t));\n    }\n\n    // Generates a random encrypted 64-bit unsigned integer.\n    function randEuint64() internal returns (euint64) {\n        return euint64.wrap(Impl.rand(Common.euint64_t));\n    }\n\n    // Generates a random encrypted 64-bit unsigned integer in the [0, upperBound) range.\n    // The upperBound must be a power of 2.\n    function randEuint64(uint64 upperBound) internal returns (euint64) {\n        return euint64.wrap(Impl.randBounded(upperBound, Common.euint64_t));\n    }\n\n    // Generates a random encrypted 128-bit unsigned integer.\n    function randEuint128() internal returns (euint128) {\n        return euint128.wrap(Impl.rand(Common.euint128_t));\n    }\n\n    // Generates a random encrypted 128-bit unsigned integer in the [0, upperBound) range.\n    // The upperBound must be a power of 2.\n    function randEuint128(uint128 upperBound) internal returns (euint128) {\n        return euint128.wrap(Impl.randBounded(upperBound, Common.euint128_t));\n    }\n\n    // Generates a random encrypted 256-bit unsigned integer.\n    function randEuint256() internal returns (euint256) {\n        return euint256.wrap(Impl.rand(Common.euint256_t));\n    }\n\n    // Generates a random encrypted 256-bit unsigned integer in the [0, upperBound) range.\n    // The upperBound must be a power of 2.\n    function randEuint256(uint256 upperBound) internal returns (euint256) {\n        return euint256.wrap(Impl.randBounded(upperBound, Common.euint256_t));\n    }\n\n    // Generates a random encrypted 512-bit unsigned integer.\n    function randEbytes64() internal returns (ebytes64) {\n        return ebytes64.wrap(Impl.rand(Common.ebytes64_t));\n    }\n\n    // Generates a random encrypted 1024-bit unsigned integer.\n    function randEbytes128() internal returns (ebytes128) {\n        return ebytes128.wrap(Impl.rand(Common.ebytes128_t));\n    }\n\n    // Generates a random encrypted 2048-bit unsigned integer.\n    function randEbytes256() internal returns (ebytes256) {\n        return ebytes256.wrap(Impl.rand(Common.ebytes256_t));\n    }\n\n    // Convert an inputHandle with corresponding inputProof to an encrypted eaddress.\n    function asEaddress(einput inputHandle, bytes memory inputProof) internal returns (eaddress) {\n        return eaddress.wrap(Impl.verify(einput.unwrap(inputHandle), inputProof, Common.euint160_t));\n    }\n\n    // Convert a plaintext value to an encrypted address.\n    function asEaddress(address value) internal returns (eaddress) {\n        return eaddress.wrap(Impl.trivialEncrypt(uint160(value), Common.euint160_t));\n    }\n\n    // Convert the given inputHandle and inputProof to an encrypted ebytes64 value.\n    function asEbytes64(einput inputHandle, bytes memory inputProof) internal returns (ebytes64) {\n        return ebytes64.wrap(Impl.verify(einput.unwrap(inputHandle), inputProof, Common.ebytes64_t));\n    }\n\n    // Left-pad a bytes array with zeros such that it becomes of length 64.\n    function padToBytes64(bytes memory input) internal pure returns (bytes memory) {\n        require(input.length <= 64, \"Input exceeds 64 bytes\");\n        bytes memory result = new bytes(64);\n        uint256 paddingLength = 64 - input.length;\n        for (uint256 i = 0; i < paddingLength; i++) {\n            result[i] = 0;\n        }\n        for (uint256 i = 0; i < input.length; i++) {\n            result[paddingLength + i] = input[i];\n        }\n        return result;\n    }\n\n    // Convert a plaintext value - must be a bytes array of size 64 - to an encrypted Bytes64.\n    function asEbytes64(bytes memory value) internal returns (ebytes64) {\n        return ebytes64.wrap(Impl.trivialEncrypt(value, Common.ebytes64_t));\n    }\n\n    // Convert the given inputHandle and inputProof to an encrypted ebytes128 value.\n    function asEbytes128(einput inputHandle, bytes memory inputProof) internal returns (ebytes128) {\n        return ebytes128.wrap(Impl.verify(einput.unwrap(inputHandle), inputProof, Common.ebytes128_t));\n    }\n\n    // Left-pad a bytes array with zeros such that it becomes of length 128.\n    function padToBytes128(bytes memory input) internal pure returns (bytes memory) {\n        require(input.length <= 128, \"Input exceeds 128 bytes\");\n        bytes memory result = new bytes(128);\n        uint256 paddingLength = 128 - input.length;\n        for (uint256 i = 0; i < paddingLength; i++) {\n            result[i] = 0;\n        }\n        for (uint256 i = 0; i < input.length; i++) {\n            result[paddingLength + i] = input[i];\n        }\n        return result;\n    }\n\n    // Convert a plaintext value - must be a bytes array of size 128 - to an encrypted Bytes128.\n    function asEbytes128(bytes memory value) internal returns (ebytes128) {\n        return ebytes128.wrap(Impl.trivialEncrypt(value, Common.ebytes128_t));\n    }\n\n    // Convert the given inputHandle and inputProof to an encrypted ebytes256 value.\n    function asEbytes256(einput inputHandle, bytes memory inputProof) internal returns (ebytes256) {\n        return ebytes256.wrap(Impl.verify(einput.unwrap(inputHandle), inputProof, Common.ebytes256_t));\n    }\n\n    // Left-pad a bytes array with zeros such that it becomes of length 256.\n    function padToBytes256(bytes memory input) internal pure returns (bytes memory) {\n        require(input.length <= 256, \"Input exceeds 256 bytes\");\n        bytes memory result = new bytes(256);\n        uint256 paddingLength = 256 - input.length;\n        for (uint256 i = 0; i < paddingLength; i++) {\n            result[i] = 0;\n        }\n        for (uint256 i = 0; i < input.length; i++) {\n            result[paddingLength + i] = input[i];\n        }\n        return result;\n    }\n\n    // Convert a plaintext value - must be a bytes array of size 256 - to an encrypted Bytes256.\n    function asEbytes256(bytes memory value) internal returns (ebytes256) {\n        return ebytes256.wrap(Impl.trivialEncrypt(value, Common.ebytes256_t));\n    }\n\n    // Return true if the enrypted address is initialized and false otherwise.\n    function isInitialized(eaddress v) internal pure returns (bool) {\n        return eaddress.unwrap(v) != 0;\n    }\n\n    // Return true if the enrypted value is initialized and false otherwise.\n    function isInitialized(ebytes64 v) internal pure returns (bool) {\n        return ebytes64.unwrap(v) != 0;\n    }\n\n    // Return true if the enrypted value is initialized and false otherwise.\n    function isInitialized(ebytes128 v) internal pure returns (bool) {\n        return ebytes128.unwrap(v) != 0;\n    }\n\n    // Return true if the enrypted value is initialized and false otherwise.\n    function isInitialized(ebytes256 v) internal pure returns (bool) {\n        return ebytes256.unwrap(v) != 0;\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(ebool a, ebool b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEbool(false);\n        }\n        if (!isInitialized(b)) {\n            b = asEbool(false);\n        }\n        return ebool.wrap(Impl.eq(ebool.unwrap(a), ebool.unwrap(b), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(ebool a, ebool b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEbool(false);\n        }\n        if (!isInitialized(b)) {\n            b = asEbool(false);\n        }\n        return ebool.wrap(Impl.ne(ebool.unwrap(a), ebool.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(ebool a, bool b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEbool(false);\n        }\n        uint256 bProc = b ? 1 : 0;\n        return ebool.wrap(Impl.eq(ebool.unwrap(a), bProc, true));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(bool b, ebool a) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEbool(false);\n        }\n        uint256 bProc = b ? 1 : 0;\n        return ebool.wrap(Impl.eq(ebool.unwrap(a), bProc, true));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(ebool a, bool b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEbool(false);\n        }\n        uint256 bProc = b ? 1 : 0;\n        return ebool.wrap(Impl.ne(ebool.unwrap(a), bProc, true));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(bool b, ebool a) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEbool(false);\n        }\n        uint256 bProc = b ? 1 : 0;\n        return ebool.wrap(Impl.ne(ebool.unwrap(a), bProc, true));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(eaddress a, eaddress b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEaddress(address(0));\n        }\n        if (!isInitialized(b)) {\n            b = asEaddress(address(0));\n        }\n        return ebool.wrap(Impl.eq(eaddress.unwrap(a), eaddress.unwrap(b), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(eaddress a, eaddress b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEaddress(address(0));\n        }\n        if (!isInitialized(b)) {\n            b = asEaddress(address(0));\n        }\n        return ebool.wrap(Impl.ne(eaddress.unwrap(a), eaddress.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(eaddress a, address b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEaddress(address(0));\n        }\n        uint256 bProc = uint256(uint160(b));\n        return ebool.wrap(Impl.eq(eaddress.unwrap(a), bProc, true));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(address b, eaddress a) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEaddress(address(0));\n        }\n        uint256 bProc = uint256(uint160(b));\n        return ebool.wrap(Impl.eq(eaddress.unwrap(a), bProc, true));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(eaddress a, address b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEaddress(address(0));\n        }\n        uint256 bProc = uint256(uint160(b));\n        return ebool.wrap(Impl.ne(eaddress.unwrap(a), bProc, true));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(address b, eaddress a) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEaddress(address(0));\n        }\n        uint256 bProc = uint256(uint160(b));\n        return ebool.wrap(Impl.ne(eaddress.unwrap(a), bProc, true));\n    }\n\n    // If 'control''s value is 'true', the result has the same value as 'a'.\n    // If 'control''s value is 'false', the result has the same value as 'b'.\n    function select(ebool control, ebool a, ebool b) internal returns (ebool) {\n        return ebool.wrap(Impl.select(ebool.unwrap(control), ebool.unwrap(a), ebool.unwrap(b)));\n    }\n\n    // If 'control''s value is 'true', the result has the same value as 'a'.\n    // If 'control''s value is 'false', the result has the same value as 'b'.\n    function select(ebool control, eaddress a, eaddress b) internal returns (eaddress) {\n        return eaddress.wrap(Impl.select(ebool.unwrap(control), eaddress.unwrap(a), eaddress.unwrap(b)));\n    }\n\n    // If 'control''s value is 'true', the result has the same value as 'a'.\n    // If 'control''s value is 'false', the result has the same value as 'b'.\n    function select(ebool control, ebytes64 a, ebytes64 b) internal returns (ebytes64) {\n        return ebytes64.wrap(Impl.select(ebool.unwrap(control), ebytes64.unwrap(a), ebytes64.unwrap(b)));\n    }\n\n    // If 'control''s value is 'true', the result has the same value as 'a'.\n    // If 'control''s value is 'false', the result has the same value as 'b'.\n    function select(ebool control, ebytes128 a, ebytes128 b) internal returns (ebytes128) {\n        return ebytes128.wrap(Impl.select(ebool.unwrap(control), ebytes128.unwrap(a), ebytes128.unwrap(b)));\n    }\n\n    // If 'control''s value is 'true', the result has the same value as 'a'.\n    // If 'control''s value is 'false', the result has the same value as 'b'.\n    function select(ebool control, ebytes256 a, ebytes256 b) internal returns (ebytes256) {\n        return ebytes256.wrap(Impl.select(ebool.unwrap(control), ebytes256.unwrap(a), ebytes256.unwrap(b)));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(ebytes64 a, ebytes64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEbytes64(padToBytes64(hex\"\"));\n        }\n        if (!isInitialized(b)) {\n            b = asEbytes64(padToBytes64(hex\"\"));\n        }\n        return ebool.wrap(Impl.eq(ebytes64.unwrap(a), ebytes64.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(ebytes64 a, bytes memory b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEbytes64(padToBytes64(hex\"\"));\n        }\n        return ebool.wrap(Impl.eq(ebytes64.unwrap(a), b, true));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(bytes memory a, ebytes64 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEbytes64(padToBytes64(hex\"\"));\n        }\n        return ebool.wrap(Impl.eq(ebytes64.unwrap(b), a, true));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(ebytes64 a, ebytes64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEbytes64(padToBytes64(hex\"\"));\n        }\n        if (!isInitialized(b)) {\n            b = asEbytes64(padToBytes64(hex\"\"));\n        }\n        return ebool.wrap(Impl.ne(ebytes64.unwrap(a), ebytes64.unwrap(b), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(ebytes64 a, bytes memory b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEbytes64(padToBytes64(hex\"\"));\n        }\n        return ebool.wrap(Impl.ne(ebytes64.unwrap(a), b, true));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(bytes memory a, ebytes64 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEbytes64(padToBytes64(hex\"\"));\n        }\n        return ebool.wrap(Impl.ne(ebytes64.unwrap(b), a, true));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(ebytes128 a, ebytes128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEbytes128(padToBytes128(hex\"\"));\n        }\n        if (!isInitialized(b)) {\n            b = asEbytes128(padToBytes128(hex\"\"));\n        }\n        return ebool.wrap(Impl.eq(ebytes128.unwrap(a), ebytes128.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(ebytes128 a, bytes memory b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEbytes128(padToBytes128(hex\"\"));\n        }\n        return ebool.wrap(Impl.eq(ebytes128.unwrap(a), b, true));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(bytes memory a, ebytes128 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEbytes128(padToBytes128(hex\"\"));\n        }\n        return ebool.wrap(Impl.eq(ebytes128.unwrap(b), a, true));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(ebytes128 a, ebytes128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEbytes128(padToBytes128(hex\"\"));\n        }\n        if (!isInitialized(b)) {\n            b = asEbytes128(padToBytes128(hex\"\"));\n        }\n        return ebool.wrap(Impl.ne(ebytes128.unwrap(a), ebytes128.unwrap(b), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(ebytes128 a, bytes memory b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEbytes128(padToBytes128(hex\"\"));\n        }\n        return ebool.wrap(Impl.ne(ebytes128.unwrap(a), b, true));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(bytes memory a, ebytes128 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEbytes128(padToBytes128(hex\"\"));\n        }\n        return ebool.wrap(Impl.ne(ebytes128.unwrap(b), a, true));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(ebytes256 a, ebytes256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEbytes256(padToBytes256(hex\"\"));\n        }\n        if (!isInitialized(b)) {\n            b = asEbytes256(padToBytes256(hex\"\"));\n        }\n        return ebool.wrap(Impl.eq(ebytes256.unwrap(a), ebytes256.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(ebytes256 a, bytes memory b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEbytes256(padToBytes256(hex\"\"));\n        }\n        return ebool.wrap(Impl.eq(ebytes256.unwrap(a), b, true));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(bytes memory a, ebytes256 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEbytes256(padToBytes256(hex\"\"));\n        }\n        return ebool.wrap(Impl.eq(ebytes256.unwrap(b), a, true));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(ebytes256 a, ebytes256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEbytes256(padToBytes256(hex\"\"));\n        }\n        if (!isInitialized(b)) {\n            b = asEbytes256(padToBytes256(hex\"\"));\n        }\n        return ebool.wrap(Impl.ne(ebytes256.unwrap(a), ebytes256.unwrap(b), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(ebytes256 a, bytes memory b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEbytes256(padToBytes256(hex\"\"));\n        }\n        return ebool.wrap(Impl.ne(ebytes256.unwrap(a), b, true));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(bytes memory a, ebytes256 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEbytes256(padToBytes256(hex\"\"));\n        }\n        return ebool.wrap(Impl.ne(ebytes256.unwrap(b), a, true));\n    }\n\n    // cleans the transient storage of ACL containing all the allowedTransient accounts\n    // to be used for integration with Account Abstraction or when bundling UserOps calling the FHEVMCoprocessor\n    function cleanTransientStorage() internal {\n        return Impl.cleanTransientStorage();\n    }\n\n    function isAllowed(ebool value, address account) internal view returns (bool) {\n        return Impl.isAllowed(ebool.unwrap(value), account);\n    }\n    function isAllowed(euint4 value, address account) internal view returns (bool) {\n        return Impl.isAllowed(euint4.unwrap(value), account);\n    }\n    function isAllowed(euint8 value, address account) internal view returns (bool) {\n        return Impl.isAllowed(euint8.unwrap(value), account);\n    }\n    function isAllowed(euint16 value, address account) internal view returns (bool) {\n        return Impl.isAllowed(euint16.unwrap(value), account);\n    }\n    function isAllowed(euint32 value, address account) internal view returns (bool) {\n        return Impl.isAllowed(euint32.unwrap(value), account);\n    }\n    function isAllowed(euint64 value, address account) internal view returns (bool) {\n        return Impl.isAllowed(euint64.unwrap(value), account);\n    }\n    function isAllowed(euint128 value, address account) internal view returns (bool) {\n        return Impl.isAllowed(euint128.unwrap(value), account);\n    }\n    function isAllowed(euint256 value, address account) internal view returns (bool) {\n        return Impl.isAllowed(euint256.unwrap(value), account);\n    }\n    function isAllowed(eaddress value, address account) internal view returns (bool) {\n        return Impl.isAllowed(eaddress.unwrap(value), account);\n    }\n\n    function isAllowed(ebytes256 value, address account) internal view returns (bool) {\n        return Impl.isAllowed(ebytes256.unwrap(value), account);\n    }\n\n    function isSenderAllowed(ebool value) internal view returns (bool) {\n        return Impl.isAllowed(ebool.unwrap(value), msg.sender);\n    }\n\n    function isSenderAllowed(euint4 value) internal view returns (bool) {\n        return Impl.isAllowed(euint4.unwrap(value), msg.sender);\n    }\n\n    function isSenderAllowed(euint8 value) internal view returns (bool) {\n        return Impl.isAllowed(euint8.unwrap(value), msg.sender);\n    }\n\n    function isSenderAllowed(euint16 value) internal view returns (bool) {\n        return Impl.isAllowed(euint16.unwrap(value), msg.sender);\n    }\n\n    function isSenderAllowed(euint32 value) internal view returns (bool) {\n        return Impl.isAllowed(euint32.unwrap(value), msg.sender);\n    }\n\n    function isSenderAllowed(euint64 value) internal view returns (bool) {\n        return Impl.isAllowed(euint64.unwrap(value), msg.sender);\n    }\n\n    function isSenderAllowed(euint128 value) internal view returns (bool) {\n        return Impl.isAllowed(euint128.unwrap(value), msg.sender);\n    }\n\n    function isSenderAllowed(euint256 value) internal view returns (bool) {\n        return Impl.isAllowed(euint256.unwrap(value), msg.sender);\n    }\n\n    function isSenderAllowed(eaddress value) internal view returns (bool) {\n        return Impl.isAllowed(eaddress.unwrap(value), msg.sender);\n    }\n\n    function isSenderAllowed(ebytes256 value) internal view returns (bool) {\n        return Impl.isAllowed(ebytes256.unwrap(value), msg.sender);\n    }\n\n    function allow(ebool value, address account) internal {\n        Impl.allow(ebool.unwrap(value), account);\n    }\n\n    function allowThis(ebool value) internal {\n        Impl.allow(ebool.unwrap(value), address(this));\n    }\n\n    function allow(euint4 value, address account) internal {\n        Impl.allow(euint4.unwrap(value), account);\n    }\n\n    function allowThis(euint4 value) internal {\n        Impl.allow(euint4.unwrap(value), address(this));\n    }\n\n    function allow(euint8 value, address account) internal {\n        Impl.allow(euint8.unwrap(value), account);\n    }\n\n    function allowThis(euint8 value) internal {\n        Impl.allow(euint8.unwrap(value), address(this));\n    }\n\n    function allow(euint16 value, address account) internal {\n        Impl.allow(euint16.unwrap(value), account);\n    }\n\n    function allowThis(euint16 value) internal {\n        Impl.allow(euint16.unwrap(value), address(this));\n    }\n\n    function allow(euint32 value, address account) internal {\n        Impl.allow(euint32.unwrap(value), account);\n    }\n\n    function allowThis(euint32 value) internal {\n        Impl.allow(euint32.unwrap(value), address(this));\n    }\n\n    function allow(euint64 value, address account) internal {\n        Impl.allow(euint64.unwrap(value), account);\n    }\n\n    function allowThis(euint64 value) internal {\n        Impl.allow(euint64.unwrap(value), address(this));\n    }\n\n    function allow(euint128 value, address account) internal {\n        Impl.allow(euint128.unwrap(value), account);\n    }\n\n    function allowThis(euint128 value) internal {\n        Impl.allow(euint128.unwrap(value), address(this));\n    }\n\n    function allow(euint256 value, address account) internal {\n        Impl.allow(euint256.unwrap(value), account);\n    }\n\n    function allowThis(euint256 value) internal {\n        Impl.allow(euint256.unwrap(value), address(this));\n    }\n\n    function allow(eaddress value, address account) internal {\n        Impl.allow(eaddress.unwrap(value), account);\n    }\n\n    function allowThis(eaddress value) internal {\n        Impl.allow(eaddress.unwrap(value), address(this));\n    }\n\n    function allow(ebytes64 value, address account) internal {\n        Impl.allow(ebytes64.unwrap(value), account);\n    }\n\n    function allowThis(ebytes64 value) internal {\n        Impl.allow(ebytes64.unwrap(value), address(this));\n    }\n\n    function allow(ebytes128 value, address account) internal {\n        Impl.allow(ebytes128.unwrap(value), account);\n    }\n\n    function allowThis(ebytes128 value) internal {\n        Impl.allow(ebytes128.unwrap(value), address(this));\n    }\n\n    function allow(ebytes256 value, address account) internal {\n        Impl.allow(ebytes256.unwrap(value), account);\n    }\n\n    function allowThis(ebytes256 value) internal {\n        Impl.allow(ebytes256.unwrap(value), address(this));\n    }\n\n    function allowTransient(ebool value, address account) internal {\n        Impl.allowTransient(ebool.unwrap(value), account);\n    }\n\n    function allowTransient(euint4 value, address account) internal {\n        Impl.allowTransient(euint4.unwrap(value), account);\n    }\n\n    function allowTransient(euint8 value, address account) internal {\n        Impl.allowTransient(euint8.unwrap(value), account);\n    }\n\n    function allowTransient(euint16 value, address account) internal {\n        Impl.allowTransient(euint16.unwrap(value), account);\n    }\n\n    function allowTransient(euint32 value, address account) internal {\n        Impl.allowTransient(euint32.unwrap(value), account);\n    }\n\n    function allowTransient(euint64 value, address account) internal {\n        Impl.allowTransient(euint64.unwrap(value), account);\n    }\n\n    function allowTransient(euint128 value, address account) internal {\n        Impl.allowTransient(euint128.unwrap(value), account);\n    }\n\n    function allowTransient(euint256 value, address account) internal {\n        Impl.allowTransient(euint256.unwrap(value), account);\n    }\n\n    function allowTransient(eaddress value, address account) internal {\n        Impl.allowTransient(eaddress.unwrap(value), account);\n    }\n\n    function allowTransient(ebytes64 value, address account) internal {\n        Impl.allowTransient(ebytes64.unwrap(value), account);\n    }\n\n    function allowTransient(ebytes128 value, address account) internal {\n        Impl.allowTransient(ebytes128.unwrap(value), account);\n    }\n\n    function allowTransient(ebytes256 value, address account) internal {\n        Impl.allowTransient(ebytes256.unwrap(value), account);\n    }\n}\n"
    }
  },
  "settings": {
    "metadata": {
      "bytecodeHash": "none",
      "useLiteralContent": true
    },
    "viaIR": true,
    "optimizer": {
      "enabled": true,
      "runs": 800
    },
    "evmVersion": "cancun",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}